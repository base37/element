<style></style>
<template>
    <slot></slot>
</template>
<script>
    export default class extends `HTMLElement` {

        #durability
        #rawValue
        #name
        #value
        #version

        static E_DefaultEventType = 'change'
        static E_ValueProperty = 'value'

        static get observedAttributes() { return (super.observedAttributes || []).concat('durability', 'name') }
        static get E_FlattenableProperties() { return (super.E_FlattenableProperties || []).concat('name', 'version', 'value') }

        async connectedCallback() {
            if (this.hasAttribute('lazy')) return
            const dbName = this.name
            if (!dbName) return
            this.#value = {}
            const request = indexedDB.open(dbName)
            request.onsuccess = event => {
                const db = event.target.result, objectStoreNames = db.objectStoreNames,
                    transaction = db.transaction(objectStoreNames, 'readonly')
                for (let i = 0; i < objectStoreNames.length; i++) {
                    const objectStoreName = objectStoreNames[i], objectStore = transaction.objectStore(objectStoreName)
                    objectStore.getAll().addEventListener('success', event => this.#value[objectStoreName] = event.target.result)
                }
                transaction.addEventListener('complete', event => {
                    this.#version = db.version
                    this.E_emitValueChange(this.#version, 'version')
                    this.E_emitValueChange()
                })
            }
        }

        get durability() { return this.#durability ?? this.getAttribute('durability') }
        set durability(value) { this.#durability = value }

        get name() { return this.#name ?? this.getAttribute('name') }
        set name(value) { this.#name = value }

        get value() { return this.#value }
        set value(value) { if (value && (typeof value === 'object')) this.#setValue(value) }

        get version() { return parseInt(this.#version ?? 0) }

        async #setValue(tree) {
            const dbName = this.name
            if (!dbName) return
            const version = (this.#version ?? 0) + 1
            const request = indexedDB.open(dbName, version)
            request.addEventListener('upgradeneeded', async event => {
                const db = event.target.result
                for (const [storeName, storePut] of Object.entries(tree)) {
                    if (!db.objectStoreNames.contains(storeName)) {
                        const objectStoreElement = this.querySelector(`e-indexeddb-objectstore[name="${storeName}"]`),
                            { keyPath, autoIncrement } = objectStoreElement ?? {}
                        const objectStore = db.createObjectStore(storeName, { keyPath, autoIncrement })
                        await new Promise(resolve => {
                            objectStore.transaction.addEventListener('complete', event => resolve, { once: true })
                        })
                    }
                }
                const transaction = db.transaction(Object.keys(tree), 'readwrite', { durability: this.durability })
                this.#value ||= {}
                for (const [storeName, storePut] of Object.entries(tree)) {
                    this.#value[storeName] = storePut
                    const objectStore = transaction.objectStore(storeName)
                    if (storePut && typeof storePut === 'object') {
                        for (const [k, v] of Object.entries(storePut)) objectStore.put(v, k)
                    } else {
                        objectStore.put(storePut)
                    }
                }
                transaction.addEventListener('complete', event => {
                    this.#version = db.version
                    this.E_emitValueChange(this.#version, 'version')
                    this.E_emitValueChange()
                }, { once: true })
            })
        }

    }

</script>