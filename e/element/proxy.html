<style></style>
<template></template>
<script>
    export default class extends `./map` {

        #contentType

        static portType = 'Proxy'

        constructor() {
            super()
            Object.defineProperty(this, '_getPort', {
                value: (portExpression, signal) => this.#getPort(portExpression, signal)
            })
            Object.defineProperty(this, '_applyFromCells', {
                value: (value, cell, countLabel, counter, event, name) => this.#applyFromCells(value, cell, countLabel, counter, event, name)
            })
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat() }

        #getPort(portExpression, signal) {
            if (!portExpression || (typeof portExpression !== 'string') || !(signal instanceof AbortSignal)) return
            const direction = this.direction, cells = this.cells
            if ((direction !== 'toCell') && (direction !== 'fromCell')) return
            if (!cells) return
            let name, handler
            if (!portExpression.endsWith('`') && (portExpression.indexOf('~') !== -1)) {
                const portExpressionIndexOf = portExpression.indexOf('~')
                if (portExpressionIndexOf) {
                    const portExpressionSplit = portExpression.split('~').map(s => s.trim())
                    name = portExpressionSplit[0]
                    handler = this.E.env.variables[portExpressionSplit[1]]
                } else {
                    name = portExpression.slice(1)
                    handler = this.E.env.variables[name]
                }
            } else if (portExpression.endsWith('`')) {
                const portExpressionIndexOf = portExpression.indexOf('`')
                if (!portExpressionIndexOf || (portExpressionIndexOf === portExpression.lastIndexOf('`'))) return
                name = portExpression.slice(0, portExpressionIndexOf)
                const handlerExpression = portExpression.slice(portExpressionIndexOf).slice(1, -1)
                if (!name || !handlerExpression) return
                const [parentExpression, childExpression] = handlerExpression.split('.').map(s => s.trim())
                if (!parentExpression || (childExpression === '')) return
                let [parentObjectName, ...parentArgs] = parentExpression.split('(').map(s => s.trim())
                parentArgs = parentArgs.join('(').slice(0, -1).trim().split(',').map(s => s.trim())
                const parentIsNewable = parentExpression.includes('(') && parentExpression.endsWith(')')
                let [childMethodName, ...childArgs] = childExpression.split('(').map(s => s.trim())
                childArgs = childArgs.join('(').slice(0, -1).trim().split(',').map(s => s.trim())
                handler = (value, proxyMapElement, init) => {
                    const getParentArgs = () => parentArgs.map(a => a === '$' ? value : proxyMapElement.E.resolveVariables('${' + a.trim() + '}', proxyMapElement))
                    if (init) return parentIsNewable ? new globalThis[parentObjectName](...getParentArgs()) : undefined
                    if (!(this instanceof Object)) return
                    if (childMethodName) {
                        const getChildArgs = () => childArgs.map(a => a === '$' ? value : proxyMapElement.E.resolveVariables('${' + a.trim() + '}', proxyMapElement))
                        if (this.singleton) {
                            if (!(this.singleton instanceof Object)) return
                            if (typeof this.singleton[childMethodName] !== 'function') return
                            return this.singleton[childMethodName](...getChildArgs())
                        } else {
                            if (!(globalThis[parentObjectName] instanceof Object)) return
                            if (typeof globalThis[parentObjectName][childMethodName] !== 'function') return
                            return globalThis[parentObjectName][childMethodName](...getChildArgs())
                        }
                    } else {
                        return this.singleton ? this.singleton(...getParentArgs()) : globalThis[parentObjectName](...getParentArgs())
                    }
                }
            } else { return }
            if (!name || (typeof handler !== 'function')) return
            this.E.env.ports[name] ||= {}
            this.E.env.ports[name].name = name
            this.E.env.ports[name].type = this.constructor.portType
            handler = handler.bind(this.E.env.ports[name])
            this.E.env.ports[name][direction] = { handler, name, direction }
            this.E.env.ports[name].singleton = handler(undefined, this, true)
            return [this.E.env.ports[name], [name]]
        }

        #applyFromCells(value, cell, countLabel, counter, event, name) {
            const handler = this.E.env.ports[name]?.fromCell?.handler
            if (!handler) return
            const port = { name, type: this.E.env.ports[name].type }
            this.E.runTransform(this.transform, value, this, { cell: { value, name: cell.name, [countLabel]: counter }, event, port })
                .then(data => this.contentType ? this.E.serialize(data, this) : data).then(serializedData => handler(serializedData, this))
        }

    }
</script>