<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #listen
        #abortController

        constructor() { super() }

        static get observedAttributes() { return (super.observedAttributes || []).concat(':', 'listen', 'force') }

        async connectedCallback() { }

        get [':']() { return this.listen }
        set [':'](value) { this.listen = value }

        get force() { return this.hasAttribute('force') }
        set force(value) { }

        get listen() { return this.E.utils.safeGet(this, this.#listen, 'listen') }
        set listen(value) {
            if (this.#listen === value) return
            this.#setListen(value)
            this.#listen = value
        }

        #setListen(listenStatement) {
            listenStatement = this.E.resolveVariables(listenStatement, this)
            //console.log('cmap.html: line 30', listenStatement)
            if (!listenStatement) return
            const [sourceExpression, transformExpression, sinkExpression] = listenStatement.split(' >> ').map(s => s.trim()), dirTargetToCell = sourceExpression.includes('|') || sourceExpression.includes('`'),
                cellExpression = dirTargetToCell ? sinkExpression : sourceExpression, targetExpression = dirTargetToCell ? sourceExpression : sinkExpression
            if (!cellExpression || !targetExpression) return
            if (this.#abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            if (dirTargetToCell) {
                const [scopeEventsExpression, selector, valueSourceExpression] = targetExpression.split('|').map(s => s.trim()),
                    [scopeExpression, eventsExpression] = scopeEventsExpression.split('!').map(s => s.trim()),
                    scope = scopeExpression ? this.E.utils.resolveScope(scopeExpression, this) : this.parentElement
                if (!scope) return
                const eventNames = eventsExpression ? eventsExpression.split(',').map(s => s.trim()).filter(s => !!s) : Array.from(new Set(Object.values(this.E.env.options.defaultEventTypes).concat(['click'])))
                for (const eventName of eventNames) {
                    scope.addEventListener(eventName, async event => {
                        if (!event.target.matches(selector)) return
                        if (!eventsExpression && (event.type !== (this.E.env.options.defaultEventTypes[event.target.tagName.toLowerCase()] ?? 'click'))) return
                        const sourceValue = this.E.flatten(this.E.utils.resolveSelector(valueSourceExpression ?? selector, event.currentTarget)),
                            cellNames = this.E.resolveVariables(cellExpression, this).split(',').map(s => s.trim()).filter(s => !!s).map(c => this.E.resolveVariables(c, this)).filter(c => !!c)
                        for (const cellName of cellNames) {
                            const cell = this.E.getCell(cellName).get(), result = await this.E.runTransform(transformExpression, sourceValue, this, { cell, event: this.E.flatten(event) })
                            if (!this.force) if ((result === undefined) || (cell === result) || (JSON.stringify(cell) === JSON.stringify(result))) continue
                            this.E.getCell(cellName).set(result, this.force)
                        }
                    }, { signal: this.#abortController.signal })
                }
            } else {
                const cellNames = this.E.resolveVariables(cellExpression, this).split(',').map(s => s.trim()).filter(s => !!s).map(c => this.E.resolveVariables(c, this)).filter(c => !!c),
                    applyCellValue = (cellValue, cellName, event) => {
                        let targets = this.E.utils.resolveScopedSelector(targetExpression, this)
                        if (!Array.isArray(targets)) targets = [targets]
                        for (const target of targets) this.E.runTransform(transformExpression, cellValue, this, { cell: this.E.getCell(cellName).get(), event }).then(data => this.E.applyData(target, data))
                    }
                for (const cellName of cellNames) {
                    const cell = this.E.getCell(cellName), cellValue = cell.get()
                    if (cellValue !== undefined) applyCellValue(cellValue, cellName)
                    cell.eventTarget.addEventListener('change', event => {
                        applyCellValue(event.detail, cellName, event)
                    }, { signal: this.#abortController.signal })
                }
            }
        }

    }
</script>