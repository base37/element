<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #abortController
        #contentType
        #direction
        #directive
        #cells
        #transform
        #port
        #options

        static get _flattenableProperties() {
            return (super._flattenableProperties || []).concat(['cells', 'direction', 'force', 'port', 'passive', 'prevent', 'transform'])
        }

        constructor() { super() }

        static get observedAttributes() { return (super.observedAttributes || []).concat(':', 'content-type', 'directive', 'options') }

        get ['content-type']() { return this.contentType }
        set ['content-type'](value) { this.contentType = value }

        get contentType() { return this.E.utils.safeGet(this, this.#contentType, 'content-type', 'contentType') }
        set contentType(value) { this.#contentType = value }

        async connectedCallback() { }

        connectFromCells(signal, portTypeSpecificArgs = []) {
            const cells = this.cells
            if (Array.isArray(cells)) {
                for (const [index, cell] of cells.entries()) {
                    const cellValue = cell.get()
                    if (this.force || (cellValue !== undefined)) this._applyFromCells(cellValue, cell, 'index', index, undefined, ...portTypeSpecificArgs)
                    cell.eventTarget.addEventListener('change', event => {
                        if (this.force || (event.detail !== undefined)) this._applyFromCells(event.detail, cell, 'index', index, this.E.flatten(event), ...portTypeSpecificArgs)
                    }, { signal })
                }
            } else if (cells) {
                for (const [key, cell] of Object.entries(cells)) {
                    const cellValue = cell.get()
                    if (this.force || (cellValue !== undefined)) this._applyFromCells(cellValue, cell, 'key', key, undefined, ...portTypeSpecificArgs)
                    cell.eventTarget.addEventListener('change', event => {
                        if (this.force || (event.detail !== undefined)) this._applyFromCells(event.detail, cell, 'key', key, this.E.flatten(event), ...portTypeSpecificArgs)
                    }, { signal })
                }
            }
        }

        async saveToCell(rawValue, cell, cellBindings = {}, transformBindings = {}) {
            const oldValue = cell.get(), force = this.force
            const newValue = await this.E.runTransform(this.transform, rawValue, this, { cell: { value: oldValue, name: cell.name, ...cellBindings }, ...transformBindings })
            if (!force) if ((newValue === undefined) || (oldValue === newValue) || (JSON.stringify(oldValue) === JSON.stringify(newValue))) return
            cell.set(newValue, force)
        }

        get [':']() { return this.directive }
        set [':'](value) { this.directive = value }

        get cells() { return this.#cells }

        get direction() { return this.#direction }

        get directive() { return this.E.utils.safeGet(this, this.#directive, 'directive') }
        set directive(value) {
            if (this.#directive === value) return
            this.#setDirective(value)
            this.#directive = value
        }

        get force() { return this.hasAttribute('force') }
        set force(value) { }

        get options() { return this.E.utils.parseObjectAttribute(this.E.utils.safeGet(this, this.#options, 'options')) }
        set options(value) {
            if (this.#options === value) return
            this.#options = value
        }

        get port() { return this.#port }

        get passive() { return this.hasAttribute('passive') }
        set passive(value) { }

        get prevent() { return this.hasAttribute('prevent') }
        set prevent(value) { }

        get transform() { return this.#transform }

        #setDirective(directive) {
            directive = this.E.resolveVariables(directive, this)
            if (!directive || (typeof directive !== 'string')) return
            let cellsExpression, transformExpression, portExpression
            for (const sep of [' >> ', ' << ']) {
                if ((directive.indexOf(sep) > 0) && (directive.indexOf(sep, directive.indexOf(sep) + 1) > 0)) {
                    [cellsExpression, transformExpression, portExpression] = directive.split(sep).map(s => s.trim())
                    this.#direction = sep === ' << ' ? 'toCell' : 'fromCell'
                    break
                }
            }
            if (!cellsExpression || !transformExpression || !portExpression) return
            if ((cellsExpression[0] === '[') && cellsExpression.endsWith(']')) {
                this.#cells = []
                for (let c of cellsExpression.slice(1, -1).split(',').map(c => c.trim()).filter(c => c)) this.#cells.push(this.E.getCell(c.trim()))
            } else if ((cellsExpression[0] === '{') && cellsExpression.endsWith('}')) {
                this.#cells = {}
                for (let cp of cellsExpression.slice(1, -1).split(',').map(c => c.trim()).filter(c => c)) {
                    let [cellKey, cellName] = cp.split(':').map(c => c.trim())
                    if (!cellName) cellName = cellKey
                    this.#cells[cellKey] = this.E.getCell(cellName)
                }
            } else {
                this.#cells = [this.E.getCell(cellsExpression)]
            }
            this.#transform = transformExpression
            if (this.#abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            const signal = this.#abortController.signal, [port, portTypeSpecificArgs] = this._getPort(portExpression, signal)
            this.#port = port
            if (this.#direction === 'toCell') {
                if (!this.passive) this.touch()
            } else if (this.#direction === 'fromCell') {
                this.connectFromCells(signal, portTypeSpecificArgs)
            }
        }

        _applyToCells(value) {
            const cells = this.cells
            if (Array.isArray(cells)) {
                for (const [index, cell] of cells.entries()) this.saveToCell(value, cell, { index }, { event })
            } else if (cells) {
                for (const [key, cell] of Object.entries(cells)) this.saveToCell(value, cell, { key }, { event })
            }
        }

        touch() {
            const handler = (this.port ?? {})[this.direction]?.handler
            if (!handler) return
            const value = handler(undefined, this)
            Promise.resolve(this.contentType ? this.E.parse(value, this) : value).then(parsedValue => this._applyToCells(parsedValue))
        }


    }
</script>