<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #abortController
        #direction
        #directive
        #cells
        #transform
        #port
        #options

        constructor() { super() }

        static get observedAttributes() { return (super.observedAttributes || []).concat(':', 'directive', 'options') }

        async connectedCallback() { }

        connectFromCells(signal, portTypeSpecificArgs = []) {
            const cells = this.cells
            if (Array.isArray(cells)) {
                for (const [index, cell] of cells.entries()) {
                    const cellValue = cell.get()
                    if (this.force || (cellValue !== undefined)) this.applyCellValue(cellValue, cell, 'index', index)
                    cell.eventTarget.addEventListener('change', event => {
                        if (this.force || (event.detail !== undefined)) this.applyCellValue(event.detail, cell, 'index', index, this.E.flatten(event), ...portTypeSpecificArgs)
                    }, { signal })
                }
            } else if (cells) {
                for (const [key, cell] of Object.entries(cells)) {
                    const cellValue = cell.get()
                    if (this.force || (cellValue !== undefined)) this.applyCellValue(cellValue, cell, 'key', key)
                    cell.eventTarget.addEventListener('change', event => {
                        if (this.force || (event.detail !== undefined)) this.applyCellValue(event.detail, cell, 'key', key, this.E.flatten(event), ...portTypeSpecificArgs)
                    }, { signal })
                }
            }
        }

        async saveToCell(rawValue, cell, cellBindings = {}, transformBindings = {}) {
            const oldValue = cell.get(), force = this.force,
                newValue = await this.E.runTransform(this.transform, rawValue, this, { cell: { value: oldValue, name: cell.name, ...cellBindings }, ...transformBindings })
            if (!force) if ((newValue === undefined) || (oldValue === newValue) || (JSON.stringify(oldValue) === JSON.stringify(newValue))) return
            cell.set(newValue, force)
        }

        get [':']() { return this.directive }
        set [':'](value) { this.directive = value }

        get cells() { return this.#cells }

        get direction() { return this.#direction }

        get directive() { return this.E.utils.safeGet(this, this.#directive, 'directive') }
        set directive(value) {
            if (this.#directive === value) return
            this.#setDirective(value)
            this.#directive = value
        }

        get force() { return this.hasAttribute('force') }
        set force(value) { }

        get port() { return this.#port }

        get prevent() { return this.hasAttribute('prevent') }
        set prevent(value) { }

        get transform() { return this.#transform }

        #setDirective(directive) {
            directive = this.E.resolveVariables(directive, this)
            if (!directive || (typeof directive !== 'string')) return
            let cellsExpression, transformExpression, portExpression
            for (const sep of [' >> ', ' << ']) {
                if ((directive.indexOf(sep) > 0) && (directive.indexOf(sep, directive.indexOf(sep) + 1) > 0)) {
                    [cellsExpression, transformExpression, portExpression] = directive.split(sep).map(s => s.trim())
                    this.#direction = sep === ' << ' ? 'toCell' : 'fromCell'
                    break
                }
            }
            cellsExpression = this.E.resolveVariables(cellsExpression, this).trim()
            if (!cellsExpression) return
            transformExpression = this.E.resolveVariables(transformExpression).trim()
            if (!transformExpression) return
            portExpression = this.E.resolveVariables(portExpression).trim()
            if (!portExpression) return

            if ((cellsExpression[0] === '[') && cellsExpression.endsWith(']')) {
                this.#cells = []
                for (let c of cellsExpression.slice(1, -1).split(',')) this.#cells.push(this.E.getCell(this.E.resolveVariables(c.trim(), this)))
            } else if ((cellsExpression[0] === '[') && cellsExpression.endsWith(']')) {
                this.#cells = {}
                for (let cp of cellsExpression.slice(1, -1).split(',')) {
                    let [cellKey, cellName] = cp.split(':')
                    this.#cells[this.E.resolveVariables(cellKey.trim(), this)] = this.E.getCell(this.E.resolveVariables(cellName.trim(), this))
                }
            } else {
                this.#cells = [this.E.getCell(this.E.resolveVariables(cellsExpression, this))]
            }
            this.#transform = transformExpression

            if (this.#abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            this.#port = this._getPort(portExpression, this.#abortController.signal)
        }

    }
</script>