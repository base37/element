<style></style>
<template></template>
<script>
    export default class extends `meta` {

        static channels = {}
        static idle = window.requestIdleCallback || ((cb) => setTimeout(cb, 0))
        static garbageCollector = 0

        #listen
        #abortController

        constructor() {
            super()
            if (!this.constructor.garbageCollector) {
                this.constructor.garbageCollector = window.setInterval(() => {
                    this.constructor.idle(() => {
                        for (const channel of Object.values(this.constructor.channels)) channel.history = channel.history.filter(entry => entry.expires > Date.now())
                    })
                }, 1000)

            }
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('listen') }

        async connectedCallback() { }

        get listen() { return this.E.utils.safeGet(this, this.#listen, 'listen') }
        set listen(value) {
            if (this.#listen === value) return
            this.#setListen(value)
            this.#listen = value
        }

        #setListen(listenStatement) {
            if (!listenStatement) return
            const [sourceExpression, transformExpression, sinkExpression] = listenStatement.split(' >> ').map(s => s.trim()), dirTargetToChannel = sourceExpression.includes('|') || sourceExpression.includes('`'),
                channelExpression = dirTargetToChannel ? sinkExpression : sourceExpression, targetExpression = dirTargetToChannel ? sourceExpression : sinkExpression
            if (!channelExpression || !targetExpression) return
            if (dirTargetToChannel) {
                const [scopeEventsExpression, selector, valueSourceExpression] = targetExpression.split('|').map(s => s.trim()),
                    [scopeExpression, eventsExpression] = scopeEventsExpression.split('!').map(s => s.trim()),
                    scope = scopeExpression ? this.closest(scopeExpression) : this.parentElement
                if (!scope) return
                const eventNames = eventExpression ? eventExpression.split(',').map(s => s.trim()).filter(s => !!s) : Array.from(new Set(Object.values(E.env.options.defaultEventTypes)))
                if (this.#abortController) this.#abortController.abort()
                this.#abortController = new AbortController()
                for (const eventName in eventNames) {
                    scope.addEventListener(eventName, async event => {
                        if (!event.target.matches(selector)) return
                        if (!eventExpression && (event.type !== (E.env.options.defaultEventTypes[event.target.tagName.toLowerCase()] ?? 'click'))) return
                        const sourceValue = this.E.utils.flatten(this.E.utils.resolveSelector(event.currentTarget, valueSourceExpression)),
                            messagePayload = await this.E.runTransform(transformExpression, sourceValue, undefined, this)
                        if (messagePayload === undefined) return
                        const channelNames = this.E.resolveVariables(channelExpression, this).split(',').map(s => s.trim()).filter(s => !!s).map(c => this.E.resolveVariables(c, this))
                        for (const channelNameMessageTtl of channelNames) {
                            const [channelName, channelMessageTtl] = channelNameMessageTtl.split(':').map(s => s.trim())
                            if (!channelName) continue
                            this.constructor.channels[channelName] ||= { endpoint: new BroadcastChannel(channelName), history: [] }
                            const messageExpires = channelMessageTtl ? (Date.now() + (parseInt(channelMessageTtl) || 0)) : Infinity, message = { payload: messagePayload, expires: messageExpires, source: event.target, scope: event.currentTarget }
                            this.constructor.channels[channelName].endpoint.postMessage(message)
                            if (message.expires > Date.now()) this.constructor.channels[channelName].history.push(message)
                        }
                    }, { signal: this.#abortController.signal })
                }
            } else {
                const channelNames = this.E.resolveVariables(channelExpression, this).split(',').map(s => s.trim()).filter(s => !!s).map(c => this.E.resolveVariables(c, this))
                const processMessage = message => {
                    const { payload, expires, source, scope } = event.data
                    let targets = this.E.utils.resolveScopedSelector(targetExpression, this)
                    if (!Array.isArray(targets)) targets = [targets]
                    for (const target of targets) {
                        this.E.runTransform(transformExpression, payload, this.E.flatten(target), this).then(applyData => {
                            this.E.sinkData(target, applyData, undefined, undefined, this, event.data)
                        })
                    }
                }
                for (const channelName of channelNames) {
                    if (!channelName) continue
                    this.constructor.channels[channelName] ||= { endpoint: new BroadcastChannel(channelName), history: [] }
                    if (this.#abortController) this.#abortController.abort()
                    this.#abortController = new AbortController()
                    this.constructor.channels[channelName].endpoint.addEventListener('message', async event => processMessage(event.data), { signal: this.#abortController.signal })
                    for (const message of this.constructor.channels[channelName].history) processMessage(message)
                }
            }
        }

    }
</script>