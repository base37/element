<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #abortController
        #direction
        #directive
        #cells
        #transform
        #port
        #options

        constructor() { super() }

        static get observedAttributes() { return (super.observedAttributes || []).concat(':', 'directive', 'options') }

        async connectedCallback() { }

        setToCell = async (cell, countLabel, counter) => {
            const value = cell.get(), result = await this.E.runTransform(transform, sourceValue, this, { cell: { value, name: cell.name, [countLabel]: counter }, event: this.E.flatten(event) })
            if (!force) if ((result === undefined) || (value === result) || (JSON.stringify(value) === JSON.stringify(result))) return
            cell.set(result, force)
        }


        async saveToCell(value, cell, cellBindings = {}, transformBindings = {}) {
            const cellValue = cell.get(), force = this.force,
                result = await this.E.runTransform(this.transform, value, this, { cell: { value: cellValue, name: cell.name, ...cellBindings }, ...transformBindings })
            if (!force) if ((result === undefined) || (cellValue === result) || (JSON.stringify(cellValue) === JSON.stringify(result))) return
            cell.set(result, force)
        }

        get [':']() { return this.directive }
        set [':'](value) { this.directive = value }

        get cells() { return this.#cells }

        get direction() { return this.#direction }

        get directive() { return this.E.utils.safeGet(this, this.#directive, 'directive') }
        set directive(value) {
            if (this.#directive === value) return
            this.#setDirective(value)
            this.#directive = value
        }

        get force() { return this.hasAttribute('force') }
        set force(value) { }

        get port() { return this.#port }

        get prevent() { return this.hasAttribute('prevent') }
        set prevent(value) { }

        get transform() { return this.#transform }

        #setDirective(directive) {
            directive = this.E.resolveVariables(directive, this)
            if (!directive || (typeof directive !== 'string')) return
            let cellsExpression, transformExpression, portExpression
            for (const sep of [' >> ', ' << ']) {
                if ((directive.indexOf(sep) > 0) && (directive.indexOf(sep, directive.indexOf(sep) + 1) > 0)) {
                    [cellsExpression, transformExpression, sinkExpression] = directive.split(sep).map(s => s.trim())
                    this.#direction = sep === ' << ' ? 'toCell' : 'fromCell'
                    break
                }
            }
            cellsExpression = this.E.resolveVariables(cellsExpression, this).trim()
            if (!cellsExpression) return
            transformExpression = this.E.resolveVariables(transformExpression).trim()
            if (!transformExpression) return
            portExpression = this.E.resolveVariables(portExpression).trim()
            if (!portExpression) return

            if ((cellsExpression[0] === '[') && cellsExpression.endsWith(']')) {
                this.#cells = []
                for (let c of cellsExpression.slice(1, -1).split(',')) this.#cells.push(this.E.getCell(this.E.resolveVariables(c.trim(), this)))
            } else if ((cellsExpression[0] === '[') && cellsExpression.endsWith(']')) {
                this.#cells = {}
                for (let cp of cellsExpression.slice(1, -1).split(',')) {
                    let [cellKey, cellName] = cp.split(':')
                    this.#cells[this.E.resolveVariables(cellKey.trim(), this)] = this.E.getCell(this.E.resolveVariables(cellName.trim(), this))
                }
            } else {
                this.#cells = [this.E.getCell(this.E.resolveVariables(cellsExpression, this))]
            }
            this.#transform = transformExpression

            if (this.#abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            this.#port = this._getPort(portExpression, this.#abortController.signal)
        }

    }
</script>