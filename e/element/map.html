<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #listen
        #abortController

        constructor() { super() }

        static get observedAttributes() { return (super.observedAttributes || []).concat('listen') }

        async connectedCallback() { }

        get listen() { return this.E.utils.safeGet(this, this.#listen, 'listen') }
        set listen(value) {
            if (this.#listen === value) return
            this.#setListen(value)
            this.#listen = value
        }

        #setListen(listenStatement) {
            if (!listenStatement) return
            const [sourceExpression, transformExpression, sinkExpression] = listenStatement.split(' >> ').map(s => s.trim()), dirTargetToCell = sourceExpression.includes('|') || sourceExpression.includes('`'),
                cellExpression = dirTargetToCell ? sinkExpression : sourceExpression, targetExpression = dirTargetToCell ? sourceExpression : sinkExpression
            if (!cellExpression || !targetExpression) return
            if (this.#abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            if (dirTargetToCell) {
                const [scopeEventsExpression, selector, valueSourceExpression] = targetExpression.split('|').map(s => s.trim()),
                    [scopeExpression, eventsExpression] = scopeEventsExpression.split('!').map(s => s.trim()),
                    scope = scopeExpression ? this.closest(scopeExpression) : this.parentElement
                if (!scope) return
                const eventNames = eventsExpression ? eventsExpression.split(',').map(s => s.trim()).filter(s => !!s) : Array.from(new Set(Object.values(E.env.options.defaultEventTypes)))
                for (const eventName of eventNames) {
                    scope.addEventListener(eventName, async event => {
                        if (!event.target.matches(selector)) return
                        if (!eventsExpression && (event.type !== (E.env.options.defaultEventTypes[event.target.tagName.toLowerCase()] ?? 'click'))) return
                        const sourceValue = this.E.flatten(this.E.utils.resolveSelector(event.currentTarget, valueSourceExpression ?? selector)),
                            value = await this.E.runTransform(transformExpression, sourceValue, undefined, this),
                            cellNames = this.E.resolveVariables(cellExpression, this).split(',').map(s => s.trim()).filter(s => !!s).map(c => this.E.resolveVariables(c, this)).filter(c => !!c)
                        for (const cellName of cellNames) this.E.getCell(cellName).set(value)
                    }, { signal: this.#abortController.signal })
                }
            } else {
                const cellNames = this.E.resolveVariables(cellExpression, this).split(',').map(s => s.trim()).filter(s => !!s).map(c => this.E.resolveVariables(c, this)).filter(c => !!c)
                for (const cellName of cellNames) {
                    this.E.getCell(cellName).eventTarget.addEventListener('change', event => {
                        let targets = this.E.utils.resolveScopedSelector(targetExpression, this)
                        if (!Array.isArray(targets)) targets = [targets]
                        for (const target of targets) this.E.runTransform(transformExpression, event.detail, this.E.flatten(target), this).then(data => this.E.applyData(target, data))
                    }, { signal: this.#abortController.signal })
                }
            }
        }

    }
</script>