<style></style>
<template>
    <slot></slot>
</template>
<script>
    export default class extends `script` {

        #abortController
        #context = {}
        #slots = {}
        #src
        #statements = []
        #type

        constructor() { super() }

        static get observedAttributes() { return (super.observedAttributes || []).concat('src', 'type') }

        async connectedCallback() {
            let code = this.textContent ?? ''
            const src = this.src, type = this.type ?? 'script/flow'
            if (src) code = [await fetch(src).then(r => r.text()), code].join('/n/n')
            if (!code) return
            if (this.#abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            let splitter = /\n/gm
            if (type === 'script/flow') splitter = /\n(?!\s+>>)/gm
            if (type === 'text/flow') splitter = /\n\s*\n/gm
            const codeStatements = [], isNumeric = /^[0-9\.]+$/
            for (let s of code.split(splitter)) if (s = s.trim()) if (s.slice(0, 2) !== '# ') codeStatements.push(s)
            for (const codeStatement of codeStatements) {
                const codeStatementSlice03 = codeStatement.slice(0, 3)
                if (codeStatementSlice03 === '#! ') {
                    this.#statements.push([this.#parseContextStatement(codeStatement.slice(3))])
                    continue
                }
                const codeExpressions = [], steps = []
                for (let [index, codeExpression] of codeStatement.split(' >> ').entries()) {
                    codeExpression = codeExpression.trim()
                    if (!index) steps.push(this.#parseTriggerExpression(codeExpression))
                    if (!codeExpression) continue
                    switch (codeExpression[0]) {
                        case '!':
                            steps.push(this.#parseEventTargetExpression(codeExpression.slice(1)))
                            break
                        case '`':
                            steps.push(this.#parseProxyExpression(codeExpression.slice(1, -1)))
                            break
                        case '/':
                            steps.push(this.#parseRegExpExpression(codeExpression.slice(1, -1)))
                            break
                        case '"':
                        case "'":
                            steps.push(this.#parseStringExpression(codeExpression.slice(1, -1)))
                            break
                        case "#":
                            steps.push(this.#parseCellExpression(codeExpression.slice(1)))
                            break
                        case "%":
                            steps.push(this.#parseSlotExpression(codeExpression.slice(1)))
                            break
                        case "$":
                            steps.push(this.#parseSelectorExpression(codeExpression.slice(2, -1)))
                            break
                        case "(":
                            steps.push(this.#parseTransformExpression(codeExpression))
                            break
                        case "{":
                        case "n":
                        case "t":
                        case "f":
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "7":
                        case "9":
                            if (codeExpression === 'null' || codeExpression === 'true' || codeExpression === 'false'
                                || codeExpression.match(isNumeric)) {
                                steps.push(this.#parseJSONExpression(codeExpression))
                            } else {
                                steps.push(this.#parseRemoteExpression(codeExpression))
                            }
                            break
                        default:
                            steps.push(this.#parseRemoteExpression(codeExpression))
                    }
                }



            }
            let context = { ...this.E.env.context }
            for (const statement of this.#statements) {
                const triggerExpression = statement[0], context = { ...context }
                const statementProcessor = async (result) => {
                    let labels = {}
                    for (const expression of statement) {
                        const [label, expressionHandler, defaultValue] = expression
                        result = (await expressionHandler(result, labels, this.#slots, this.E.env.cells, context)) ?? defaultValue
                        if (result == undefined) break
                        labels[label] = result
                    }
                }
                const [triggerTarget, eventNames] = triggerExpression
                if (triggerTarget && Array.isArray(eventNames) && eventNames.length) {
                    if (triggerTarget instanceof HTMLElement) {
                        let [selector, eventList] = eventNames[0].split('!'), eventNames, useDefaultEvents
                        if (eventList) {
                            eventNames = eventList.split(',').map(s => s.trim()).filter(s => !!s)
                        } else {
                            eventNames = Array.from(new Set(Object.values(this.E.env.options.defaultEventTypes).concat(['click'])))
                            useDefaultEvents = true
                        }
                        for (const eventName of eventNames) {
                            triggerTarget.addEventListener(eventName, event => {
                                if (useDefaultEvents && (event.type !== (this.E.env.options.defaultEventTypes[event.target.tagName.toLowerCase()] ?? 'click'))) return
                                if (selector && !event.target.matches(selector)) return
                                statementProcessor(this.E.flatten(event.target))
                            }, { signal: this.#abortController.signal })
                        }
                    } else if (triggerTarget instanceof EventTarget) {
                        for (const eventName of eventNames) triggerTarget.addEventListener(eventName, statementProcessor)
                    } else if (Array.isArray(triggerTarget)) {
                        for (const [index, valueStore] of triggerTarget.entries()) {
                            valueStore.eventTarget.addEventListener('change', event => {
                                statementProcessor(valueStore.get())
                            })
                        }
                    } else if (triggerTarget instanceof Object) {
                        for (const [key, valueStore] of Object.entries(triggerTarget)) {
                            valueStore.eventTarget.addEventListener('change', event => {
                                statementProcessor(valueStore.get())
                            })
                        }
                    }
                } else {
                    await statementProcessor()
                }
            }
        }

        disconnectedCallback() { }

        get src() { return this.E.utils.safeGet(this, this.#src, 'src') }
        set src(value) { this.#src = value }

        get type() { return this.E.utils.safeGet(this, this.#type, 'type') }
        set type(value) { this.#type = value }

        #getSlot(name) {
            if (!name) return
            if (!this.#slots[name]) {
                const slot = {
                    eventTarget: new EventTarget(),
                    get: function () { return this.value },
                    set: function (value, force) {
                        if (this.value === value) {
                            if (force) slot.eventTarget.dispatchEvent(new CustomEvent('change', { detail: value }))
                            return
                        }
                        this.value = value
                        slot.eventTarget.dispatchEvent(new CustomEvent('change', { detail: value }))
                    },
                    value: undefined, name
                }
                this.#slots[name] = cell
            }
            return this.#slots[name]
        }

        #parseContextStatement = (statementCode) => {
            const pairs = {}
            for (const s of statementCode.slice(3).trim().slice(1, -1).trim().split(',')) {
                let [k, v] = s.trim().split(':').map(s => s.trim())
                if (k[0] === '"' || k[0] === "'") k = k.slice(1, -1)
                pairs[k] = v ?? k
            }
            return [0, (result, labels, slots, cells, context) => {
                for (const [k, v] of pairs) context[k] = this.E.resolveVariables(v ?? k, this)
            }, undefined]
        }

        #parseTriggerExpression = (expressionCode) => {
            switch (expressionCode[0]) {
                case '!':
                    expressionCode = expressionCode.slice(1)
                    if (expressionCode === '#') {
                        return [window, ['hashchange']]
                    } else {
                        const [eventTargetName, eventNames] = expressionCode.split(' ')
                        this.E.env.eventTargets[eventTargetName.trim()] ||= new EventTarget()
                        return [this.E.env.eventTargets[eventTargetName], eventNames.trim().split(',').map(s => s.trim()).filter(s => !!s)]
                    }
                case '%':
                case '#':
                    const targetType = expressionCode[0], expressionCode = expressionCode.slice(1).trim()
                    let target
                    if ((expressionCode[0] === '{') && expressionCode.endsWith('}')) {
                        targets = {}
                        for (const pair of expressionCode.slice(1, -1).trim().split(',')) {
                            let [targetKey, targetName] = pair.trim().split(':').map(s => s.trim())
                            if (!targetName) targetName = targetKey
                            pairs[targetKey] = targetType === '%' ? this.#getSlot(targetName.trim()) : this.E.getCell(targetName.trim())
                        }
                    } else if ((expressionCode[0] === '[') && expressionCode.endsWith(']')) {
                        target = []
                        for (const t of expressionCode.split(',')) {
                            targets.push(targetType === '%' ? this.#getSlot(t.trim()) : this.E.getCell(t.trim()))
                        }
                    } else {
                        target = [(targetType === '%' ? this.#getSlot(expressionCode) : this.E.getCell(expressionCode))]
                    }
                    return [target, ['change']]
                case '$':
                    let scopedSelector = expressionCode.slice(2, -1)
                    if (!scopedSelector) scopedSelector = ':|'
                    if (!scopedSelector.includes('|')) scopedSelector = `:|${scopedSelector}`
                    const [scopeStatement, selector] = scopedSelector.split('|').map(s => s.trim()),
                        scope = this.E.utils.resolveScope(scopeStatement, this)
                    return [scope, [selector]]
            }
        }


    }
</script>