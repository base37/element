<style></style>
<template>
    <field></field>
</template>
<script>
    export default class extends `script` {

        #abortController
        #handlers = []
        #cellNames = []
        #context = {}
        #fieldNames = []
        #fields = {}
        #src
        #statements = []
        #type
        #init = {}
        #keyedAbortControllers = {}

        get handlers() { return this.#handlers }
        get cellNames() { return this.#cellNames }
        get fieldNames() { return this.#fieldNames }
        get fields() { return this.#fields }
        get statements() { return this.#statements }
        get init() { return this.#init }


        constructor() {
            super()
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('src', 'type') }

        #loadApplication(handlers = [], fieldNames = [], cellNames = [], statements = [], init = {}) {
            this.#handlers = Object.freeze(handlers)//each one function(value, labels, env) => returns value
            this.#fields ||= {}
            for (const fieldName of fieldNames) this.#fields[fieldName] = this.#getField(fieldName)
            Object.freeze(this.#fields)
            this.#fieldNames = Object.freeze(fieldNames)
            this.#cellNames = Object.freeze(cellNames)
            this.#statements = Object.freeze(statements) // { labels = {}, steps = [ [label, handlerIndex, defaultValue] ] }
            this.#init = Object.freeze(init) // key => % or # name , value => function whose return value is assigned to that field or cell
        }

        #runApplication() {
            if (this.#abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            const rootNode = this.getRootNode(),
                context = Object.freeze(rootNode instanceof ShadowRoot
                    ? { ...this.E.env.context, ...Object.fromEntries(Object.entries(rootNode.host.dataset)) } : this.E.env.context),
                env = Object.freeze({ fields: {}, cells: {}, context })
            for (const fieldName of this.#fieldNames) env.fields[fieldName] = this.#getField(fieldName)
            for (const cellName of this.#cellNames) env.cells[cellName] = this.E.getCell(cellName)
            Object.freeze(env.fields)
            Object.freeze(env.cells)
            for (const [statementIndex, statement] of this.#statements.entries()) {
                const { labels = {}, steps = [] } = statement
                for (const [stepIndex, step] of steps.entries()) {
                    const [label, handlerIndex, defaultValue] = step
                    this.addEventListener(stepIndex ? `done-${statementIndex}-${stepIndex - 1}` : 'run', async event => {
                        let detail = (await this.#handlers[handlerIndex](event.detail, { ...labels }, env, statementIndex, stepIndex)) ?? this.#getVariable(defaultValue)
                        switch (label[0]) {
                            case '%':
                                env.fields[label.slice(1)].set(detail)
                                break
                            case '#':
                                env.cells[label.slice(1)].set(detail)
                                break
                            default:
                                labels[label] = detail
                        }
                        labels[`${stepIndex}`] = detail
                        if (detail != undefined) this.dispatchEvent(new CustomEvent(`done-${statementIndex}-${stepIndex}`, { detail }))
                    }, { signal: this.#abortController.signal })
                }
            }
            const promises = []
            this.dispatchEvent(new CustomEvent('initStart'))
            for (const [name, func] of Object.entries(this.#init)) {
                if (typeof func !== 'function') continue
                promises.push(Promise.resolve(func(this, env)).then(initValue => {
                    switch (name[0]) {
                        case '%':
                            (env.fields[name.slice(1)] ?? {}).value = initValue
                            break
                        case '#':
                            (env.cells[name.slice(1)] ?? {}).value = initValue
                            break
                        default:
                            (env.fields[name] ?? env.cells[name] ?? {}).value = initValue
                    }
                }))
            }
            Promise.all(promises).then(() => {
                this.dispatchEvent(new CustomEvent('initEnd'))
                this.dispatchEvent(new CustomEvent('run'))
            })
        }

        async #parseApplication(code) {
            const textAsModule =
                `const E = globalThis['${this.E._globalNamespace}']; ${code};`,
                moduleAsUrl = URL.createObjectURL(new Blob([textAsModule], { type: 'text/javascript' })),
                classModule = await import(moduleAsUrl), { handlers = [], fieldNames = [], cellNames = [], statements = [], init = {} } = classModule
            URL.revokeObjectURL(moduleAsUrl)
            this.#loadApplication(handlers, fieldNames, cellNames, statements, init)
        }

        #parseInit(directive) {
            if (!directive) return {}
            const init = {}, isNumeric = /^[0-9\.]+$/
            for (let segment of directive.split(' !! ')) {
                segment = segment.trim()
                if (!segment) continue // ` " ' $ ( { n t f 0-9 
                let [label, ...expression] = segment.split(': ')
                expression = expression.join(': ').trim()
                label = label.trim()
                if (!label || !expression) continue
                switch (expression[0]) {
                    case '`':
                        init[label] = this.#parseProxyExpression(expression.slice(1, -1), true)
                        break
                    case '"':
                    case "'":
                        init[label] = this.#parseStringExpression(expression.slice(1, -1), true)
                        break
                    case "$":
                        init[label] = this.#parseVariableExpression(expression.slice(2, -1), true)
                        break
                    case '{':
                        init[label] = this.#parseJSONExpression(expression, true)
                        break
                    case 'n':
                    case 't':
                    case 'f':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        if (expression === 'null' || expression === 'true' || expression === 'false'
                            || expression.match(isNumeric)) {
                            init[label] = this.#parseJSONExpression(expression, true)
                        }
                    case '~':
                        if (expression.endsWith('~')) {
                            init[label] = this.#parseRemoteExpression(expression.slice(1, -1), true)
                            break
                        }
                    default:
                        init[label] = this.#parseRemoteExpression(expression, true)
                }
            }
            return init
        }

        #compileScript(code) {
            const handlers = [], fieldNames = new Set(), cellNames = new Set(), statements = [], init = {},
                splitter = /\n(?!\s+>>)/gm, isNumeric = /^[0-9\.]+$/, handlerMap = {}
            for (let directive of code.split(splitter)) {
                directive = directive.trim()
                if (!directive || (directive.slice(0, 2) === '# ')) continue
                if (directive.slice(0, 3) === '#! ') {
                    Object.assign(init, this.#parseInit(directive.slice(3).trim()))
                    continue
                }
                const statement = { labels: {}, steps: [] }, directiveSlice03 = directive.slice(0, 3)
                for (let [index, segment] of directive.split(' >> ').entries()) {
                    segment = segment.trim()
                    if (!segment) continue
                    const step = []
                    let label, handlerExpression = segment, defaultExpression
                    const labelMatch = handlerExpression.match(/^([a-z0-9]+):\s+/)
                    if (labelMatch) {
                        label = labelMatch[1].trim()
                        handlerExpression = handlerExpression.slice(labelMatch[0].length).trim()
                    }
                    const defaultExpressionMatch = handlerExpression.match(/\s+\?\?\s+(.+)\s*$/)
                    if (defaultExpressionMatch) {
                        defaultExpression = defaultExpressionMatch[1].trim()
                        handlerExpression = handlerExpression.slice(0, defaultExpressionMatch.index).trim()
                    }
                    label ||= `${index}`
                    step.push(label)
                    switch (label[0]) {
                        case '%':
                            fieldNames.add(label.slice(1))
                            break
                        case '#':
                            cellNames.add(label.slice(1))
                            break
                        default:
                            statement.labels[label] = undefined
                    }
                    let handler, handlerIndex
                    switch (handlerExpression[0]) {
                        case '!':
                            handler = this.#parseEventTargetExpression(handlerExpression.slice(1))
                            break
                        case '`':
                            handler = this.#parseProxyExpression(handlerExpression.slice(1, -1))
                            break
                        case '/':
                            handler = this.#parseRegExpExpression(handlerExpression.slice(1, -1))
                            break
                        case '"':
                        case "'":
                            handler = this.#parseStringExpression(handlerExpression.slice(1, -1))
                            break
                        case "#":
                        case "%":
                            let addedNames
                            [handler, addedNames] = this.#parseFieldOrCellExpression(handlerExpression.slice(1), handlerExpression[0])
                            const names = handlerExpression[0] === '#' ? cellNames : fieldNames
                            for (const addedName of addedNames) names.add(addedName)
                            break
                        case "$":
                            if (handlerExpression[1] === "{") {
                                handler = this.#parseVariableExpression(handlerExpression.slice(2, -1))
                            } else if (handlerExpression[1] === "(") {
                                handler = this.#parseSelectorExpression(handlerExpression.slice(2, -1))
                            }
                            break
                        case "(":
                            handler = this.#parseTransformExpression(handlerExpression)
                            break
                        case "{":
                            handler = this.#parseJSONExpression(handlerExpression)
                            break
                        case "n":
                        case "t":
                        case "f":
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "7":
                        case "9":
                            if (handlerExpression === 'null' || handlerExpression === 'true' || handlerExpression === 'false'
                                || handlerExpression.match(isNumeric)) {
                                handler = this.#parseJSONExpression(handlerExpression)
                                break
                            }
                        case '~':
                            if (handlerExpression.endsWith('~')) {
                                handler = this.#parseRemoteExpression(handlerExpression.slice(1, -1))
                                break
                            }
                        default:
                            handler = this.#parseRemoteExpression(handlerExpression)
                    }
                    handlerIndex = (handlerMap[handlerExpression] ||= (handlers.push(handler)) - 1)
                    step.push(handlerIndex)
                    if (defaultExpression) step.push(defaultExpression)
                    statement.labels[label] = undefined
                    statement.labels[`${index}`] = undefined
                    statement.steps.push(step)
                }
                Object.seal(statement.labels)
                Object.freeze(statement.steps)
                Object.freeze(statement)
                statements.push(statement)
            }
            this.#loadApplication(handlers, Array.from(fieldNames), Array.from(cellNames), statements, init)
        }

        #readText(code) {
            if (type === 'text/flow') splitter = /\n\s*\n/gm
        }

        async connectedCallback() {
            const textContent = this.textContent.trim(), src = this.src, type = this.type ?? 'script/flow'
            if (type === 'application/flow' && !textContent && src) {
                import(src).then(importResult => {
                    const { handlers = [], fieldNames = [], cellNames = [], statements = [] } = importResult
                    this.#loadApplication(handlers, fieldNames, cellNames, statements)
                })
            } else {
                const prepare = code => {
                    switch (type) {
                        case 'application/flow':
                            this.#parseApplication(code)
                            break
                        case 'text/flow':
                            this.#readText(code).then(code => this.#compileScript(code))
                            break
                        case 'script/flow':
                            this.#compileScript(code)
                    }
                }
                if (src) {
                    fetch(src).then(r => r.text()).then(code => prepare([code.trim(), textContent ?? ''].join('/n/n')))
                } else { prepare(textContent ?? '') }
            }
            await this.#runApplication()
        }

        disconnectedCallback() {
            if (this.#abortController) this.#abortController.abort()
            for (const [k, v] of Object.entries(this.#keyedAbortControllers)) v.abort()
        }

        get src() { return this.E.utils.safeGet(this, this.#src, 'src') }
        set src(value) { this.#src = value }

        get type() { return this.E.utils.safeGet(this, this.#type, 'type') }
        set type(value) { this.#type = value }

        #parseEventTargetExpression(expression) {
            const pairs = []
            let routerEvent
            for (const eventPair of expression.split(',')) if (eventPair) {
                let [eventTargetName, eventName] = eventPair.trim().split(':').map(s => s.trim())
                if (!eventTargetName) continue
                if (!eventName) eventName = eventTargetName
                if (eventTargetName === '#' || eventTargetName === '?' || eventTargetName === '/') {
                    routerEvent = eventTargetName
                } else {
                    this.E.env.eventTargets[eventTargetName] ||= new EventTarget()
                    pairs.push([eventTargetName, eventName])
                }
            }
            return async (value, labels, env, statementIndex, stepIndex) => {
                if (routerEvent === '#') {
                    const eventKey = `${statementIndex}-${stepIndex}-#`
                    if (!this.#keyedAbortControllers[eventKey]) {
                        this.#keyedAbortControllers[eventKey] = new AbortController()
                        window.addEventListener('hashchange', event => {
                            this.dispatchEvent(new CustomEvent(`done-${statementIndex}-${stepIndex}`, { detail: document.location.hash }))
                        }, { signal: this.#keyedAbortControllers[eventKey].signal })
                    }
                    return document.location.hash
                } else if (routerEvent === '?') {
                    return document.location.search
                } else if (routerEvent === '/') {
                    return document.location.pathname
                }
            }
        }

        #parseProxyExpression(expressionCode, isInit) {
            const [parentExpression, childExpression] = expressionCode.split('.').map(s => s.trim())
            if (!parentExpression || (childExpression === '')) return
            let [parentObjectName, ...parentArgs] = parentExpression.split('(').map(s => s.trim())
            parentArgs = parentArgs.join('(').slice(0, -1).trim().split(',').map(s => s.trim())
            const parentIsNewable = parentExpression.includes('(') && parentExpression.endsWith(')')
            let [childMethodName, ...childArgs] = childExpression.split('(').map(s => s.trim())
            childArgs = childArgs.join('(').slice(0, -1).trim().split(',').map(s => s.trim())
            const getArgs = (args, value, labels, env) => args.map(a => this.#mergeVariables(a.trim(), value, labels, env))
            if (isInit) return parentIsNewable ? new globalThis[parentObjectName](...getParentArgs())
                : globalThis[parentObjectName](...getParentArgs())
            return (value, labels, env, statementIndex, stepIndex) => {
                if (childMethodName) {
                    if (!(globalThis[parentObjectName] instanceof Object)) return
                    if (typeof globalThis[parentObjectName][childMethodName] !== 'function') return
                    return globalThis[parentObjectName][childMethodName](...getArgs(childArgs, value, labels, env))
                } else {
                    return globalThis[parentObjectName](...getArgs(parentArgs, value, labels, env))
                }
            }
        }

        #parseRegExpExpression(expression) {
            expression = expression.trim()
            if (!expression) return
            const regex = new RegExp(expression)
            return (value, labels, env, statementIndex, stepIndex) => {
                if (typeof value !== 'string') value = `${value}`
                const match = value.match(regex)
                return match ? (match.groups ?? match[1]) : undefined
            }
        }

        #parseStringExpression(expression, isInit) {
            return (value, labels, env, statementIndex, stepIndex) => this.#mergeVariables(expression, value, labels, env)
        }

        #parseFieldOrCellExpression(expression, type) {
            let group = this.#getFieldOrCellGroup(expression, type),
                config = Array.isArray(group) ? 'array' : ((expression[0] === '{') ? 'object' : 'single'), added = new Set()
            if (config === 'array' && group.length === 1 && expression[0] !== '[') config = 'single'
            if (config === 'single') group = group[0]
            switch (config) {
                case 'single':
                    added.add(group.name)
                    break
                case 'array':
                    for (const item of group) added.add(item.name)
                    break
                default:
                    for (const [name, item] of Object.entries(group)) added.add(item.name)
            }
            return [(value, labels, env, statementIndex, stepIndex) => {
                let getReturnValue, items = []
                const eventKey = `${statementIndex}-${stepIndex}-${type}`
                switch (config) {
                    case 'single':
                        group.set(value)
                        getReturnValue = () => group.get()
                        items.push(group)
                        break
                    case 'array':
                        if (Array.isArray(value)) {
                            for (const [i, v] of value.entries()) if ((v != undefined) && (group[i] != undefined)) group[i].set(v)
                        }
                        getReturnValue = () => group.map(i => i.get())
                        items = group
                        break
                    default:
                        if (value instanceof Object) for (const [k, v] of Object.entries(value)) {
                            if (v == undefined) continue
                            if (k[0] === type) {
                                const n = k.slice(1)
                                if (group[n]) group[n].set(v)
                            }
                        }
                        getReturnValue = () => Object.fromEntries(Object.entries(group).map(ent => [`${type}${ent[0]}`, ent[1].get()]))
                        items = Object.values(group)
                }
                if (!this.#keyedAbortControllers[eventKey]) {
                    this.#keyedAbortControllers[eventKey] = new AbortController()
                    for (const item of items) {
                        item.eventTarget.addEventListener('change', event => {
                            const retval = getReturnValue()
                            console.log('flow.html: line 444', retval)
                            this.dispatchEvent(new CustomEvent(`done-${statementIndex}-${stepIndex}`, { detail: getReturnValue() }))
                        }, { signal: this.#keyedAbortControllers[eventKey].signal })
                    }
                }
                return getReturnValue()
            }, Array.from(added)]
        }

        #parseSelectorExpression(expression) {
            if (expression && (expression[0] === '#')) expression = `:|${expression}`
            const [scopeStatement, selectorStatement] = expression.split('|').map(s => s.trim()),
                scope = this.E.utils.resolveScope(scopeStatement, this)
            if (!scope) return []
            let [selector, eventList] = selectorStatement.split('!').map(s => s.trim())
            if (eventList) eventList = eventList.split(',').map(s => s.trim()).filter(s => !!s)
            return (value, labels, env, statementIndex, stepIndex) => {
                if (value != undefined) {
                    const target = this.E.utils.resolveSelector(selector, scope)
                    if (Array.isArray(target)) {
                        for (const t of target) this.E.applyData(t, value)
                    } else if (target) {
                        this.E.applyData(target, value)
                    }
                }
                const eventNames = eventList ?? Array.from(new Set(Object.values(this.E.env.options.defaultEventTypes).concat(['click']))),
                    eventKey = `${statementIndex}-${stepIndex}`
                if (!this.#keyedAbortControllers[eventKey]) {
                    this.#keyedAbortControllers[eventKey] = new AbortController()
                    for (const eventName of eventNames) {
                        scope.addEventListener(eventName, event => {
                            if (selector && !event.target.matches(selector)) return
                            if (!eventList && (event.type !== (this.E.env.options.defaultEventTypes[event.target.tagName.toLowerCase()] ?? 'click'))) return
                            event.preventDefault()
                            this.dispatchEvent(new CustomEvent(`done-${statementIndex}-${stepIndex}`, { detail: this.E.flatten(event.target) }))
                        }, { signal: this.#keyedAbortControllers[eventKey].signal })
                    }
                }
                return value
            }
        }

        #parseJSONExpression(expression, isInit) {
            let retval
            try { retval = JSON.parse(expression) } catch (e) { }
            return (value, labels, env, statementIndex, stepIndex) => retval
        }

        #parseVariableExpression(expression, isInit) {
            return (value, labels, env, statementIndex, stepIndex) => this.#getVariable(expression, value, labels, env)
        }

        #parseTransformExpression(expression) {
            if (expression && expression.startsWith('(`') && expression.endsWith('`)')) expression = expression.slice(1, -1)
            return async (value, labels, env, statementIndex, stepIndex) => {
                const fields = Object.freeze(Object.fromEntries(Object.entries(this.#fields).map(f => [f[0], f[1].get()]))),
                    cells = Object.freeze(Object.fromEntries(Object.entries(this.E.env.cells).map(c => [c[0], c[1].get()]))),
                    context = Object.freeze({ ...env.context })
                return await this.E.runTransform(expression, value, this, { labels, fields, cells, context })
            }
        }

        #parseRemoteExpression(expression, isInit) {
            // const globalUrl = this.E.resolveUrl(this.#mergeVariables(expression, "", {}, this.E.env.context ?? {}), this)
            // let globalConnnector, send
            // if (globalUrl.startsWith('wss://')) {
            //     globalConnnector = new WebSocket(globalUrl)
            //     send = p => globalConnnector.send(p)
            // } else if (globalUrl.startsWith('sse://')) {
            //     globalConnnector = new EventSource(globalUrl)
            // } else if (globalUrl.startsWith('wt://')) {
            //     // web transport
            // } else if (globalUrl.startsWith('rtc://')) {
            //     // web rtc
            // }
            const expressionIncludesValueAsVariable = (expression.includes('${}') || expression.includes('${$}'))
            return async (value, labels, env, statementIndex, stepIndex) => {
                let url = this.#mergeVariables(expression, value, labels, env)
                if (!url) return
                const options = {}
                if (!(expressionIncludesValueAsVariable && (typeof value === 'string'))) {
                    if (value instanceof Object && (value.method || value.body)) {
                        Object.assign(options, value)
                        if (options.body && (typeof options.body !== 'string')) options.body = await this.E.serialize(options.body)
                    } else {
                        Object.assign(options, { method: 'POST', body: typeof value === 'string' ? value : await this.E.serialize(value) })
                    }
                }
                return await fetch(url, options).then(r => {
                    return this.E.parse(r).then(value => {
                        return {
                            ok: r.ok,
                            status: r.status,
                            headers: Object.fromEntries(r.headers.entries()),
                            value
                        }
                    })
                })
            }
        }





        #getField(name) {
            if (!name) return
            if (!this.#fields[name]) {
                const field = {
                    eventTarget: new EventTarget(),
                    get: function () { return this.value },
                    set: function (value, force) {
                        if (this.value === value) {
                            if (force) field.eventTarget.dispatchEvent(new CustomEvent('change', { detail: value }))
                            return this
                        }
                        this.value = value
                        field.eventTarget.dispatchEvent(new CustomEvent('change', { detail: value }))
                        return this
                    },
                    value: undefined, name
                }
                this.#fields[name] = field
            }
            return this.#fields[name]
        }

        #getFieldOrCellGroup(expression, type = '#') {
            let group
            if ((expression[0] === '{') && expression.endsWith('}')) {
                group = {}
                for (const pair of expression.slice(1, -1).trim().split(',')) {
                    let [key, name] = pair.trim().split(':').map(s => s.trim())
                    if (!name) name = key
                    group[key] = type === '%' ? this.#getField(name.trim()) : this.E.getCell(name.trim())
                }
            } else if ((expression[0] === '[') && expression.endsWith(']')) {
                group = []
                for (const t of expression.split(',')) {
                    group.push(type === '%' ? this.#getField(t.trim()) : this.E.getCell(t.trim()))
                }
            } else {
                group = [(type === '%' ? this.#getField(expression) : this.E.getCell(expression))]
            }
            return group
        }

        #getVariable(expression, value, labels, env) {
            if (!expression) return value
            const isNumeric = /^[0-9\.]+$/
            switch (expression[0]) {
                case '"':
                case "'":
                    return expression.slice(1, -1)
                case '{':
                    if (expression.endsWith('}')) {
                        const items = {}
                        for (let pair of expression.slice(1, -1).split(',')) {
                            if (!(pair = pair.trim())) continue
                            let [key, name] = pair.split(':')
                            if (!(key = key.trim()) || !(name = name.trim())) continue
                            key = this.#getVariable(key)
                            if (!key || (typeof key !== 'string')) continue
                            items[key] = this.#getVariable(name)
                        }
                        return items
                    } else {
                        return expression
                    }
                    break
                case '[':
                    if (expression.endsWith(']')) {
                        const items = []
                        for (const item of expression.slice(1, -1).split(',')) items.push(this.#getVariable(item.trim()))
                        return items
                    } else {
                        return expression
                    }
                    break
                case 't':
                case 'f':
                case 'n':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (expression === 'null' || expression === 'true' || expression === 'false'
                        || expression.match(isNumeric)) {
                        return JSON.parse(expression)
                    } else {
                        return expression
                    }
                    break
                case '~':
                    return env.context[expression]
                case '#':
                    return (env.cells[expression] ?? {})?.get()
                case '%':
                    return (env.fields[expression] ?? {})?.get()
                case '$':
                    expression = expression.slice(1)
                    if (!expression) return value
                    return labels[expression] ?? (env.fields[expression] ?? {})?.get() ?? (env.cells[expression] ?? {})?.get() ?? env.context[expression]
                default:
                    return labels[expression]
            }
        }

        #mergeVariables(expression, value, labels, env, inner) {
            if (!expression) return inner ? value : undefined
            if (typeof expression !== 'string') return expression
            const regExp = /\$\{(.*?)\}/g, isMatch = expression.match(regExp)
            if (!isMatch && !inner) return expression
            if (!isMatch && inner) {
                return this.#getVariable(expression, value, labels, env)
            } else if (expression[0] === '[' && expression.endsWith(']')) {
                return expression.slice(1, -1).split(',').map(s => this.#mergeVariables(s.trim(), value, labels, env, true))
            } else if (expression[0] === '{' && expression.endsWith('}')) {
                return Object.fromEntries(expression.slice(1, -1).split(',').map(s => {
                    const [k, v] = s.trim().split(':').map(ss => s.trim())
                    return [k, this.#mergeVariables(v, value, labels, env, true)]
                }))
            }
            const merge = (exp) => {
                if (exp) exp = exp.slice(2, -1)
                return this.#mergeVariables(exp, value, labels, env, true)
            }
            return ((isMatch.length === 1) && (isMatch[0] === expression)) ? merge(expression) : expression.replace(regExp, merge)
        }




        #parseTriggerExpression(expressionCode) {
            switch (expressionCode[0]) {
                case '!':
                    expressionCode = expressionCode.slice(1)
                    if (expressionCode === '#') {
                        return [window, ['hashchange']]
                    } else {
                        const [eventTargetName, eventNames] = expressionCode.split(' ')
                        this.E.env.eventTargets[eventTargetName.trim()] ||= new EventTarget()
                        return [this.E.env.eventTargets[eventTargetName], eventNames.trim().split(',').map(s => s.trim()).filter(s => !!s)]
                    }
                case '%':
                case '#':
                    const targetType = expressionCode[0], expressionCode = expressionCode.slice(1).trim()
                    return [this.#getFieldOrCellGroup(expressionCode, expressionCode[0]), ['change']]
                case '$':
                    let scopedSelector = expressionCode.slice(2, -1)
                    if (!scopedSelector) scopedSelector = ':|'
                    if (!scopedSelector.includes('|')) scopedSelector = `:|${scopedSelector}`
                    const [scopeStatement, selector] = scopedSelector.split('|').map(s => s.trim()),
                        scope = this.E.utils.resolveScope(scopeStatement, this)
                    return [scope, [selector]]
            }
        }



    }
</script>