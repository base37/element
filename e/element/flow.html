<style></style>
<template>
    <slot></slot>
</template>
<script>
    export default class extends `script` {

        #abortController
        #context = {}
        #slots = {}
        #src
        #statements = []
        #type

        constructor() { super() }

        static get observedAttributes() { return (super.observedAttributes || []).concat('src', 'type') }

        #loadApplication(code) {
            const stepHandlers = this.E.env.stepHandlers, context = { ...this.E.env.context }
            Object.freeze(context)
            for (let line of code.split(/\n/gm)) {
                line = line.trim()
                if (!line) continue
                let value
                const statement = JSON.parse(line), statementLength = statement.length,
                    [steps, labels, slots, cells] = statement
                const env = Object.freeze({ labels: {}, slots: {}, cells: {}, context })
                for (const name of labels) env.labels[name] = undefined
                for (const name of slots) env.slots[name] = this.#getSlot(name)
                for (const name of cells) env.cells[name] = this.E.getCell(name)
                Object.seal(env.labels)
                Object.freeze(env.slots)
                Object.freeze(env.cells)
                for (const [index, step] of statement.entries()) {
                    const [label, handlerIndex, defaultValue] = step
                    value = (await stepHandlers[handlerIndex](value, index, index ? statementLength : statement, env)) ?? defaultValue
                    switch (label[0]) {
                        case '%':
                            env.slots(label.slice(1)).set(result)
                            break
                        case '#':
                            env.cells(label.slice(1)).set(result)
                            break
                        default:
                            labels[label] = result
                    }
                    if (value == undefined) break
                }
            }
        }

        #compileScript(code) {

        }

        async connectedCallback() {
            let code = this.textContent ?? ''
            const src = this.src, type = this.type ?? 'script/flow'
            if (src) code = [await fetch(src).then(r => r.text()), code].join('/n/n')
            if (!code) return
            const codeStatements = []
            let splitter = /\n/gm
            switch (type) {
                case 'application/flow':
                    await this.#loadApplication(code)
                    break
                case 'script/flow':
                    await this.#loadApplication(await this.#compileScript(code))
                    break
                case 'text/flow':
                    await this.#loadApplication(await this.#compileScript(await this.#transpileText(code)))
                    break
            }
            if (type === 'application/flow') {
            }
            if (type === 'script/flow') splitter = /\n(?!\s+>>)/gm
            if (type === 'text/flow') splitter = /\n\s*\n/gm
            if (this.#abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            const isNumeric = /^[0-9\.]+$/
            for (let s of code.split(splitter)) if (s = s.trim()) if (s.slice(0, 2) !== '# ') codeStatements.push(s)
            for (const codeStatement of codeStatements) {
                const codeStatementSlice03 = codeStatement.slice(0, 3)
                if (codeStatementSlice03 === '#! ') {
                    this.#statements.push([this.#parseContextStatement(codeStatement.slice(3))])
                    continue
                }
                const codeExpressions = [], steps = []
                for (let [index, codeExpression] of codeStatement.split(' >> ').entries()) {
                    codeExpression = codeExpression.trim()
                    if (!index) steps.push(this.#parseTriggerExpression(codeExpression))
                    if (!codeExpression) continue
                    let stepLabel, stepExpression = codeExpression, stepDefaultExpression
                    const labelMatch = stepExpression.match(/^([a-z0-9]+):\s+/)
                    if (labelMatch) {
                        stepLabel = labelMatch[1].trim()
                        stepExpression = stepExpression.slice(labelMatch[0].length).trim()
                    }
                    const stepDefaultExpressionMatch = stepExpression.match(/\s+\?\?\s+(.+)\s*$/)
                    if (stepDefaultExpressionMatch) {
                        stepDefaultExpression = stepDefaultExpressionMatch[1].trim()
                        stepExpression = stepExpression.slice(0, stepDefaultExpressionMatch.index).trim()
                    }
                    stepLabel ||= index
                    stepHandler
                    switch (stepExpression[0]) {
                        case '!':
                            this.E.env.expressionHandlers[stepExpression] ||= this.#parseEventTargetExpression(stepExpression.slice(1))
                            break
                        case '`':
                            this.E.env.expressionHandlers[stepExpression] ||= this.#parseProxyExpression(stepExpression.slice(1, -1))
                            break
                        case '/':
                            this.E.env.expressionHandlers[stepExpression] ||= this.#parseRegExpExpression(stepExpression.slice(1, -1))
                            break
                        case '"':
                        case "'":
                            this.E.env.expressionHandlers[stepExpression] ||= this.#parseStringExpression(stepExpression.slice(1, -1))
                            break
                        case "#":
                            this.E.env.expressionHandlers[stepExpression] ||= this.#parseSlotOrCellExpression(stepExpression.slice(1), '#')
                            break
                        case "%":
                            this.E.env.expressionHandlers[stepExpression] ||= this.#parseSlotOrCellExpression(stepExpression.slice(1), '%')
                            break
                        case "$":
                            if (stepExpression[1] === "{") {
                                this.E.env.expressionHandlers[stepExpression] ||= this.#parseVariableExpression(stepExpression.slice(2, -1))
                            } else if (stepExpression[1] === "(") {
                                this.E.env.expressionHandlers[stepExpression] ||= this.#parseSelectorExpression(stepExpression.slice(2, -1))
                            }
                            break
                        case "(":
                            this.E.env.expressionHandlers[stepExpression] ||= this.#parseTransformExpression(stepExpression)
                            break
                        case "{":
                            this.E.env.expressionHandlers[stepExpression] ||= this.#parseJSONExpression(stepExpression)
                            break
                        case "n":
                        case "t":
                        case "f":
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "7":
                        case "9":
                            if (stepExpression === 'null' || stepExpression === 'true' || stepExpression === 'false'
                                || stepExpression.match(isNumeric)) {
                                this.E.env.expressionHandlers[stepExpression] ||= this.#parseJSONExpression(stepExpression)
                            } else {
                                this.E.env.expressionHandlers[stepExpression] ||= this.#parseRemoteExpression(stepExpression)
                            }
                            break
                        default:
                            this.E.env.expressionHandlers[stepExpression] ||= this.#parseRemoteExpression(stepExpression)
                    }
                    stepHandler = this.E.env.expressionHandlers[stepExpression]
                    if (stepHandler) steps.push([stepLabel, stepHandler, stepDefaultExpression])
                }
                this.#statements.push(steps)
            }
            let context = { ...this.E.env.context }
            for (const statement of this.#statements) {
                const triggerExpression = statement.shift(), context = { ...context }
                const statementProcessor = async (result) => {
                    let labels = {}
                    for (const step of statement) {
                        const [label, stepHandler, defaultValue] = step
                        result = (await stepHandler(result, labels, this.#slots, this.E.env.cells, context)) ?? defaultValue
                        if (result == undefined) break
                        labels[label] = result
                    }
                }
                const [triggerTarget, eventNames] = triggerExpression
                if (triggerTarget && Array.isArray(eventNames) && eventNames.length) {
                    if (triggerTarget instanceof HTMLElement) {
                        let [selector, eventList] = eventNames[0].split('!'), eventNames, useDefaultEvents
                        if (eventList) {
                            eventNames = eventList.split(',').map(s => s.trim()).filter(s => !!s)
                        } else {
                            eventNames = Array.from(new Set(Object.values(this.E.env.options.defaultEventTypes).concat(['click'])))
                            useDefaultEvents = true
                        }
                        for (const eventName of eventNames) {
                            triggerTarget.addEventListener(eventName, event => {
                                if (useDefaultEvents && (event.type !== (this.E.env.options.defaultEventTypes[event.target.tagName.toLowerCase()] ?? 'click'))) return
                                if (selector && !event.target.matches(selector)) return
                                statementProcessor(this.E.flatten(event.target))
                            }, { signal: this.#abortController.signal })
                        }
                    } else if (triggerTarget instanceof EventTarget) {
                        for (const eventName of eventNames) triggerTarget.addEventListener(eventName, statementProcessor)
                    } else if (Array.isArray(triggerTarget)) {
                        for (const [index, valueStore] of triggerTarget.entries()) {
                            valueStore.eventTarget.addEventListener('change', event => {
                                statementProcessor(valueStore.get())
                            })
                        }
                    } else if (triggerTarget instanceof Object) {
                        for (const [key, valueStore] of Object.entries(triggerTarget)) {
                            valueStore.eventTarget.addEventListener('change', event => {
                                statementProcessor(valueStore.get())
                            })
                        }
                    }
                } else {
                    await statementProcessor()
                }
            }
        }

        disconnectedCallback() { }

        get src() { return this.E.utils.safeGet(this, this.#src, 'src') }
        set src(value) { this.#src = value }

        get type() { return this.E.utils.safeGet(this, this.#type, 'type') }
        set type(value) { this.#type = value }

        #getSlot(name) {
            if (!name) return
            if (!this.#slots[name]) {
                const slot = {
                    eventTarget: new EventTarget(),
                    get: function () { return this.value },
                    set: function (value, force) {
                        if (this.value === value) {
                            if (force) slot.eventTarget.dispatchEvent(new CustomEvent('change', { detail: value }))
                            return
                        }
                        this.value = value
                        slot.eventTarget.dispatchEvent(new CustomEvent('change', { detail: value }))
                    },
                    value: undefined, name
                }
                this.#slots[name] = cell
            }
            return this.#slots[name]
        }

        #getSlotOrCellGroup(expression, type = '#') {
            let group
            if ((expression[0] === '{') && expression.endsWith('}')) {
                group = {}
                for (const pair of expression.slice(1, -1).trim().split(',')) {
                    let [key, name] = pair.trim().split(':').map(s => s.trim())
                    if (!name) name = key
                    pairs[key] = type === '%' ? this.#getSlot(name.trim()) : this.E.getCell(name.trim())
                }
            } else if ((expression[0] === '[') && expression.endsWith(']')) {
                group = []
                for (const t of expression.split(',')) {
                    group.push(type === '%' ? this.#getSlot(t.trim()) : this.E.getCell(t.trim()))
                }
            } else {
                group = [(type === '%' ? this.#getSlot(expression) : this.E.getCell(expression))]
            }
            return group
        }

        #parseContextStatement(statementCode) {
            const pairs = {}
            for (const s of statementCode.trim().slice(1, -1).trim().split(',')) {
                let [k, v] = s.trim().split(':').map(s => s.trim())
                if (k[0] === '"' || k[0] === "'") k = k.slice(1, -1)
                pairs[k] = v ?? k
            }
            return [0, (result, labels, slots, cells, context) => {
                for (const [k, v] of pairs) context[k] = this.E.resolveVariables(v ?? k, this)
            }, undefined]
        }

        #parseTriggerExpression(expressionCode) {
            switch (expressionCode[0]) {
                case '!':
                    expressionCode = expressionCode.slice(1)
                    if (expressionCode === '#') {
                        return [window, ['hashchange']]
                    } else {
                        const [eventTargetName, eventNames] = expressionCode.split(' ')
                        this.E.env.eventTargets[eventTargetName.trim()] ||= new EventTarget()
                        return [this.E.env.eventTargets[eventTargetName], eventNames.trim().split(',').map(s => s.trim()).filter(s => !!s)]
                    }
                case '%':
                case '#':
                    const targetType = expressionCode[0], expressionCode = expressionCode.slice(1).trim()
                    return [this.#getSlotOrCellGroup(expressionCode, expressionCode[0]), ['change']]
                case '$':
                    let scopedSelector = expressionCode.slice(2, -1)
                    if (!scopedSelector) scopedSelector = ':|'
                    if (!scopedSelector.includes('|')) scopedSelector = `:|${scopedSelector}`
                    const [scopeStatement, selector] = scopedSelector.split('|').map(s => s.trim()),
                        scope = this.E.utils.resolveScope(scopeStatement, this)
                    return [scope, [selector]]
            }
        }

        #parseEventTargetExpression(expressionCode) {
            const pairs = []
            for (const eventPair of expressionCode.split(',')) if (eventPair) {
                let [eventTargetName, eventName] = eventPair.trim().split(':').map(s => s.trim())
                if (!eventTargetName) continue
                if (!eventName) eventName = eventTargetName
                this.E.env.eventTargets[eventTargetName] ||= new EventTarget()
                pairs.push([eventTargetName, eventName])
            }
            return async (result, labels, slots, cells, context) => {
                for (const [t, n] of pairs) {
                    const eventName = n[0] === '$' ? this.E.resolveVariables(n) : n
                    this.E.env.eventTargets[t].dispatchEvent(new CustomEvent(eventName, { detail: result }))
                }
                return result
            }
        }

        #parseProxyExpression(expressionCode) {
            const [parentExpression, childExpression] = expressionCode.split('.').map(s => s.trim())
            if (!parentExpression || (childExpression === '')) return
            let [parentObjectName, ...parentArgs] = parentExpression.split('(').map(s => s.trim())
            parentArgs = parentArgs.join('(').slice(0, -1).trim().split(',').map(s => s.trim())
            const parentIsNewable = parentExpression.includes('(') && parentExpression.endsWith(')')
            let [childMethodName, ...childArgs] = childExpression.split('(').map(s => s.trim())
            childArgs = childArgs.join('(').slice(0, -1).trim().split(',').map(s => s.trim())
            const getParentArgs = r => parentArgs.map(a => a === '$' ? r : this.E.resolveVariables('${' + a.trim() + '}', this))
            const getChildArgs = r => childArgs.map(a => a === '$' ? r : this.E.resolveVariables('${' + a.trim() + '}', this))
            const singleton = parentIsNewable ? new globalThis[parentObjectName](...getParentArgs()) : undefined
            return (result, labels, slots, cells, context) => {
                if (childMethodName) {
                    if (singleton) {
                        if (!(singleton instanceof Object)) return
                        if (typeof singleton[childMethodName] !== 'function') return
                        return singleton[childMethodName](...getChildArgs(result))
                    } else {
                        if (!(globalThis[parentObjectName] instanceof Object)) return
                        if (typeof globalThis[parentObjectName][childMethodName] !== 'function') return
                        return globalThis[parentObjectName][childMethodName](...getChildArgs(result))
                    }
                } else {
                    return singleton ? singleton(...getParentArgs(result)) : globalThis[parentObjectName](...getParentArgs(result))
                }
            }
        }

        #parseRegExpExpression(expressionCode) {
            let [expression, substitute] = expressionCode.split(' ').map(s => s.trim())
            if (!expression) return
            const regex = new RegExp(expression, 'g')
            return (result, labels, slots, cells, context) => {
                let instanceSubstitute = substitute ? this.E.resolveVariables(substitute, this) : undefined
                if ((typeof result !== 'string') || (typeof instanceSubstitute !== string)) return
                if (substitute) {
                    return result.replace(regex, instanceSubstitute)
                } else {
                    const match = result.match(regex, instanceSubstitute)
                    return match ? (match.groups ?? match[1]) : undefined
                }
            }
        }

        #parseStringExpression(expressionCode) {
            return (result, labels, slots, cells, context) => expressionCode
        }

        #parseSlotOrCellExpression(expressionCode, type) {
            let group = this.#getSlotOrCellGroup(expressionCode, type),
                config = Array.isArray(group) ? 'array' : ((expressionCode[0] === '{') ? 'object' : 'single')
            if (config === 'single') group = group[0]
            return (result, labels, slots, cells, context) => {
                switch (config) {
                    case 'single':
                        group.set(result)
                        return result
                    case 'array':
                        if (Array.isArray(result)) {
                            for (const [i, v] of result.entries()) if ((v != undefined) && (group[i] != undefined)) group[i].set(v)
                        }
                        return group.map(i => i.get())
                    default:
                        if (result instanceof Object) for (const [k, v] of Object.entries(result)) {
                            if (v == undefined) continue
                            if (k[0] === type) {
                                const n = k.slice(1)
                                if (group[n]) group[n].set(v)
                            }
                        }
                        return Object.fromEntries(Object.entries(group).map(ent => [`${type}${ent[0]}`, ent[1].get()]))
                }
            }
        }

        #parseSelectorExpression(expressionCode) {
            return (result, labels, slots, cells, context) => {
                const target = this.E.resolveScopedSelector(expressionCode, this)
                if (Array.isArray(target)) {
                    for (const t of target) this.E.applyData(t, result)
                } else if (target) {
                    this.E.applyData(target, result)
                }
                return result
            }
        }

        #parseJSONExpression(expressionCode) {
            return (result, labels, slots, cells, context) => {
                let r
                try { r = JSON.parse(expressionCode) } catch (e) { return }
                const resolve = (rr) {
                    if (Array.isArray(rr)) {
                        return rr.map(rrr => this.E.resolveVariables(rrr, this))
                    } else if (rr instanceof Object) {
                        return Object.fromEntries(Object.entries(rr).map(ent => ent.map(m => this.E.resolveVariables(m, this))))
                    } else {
                        return this.E.resolveVariables(rr, this)
                    }
                }
                return resolve(r)
            }
        }

        #parseVariableExpression(expressionCode) {
            return (result, labels, slots, cells, context) => this.E.resolveVariables(expressionCode, this)
        }

        #parseTransformExpression(expressionCode) {
            return (result, labels, slots, cells, context) => {
                return await this.E.runTransform(expressionCode, result, this, {
                    context, labels,
                    slots: Object.fromEntries(Object.entries(slots).map(s => [s[0], s[1].get()])),
                    cells: Object.fromEntries(Object.entries(cells).map(s => [c[0], c[1].get()]))
                })
            }
        }

        #parseRemoteExpression(expressionCode) {
            const globalUrl = this.E.resolveUrl(this.E.resolveVariables(expressionCode), this)
            let globalConnnector, send
            if (globalUrl.startsWith('wss://')) {
                globalConnnector = new WebSocket(globalUrl)
                send = p => globalConnnector.send(p)
            } else if (globalUrl.startsWith('sse://')) {
                globalConnnector = new EventSource(globalUrl)
            } else if (globalUrl.startsWith('wt://')) {
                // web transport
            } else if (globalUrl.startsWith('rtc://')) {
                // web rtc
            }
            return (result, labels, slots, cells, context) => {
                const body = result == undefined ? undefined : ((typeof result == 'string') ? result : await this.E.serialize(result, this))
                if (globalConnnector) return send(body)
                const url = this.E.resolveUrl(this.E.resolveVariables(expressionCode), this)
                if (!url) return
                const headers = context.headers ?? {}, method = context.method ?? (body ? 'POST' : 'GET')
                if (body) {
                    headers['content-type'] = context['content-type'] ?? headers['content-type'] ?? 'application/json'
                }
                const options = { method, headers, body }
                return await fetch(url, options).then(r => {
                    return this.E.parse(r, this).then(value => {
                        return {
                            ok: r.ok,
                            status: r.status,
                            headers: Object.fromEntries(r.headers.entries()),
                            value
                        }
                    })
                })
            }
        }

    }
</script>