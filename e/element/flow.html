<style></style>
<template>
    <field></field>
</template>
<script>
    export default class extends `script` {

        #abortController
        #handlers = []
        #cellNames = []
        #fieldNames = []
        #fields = {}
        #src
        #statements = []
        #type
        #keyedAbortControllers = {}

        get abortController() { return this.#abortController }
        get handlers() { return this.#handlers }
        get cellNames() { return this.#cellNames }
        get fieldNames() { return this.#fieldNames }
        get fields() { return this.#fields }
        get statements() { return this.#statements }
        get keyedAbortControllers() { return this.#keyedAbortControllers }

        static get observedAttributes() { return (super.observedAttributes || []).concat('src', 'type') }

        load(handlers = [], fieldNames = [], cellNames = [], statements = []) {
            this.#handlers = Object.freeze(handlers)
            this.#fields ||= {}
            for (const fieldName of fieldNames) this.#fields[fieldName] = this.getField(fieldName)
            Object.freeze(this.#fields)
            this.#fieldNames = Object.freeze(fieldNames)
            this.#cellNames = Object.freeze(cellNames)
            this.#statements = Object.freeze(statements)
        }

        run() {
            if (this.#abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            const rootNode = this.getRootNode(),
                context = Object.freeze(rootNode instanceof ShadowRoot
                    ? { ...this.E.env.context, ...Object.fromEntries(Object.entries(rootNode.host.dataset)) } : this.E.env.context),
                env = Object.freeze({ fields: {}, cells: {}, context })
            for (const fieldName of this.#fieldNames) env.fields[fieldName] = this.getField(fieldName)
            for (const cellName of this.#cellNames) env.cells[cellName] = this.E.getCell(cellName)
            Object.freeze(env.fields)
            Object.freeze(env.cells)
            for (const [statementIndex, statement] of this.#statements.entries()) {
                const { labels = {}, steps = [] } = statement
                for (const [stepIndex, step] of steps.entries()) {
                    const [labelItem, handlerIndex, defaultValue] = step
                    let label, labelMode
                    if (Array.isArray(labelItem)) {
                        [label, labelMode] = label
                    } else {
                        label = labelItem
                    }
                    this.addEventListener(stepIndex ? `done-${statementIndex}-${stepIndex - 1}` : 'run', async event => {
                        let detail = await this.#handlers[handlerIndex](event.detail, { ...labels }, env, statementIndex, stepIndex)
                        if (detail == undefined) detail = this.E.getVariable(defaultValue, undefined, labels, env)
                        switch (label[0]) {
                            case '%':
                                env.fields[label.slice(1)].set(detail, labelMode)
                                break
                            case '#':
                                env.cells[label.slice(1)].set(detail, labelMode)
                                break
                            default:
                                labels[label] = detail
                        }
                        labels[`${stepIndex}`] = detail
                        if (detail != undefined) this.dispatchEvent(new CustomEvent(`done-${statementIndex}-${stepIndex}`, { detail }))
                    }, { signal: this.#abortController.signal })
                }
            }
            this.dispatchEvent(new CustomEvent('run'))
        }

        disconnectedCallback() {
            if (this.#abortController) this.#abortController.abort()
            for (const [k, v] of Object.entries(this.#keyedAbortControllers)) v.abort()
        }

        get src() { return this.E.utils.safeGet(this, this.#src, 'src') }
        set src(value) { this.#src = value }

        get type() { return this.E.utils.safeGet(this, this.#type, 'type') }
        set type(value) { this.#type = value }

        getField(name) {
            if (!name) return
            if (!this.#fields[name]) {
                const field = {
                    type: 'field',
                    eventTarget: new EventTarget(),
                    get: function () { return this.value },
                    set: function (value, labelMode) {
                        let isSame = this.value === value
                        if (!isSame) try { isSame = JSON.stringify(this.value) === JSON.stringify(value) } catch (e) { }
                        if (isSame) {
                            if (labelMode === 'force') field.eventTarget.dispatchEvent(new CustomEvent('change', { detail: value }))
                            return this
                        }
                        this.value = value
                        if (labelMode !== 'silent') field.eventTarget.dispatchEvent(new CustomEvent('change', { detail: value }))
                        return this
                    },
                    value: undefined, name
                }
                this.#fields[name] = field
            }
            return this.#fields[name]
        }

    }
</script>