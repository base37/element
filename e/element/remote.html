<style></style>
<template></template>
<script>
    export default class extends `./map` {

        #options

        static portType = 'Remote'

        constructor() {
            super()
            Object.defineProperty(this, '_getPort', {
                value: (portExpression) => this.#getPort(portExpression)
            })
            Object.defineProperty(this, '_applyFromCells', {
                value: (value, cell, countLabel, counter, event, url) => this.#applyFromCells(value, cell, countLabel, counter, event, url)
            })
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('options') }

        #getPort(portExpression) {
            if (!portExpression || (typeof portExpression !== 'string')) return
            const direction = this.direction, cells = this.cells
            if ((direction !== 'toCell') && (direction !== 'fromCell')) return
            if (!cells) return
            const [urlExpression, eventsExpression] = portExpression.split('!').map(s => s.trim()), remoteUrl = this.E.resolveUrl(urlExpression, this)
            if (!remoteUrl) return
            this.E.env.ports[remoteUrl] ||= {}
            let handler, name = remoteUrl, singleton
            if (remoteUrl.startsWith('ws://') || remoteUrl.startsWith('wss://')) {
                if (!this.E.env.ports[remoteUrl].singleton) {
                    let options = this.options ?? {}
                    if (typeof options === 'string') options = this.E.resolveVariables('${' + options + '}')
                    if (!(options instanceof Object)) return
                    singleton = new WebSocket(remoteUrl, options.protocols)
                    if (options.binaryType) singleton.binaryType = options.binaryType
                }
                if (direction === 'fromCell') {
                    handler = (value, port, remoteMapElement, init) => {
                        // need to handle closed sockets...
                        this.E.serialize(value, this).then(serializedValue => port.singleton.send(serializedValue))
                    }
                } else if (direction === 'toCell') {
                    // need to handle closed sockets...
                    port.singleton.addEventListener('message', event => {
                        this.E.parse(event.data, this).then(parsedValue => this.saveToCell(parsedValue))
                    }, { signal: this._abortController.signal })
                } else { return }
            }
            if (!remoteUrl.startsWith('https://') && !remoteUrl.startsWith('http://')) return
            if (portExpression.startsWith('wt://')) {

                // Dummy code from Claude! Probably doesn't work but something to start with...
                // also look at https://github.com/w3c/webtransport/blob/master/explainer.md
                //
                // WebTransport server URL  
                // const url = "https://example.com/wt";
                // async function connect() {
                //     const transport = new WebTransport(url);
                //     await transport.ready;
                //     const stream = await transport.createBidirectionalStream();
                //     stream.readable.getReader().read().then(result => {
                //         console.log("Received:", result.value);
                //     });
                //     const encoder = new TextEncoder();
                //     const writer = stream.writable.getWriter();
                //     writer.write(encoder.encode("Hello world!"));
                //     transport.close();
                // }
                // connect();

            } else if (portExpression.startsWith('rtc://')) {

                // Dummy code from Claude! Probably doesn't work but something to start with...
                // also look at https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/
                // const signalingUrl = "https://signaling.myserver.com";
                // const pc = new RTCPeerConnection();
                // fetch(signalingUrl, {
                //     method: 'POST',
                //     body: JSON.stringify(pc.localDescription)
                // });
                // let answerUrl;
                // fetch(signalingUrl)
                //     .then(resp => resp.text())
                //     .then(url => {
                //         answerUrl = url;
                //     });
                // fetch(answerUrl)
                //     .then(resp => resp.json())
                //     .then(answer => pc.setRemoteDescription(answer));
                // const dc = pc.createDataChannel('data');
                // dc.onmessage = () => { /* handle data */ };
                // dc.onopen = () => {
                //     dc.send('Hello world!');
                // }

            } else if ((direction === 'toCell') && portExpression.startsWith('sse://')) {
                if (!this.E.env.ports[remoteUrl].singleton) {
                    let options = this.options ?? {}
                    if (typeof options === 'string') options = this.E.resolveVariables('${' + options + '}')
                    if (!(options instanceof Object)) return
                    singleton = new EventSource(remoteUrl, options.withCredentials)
                }
                if (eventsExpression) {
                    for (const eventName of eventsExpression.split(',').map(s => s.trim()).filter(s => !!s)) {
                        port.singleton.addEventListener(eventName, event => {
                            this.E.parse(event.data, this).then(parsedValue => this.saveToCell(parsedValue, eventName))
                        }, { signal: this._abortController.signal })
                    }
                }
                port.singleton.addEventListener('message', event => {
                    this.E.parse(event.data, this).then(parsedValue => this.saveToCell(parsedValue, 'message'))
                }, { signal: this._abortController.signal })
            } else {
                if (direction === 'toCell') {
                    handler = (remoteMapElement) => {
                        const url = remoteMapElement.E.resolveUrl(remoteMapElement.E.resolveVariables(remoteUrl, remoteMapElement), remoteMapElement)
                        if (!url) return
                        return fetch(url, this.options ?? {}).then(r => {
                            return this.E.parse(r, this).then(value => {
                                return {
                                    ok: r.ok,
                                    status: r.status,
                                    headers: Object.fromEntries(r.headers.entries()),
                                    value
                                }
                            })
                        })
                    }
                } else if (direction === 'fromCell') {
                    handler = (value, remoteMapElement, init) => {
                        let options = remoteMapElement.options ?? {}
                        if (typeof options === 'string') options = remoteMapElement.E.resolveVariables('${' + options + '}')
                        if (!(options instanceof Object)) return
                        const url = remoteMapElement.E.resolveUrl(remoteMapElement.E.resolveVariables(remoteUrl, remoteMapElement), remoteMapElement)
                        if (!url) return
                        options.body = value
                        fetch(url, options).then(r => {
                            this.E.parse(r, this).then(value => {
                                const toCellResponse = { ok: r.ok, status: r.status, headers: Object.fromEntries(r.headers.entries()), value }
                                for (const map of this.port?.toCell?.maps ?? []) {
                                    map.touch(toCellResponse)
                                }
                            })
                        })
                    }
                }
            }
            if (!name || (typeof handler !== 'function')) return
            if (!name || (typeof handler !== 'function')) return
            this.E.env.ports[name] ||= {}
            this.E.env.ports[name].name = name
            this.E.env.ports[name].type = this.constructor.portType
            handler = handler.bind(this.E.env.ports[name])
            this.E.env.ports[name][direction] = { handler, name, direction }
            this.E.env.ports[name][direction].maps ||= []
            this.E.env.ports[name][direction].maps.push(this)
            this.E.env.ports[name].singleton = remoteUrl
            return [this.E.env.ports[name], [remoteUrl]]
        }

        #applyFromCells(value, cell, countLabel, counter, event, url) {
            const handler = this.E.env.ports[url]?.fromCell?.handler
            if (!handler) return
            this.E.runTransform(this.transform, value, this, { cell: { value, name: cell.name, [countLabel]: counter }, event, url })
                .then(data => {
                    if ((data != undefined)) return this.E.serialize(data, this).then(serializedData => handler(serializedData, this))
                })
        }

        touch(response) {
            const direction = this.direction, port = this.port
            if (!port || !direction) return
            const handler = port[direction]?.handler
            if (!handler) return
            //if (this.id == 'profile-getter') console.log('remote.html: line 180')
            response ||= handler(this)
            if (!response) return
            Promise.resolve(response).then(response => this._applyToCells(response))
        }

    }
</script>