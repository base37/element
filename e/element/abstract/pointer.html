<style></style>
<template><slot></slot></template>
<script>
    class extends `meta` {

        #parser
        #serializer
        #fetchOptions
        #resource
        #target
        #transform
        #apply
        #errors
        #rewrite
        #rewriteRules = []
        #boundResource
        #boundResourceController
        #boundTarget
        #boundTargetController
        #boundResourceObserver
        #boundTargetObserver
        #boundResourceRefreshCount = 0
        #boundTargetRefreshCount = 0
        #options = {}
        #optionsString = ''
        #resourceOptions = {}
        #resourceOptionsString = ''
        #targetOptions = {}
        #targetOptionsString = ''

    	constructor() {
    		super()
            Object.defineProperties(this, {
                _mode: {configurable: true, enumerable: false, value: 'pointer'}, 
                _contentType: {configurable: true, enumerable: false, value: undefined}, 
                _isReference: {configurable: true, enumerable: false, value: false}, 
                _apply: {configurable: true, enumerable: false, value: async (result, target) => {
                        target = Array.isArray(target) ? target : [target]
                        for (const t of target) this.e.setValue(t, result)
                    }
                }
            })
    	}

		static get observedAttributes() { return (super.observedAttributes || []).concat('resource', 'target', 'apply', 'transform', 'rewrite', 'errors',
            'options', 'resource-options', 'target-options', 'parser', 'serializer') }

        async connectedCallback() {}

        toString() { return this.resource ?? '' }

        #sliceAndStep(selector, list) {
            let [start=0, end=list.length, step=0] = selector.split('[').pop().slice(0, -1).split(':').map(s => (parseInt(s) || 0))
            list = list.slice(start, end)
            if (!step) return list
            return (step === 1) ? list.filter((v, i) => (i+1) % 2) : list.filter((v, i) => (i+1) % step === 0)            
        }

        async #installProtobuf() {
            if (!this.e.env.libraries.protobuf) {
                const s = document.createElement('script')
                s.setAttribute('src', 'https://cdn.jsdelivr.net/npm/protobufjs@7.2.5/dist/protobuf.min.js')
                document.head.append(s)
                this.e.utils.waitUntil(() => window.protobuf).then(() => this.e.env.libraries.protobuf = window.protobuf) 
            }   
        }

        async #installRemarkable() {
            if (!this.e.env.libraries.remarkable) {
                this.e.env.libraries.remarkable = new ((await import('https://cdn.jsdelivr.net/npm/remarkable@2.0.1/+esm')).Remarkable)()
                const plugin = (md, options) => md.core.ruler.push('html-components', parser(md, {}), {alt: []}), parser = (md, options) => {
                  return (state) => {
                    let tokens = state.tokens, i = -1, exp = new RegExp('(<([^>]+)>)','gi')
                    while (++i < tokens.length) {
                      const token = tokens[i]
                      for (const child of (token.children ?? [])) {
                        if (child.type !== 'text') return
                        if (exp.test(child.content)) child.type = 'htmltag'
                      }
                    }
                  }
                }
                this.e.env.libraries.remarkable.use(plugin)
                this.e.env.options.remarkable = {html: true}
            }
        }

        #resolveUrl(useValue) {
            if (useValue.includes(':') && !useValue.includes('://')) {
                let [routerName, routerPointer] = this.e.utils.splitOnce(useValue, ':'), router = this.e.utils.resolveMeta(this, 'e-router', routerName)
                if ((routerPointer.startsWith('/') || routerPointer.startsWith('?') || routerPointer.startsWith('#'))) {
                    const map = {'/': document.location.pathname.slice(1), '#': document.location.hash.slice(1), '?': document.location.search.slice(1)}
                    if (routerPointer[0] === '?' && (routerPointer === '[') && (routerPointer.slice(-1) === ']')) {
                        routerPointer = (new URLSearchParams(map[routerPointer[0]])).get(routerPointer.slice(2, -1))
                    } else {
                        if (routerPointer === routerPointer[0]) {
                            routerPointer = map[routerPointer[0]]
                        } else {
                            try {
                                routerPointer = map[routerPointer[0]].match(new RegExp(routerPointer.slice(1)))[0]
                            } catch(e) { routerPointer = undefined }
                        }
                    }
                }
                const rewriteRules = this.rewriteRules
                if (routerPointer && rewriteRules.length) for (const [rx, p] of rewriteRules) if ((rx instanceof RegExp) && routerPointer.match(rx)) return this.#resolveUrl(p) 
                return router ? router[this._mode](routerPointer) : this.e.getURL(new URL(`${this._mode}/${routerPointer || this.e.env.modes[this._mode].pointer}.${this.e.env.modes[this._mode].suffix}`, this.baseURI).href)
            } else if (useValue.includes('/')) {
                return this.e.getURL(new URL(useValue, this.baseURI).href) 
            } else { return this.e.getURL(new URL(`${this._mode}/${useValue}.${this.e.env.modes[this._mode].suffix}`, this.baseURI).href) }
        }

        async #refresh(payload) {
            const boundResource = this.boundResource
            if (!boundResource) return
            let result
            if (typeof boundResource === 'string') {
                let contentType = this.getAttribute('content-type') || this._contentType || undefined
                if (this._isReference && ((contentType === 'application/javascript') || boundResource.endsWith('.mjs') || boundResource.endsWith('.js'))) {
                    result = await import(boundResource)
                } else if (contentType === 'application/schema+json') { 
                    result = boundResource
                } else {
                    let resourceOptions = this.resourceOptions, 
                        requestOptions = (resourceOptions.eEnv) ? Object.assign({...this.e.env.options.fetchOptions[resourceOptions.eEnv] || {}}, resourceOptions) : resourceOptions
                    if (payload instanceof Object) {
                        requestOptions.body = await this.#serialize(payload)
                    } else if (payload) {
                        fetchOptions.method ||= 'POST'
                        fetchOptions.body = `${payload}`
                    }
                    const req = fetch(boundResource, requestOptions)
                    if (this._isReference) {
                        if ((contentType === 'application/wasm') || boundResource.endsWith('.wasm')) {
                            result = await WebAssembly.instantiateStreaming(req)
                        } else { result = req.then(r => r.body) }
                    } else {
                        let response = await req
                        if (response.status >= 400) {
                            const rewriteRules = this.rewriteRules
                            if (rewriteRules.length) for (const [rx, p] of rewriteRules) if (rx == response.status) { 
                                response = await fetch(this.#resolveUrl(p), requestOptions)
                                break 
                            } 
                            if (response.status >= 400) {
                                this.dispatchEvent(new CustomEvent('error', {detail: {type: 'refresh', status: response.status, input: response.url, requestOptions}}))
                                if (this.errors === 'throw') { throw new Error(response.text()); return } else if (this.errors === 'hide') { return }
                            }
                        }
                        result = await this.#parse(response)
                    }
                }
            } else {
                if (typeof payload === 'string') {
                    if ((boundResource instanceof WebSocket) || (boundResource instanceof EventSource)) result = this.#parse(payload)
                } else { result = boundResource }
            }
            let transform = this.transform || this.getAttribute('transform')
            if (transform) {
            if (!this.e.env.libraries.jsonata && !document.querySelector('script[src="https://cdn.jsdelivr.net/npm/jsonata/jsonata.min.js"]')) {
                const scriptTag = document.createElement('script')
                scriptTag.setAttribute('src', 'https://cdn.jsdelivr.net/npm/jsonata/jsonata.min.js')
                document.head.append(scriptTag)
                await this.e.utils.waitUntil(() => window.jsonata)                
                this.e.env.libraries.jsonata = window.jsonata
            }
            await this.e.utils.waitUntil(() => this.e.env.libraries.jsonata)
                try { result = await this.e.env.libraries.jsonata(transform).evaluate(result) } catch(e) {
                    this.dispatchEvent(new CustomEvent('error', {detail: {type: 'transform', message: e, input: result}}))
                    if (this.errors === 'throw') { throw new Error(e); return } else if (this.errors === 'hide') { result = {} }
                }
            }
            const boundTarget = this.boundTarget ?? this.parentElement
            this._apply(result, Array.isArray(boundTarget) ? boundTarget : [boundTarget])
            //.then(() => this.dispatchEvent(new CustomEvent('_apply', {detail: result})))
        }

        async #parse(response) {
            if (this.#parser) return await this.parser(response)
            const typeCheck = (response instanceof Response) || (typeof response === 'text')
            if (!typeCheck && (response instanceof Object)) return response
            response = typeCheck ? response : `${response}`
            let contentType = this.getAttribute('content-type') || this.resourceOptions['Content-Type'] || this._contentType || undefined
            if (!contentType && (response instanceof Response)) {
                contentType ||= response.headers.get('Content-Type') || undefined
                contentType = (response.url.endsWith('.json') || contentType.includes('json')) ? 'application/json' : contentType
                contentType = (response.url.endsWith('.proto') || contentType.includes('protobuf')) ? 'application/x-protobuf' : contentType
                contentType = (response.url.endsWith('.yaml') || contentType.includes('yaml')) ? 'application/x-yaml' : contentType
                contentType ||= response.url.endsWith('.hjson') ? 'application/hjson' : undefined
                contentType ||= response.url.endsWith('.msgpack') ? 'application/msgpack' : undefined
                contentType ||= response.url.endsWith('.cbor') ? 'application/cbor' : undefined
            }
            contentType ||= 'application/json'
            if (!contentType.includes('/')) contentType = `application/${contentType}`
            if ((contentType === 'text/html') || (contentType === 'text/plain')) return (response instanceof Response) ? await response.text() : response
            if (contentType === 'application/json') return (response instanceof Response) ? await response.json() : JSON.parse(response)
            let text = (response instanceof Response) ? await response.text() : response 
            if (contentType === 'text/md') {
                await this.#installRemarkable()
                let mdOptions = {...this.e.env.options.remarkable}
                if (this.hasAttribute('md')) mdOptions = {...mdOptions, ...Object.fromEntries((this.e.utils.parseObjectAttribute(this.getAttribute('md')) || {}).entries())}
                this.e.env.libraries.remarkable.set(mdOptions)
                const htmlBlocks = (text.match(new RegExp('<html>\\n+.*\\n+</html>', 'g')) ?? []).map(b => [crypto.randomUUID(), b]), 
                    htmlSpans = (text.match(new RegExp('<html>.*</html>', 'g')) ?? []).map(b => [crypto.randomUUID(), b])
                for (const [blockId, blockString] of htmlBlocks) text = text.replace(blockString, `<div id="${blockId}"></div>`)
                for (const [spanId, spanString] of htmlSpans) text = text.replace(spanString, `<span id="${spanId}"></span>`)
                text = this.e.env.libraries.remarkable.render(text)
                for (const [spanId, spanString] of htmlSpans) text = text.replace(`<span id="${spanId}"></span>`, spanString.slice(6, -7).trim())
                for (const [blockId, blockString] of htmlBlocks) text = text.replace(`<div id="${blockId}"></div>`, blockString.slice(6, -7).trim())
                return text
            }
            if (contentType === 'text/css') {
                return await (new CSSStyleSheet()).replace(text)                
            }
            if (contentType === 'application/hjson') {
                this.e.env.libraries.hjson ||= await import('https://cdn.jsdelivr.net/npm/hjson@3.2.2/+esm')
                return this.e.env.libraries.hjson.parse(text)
            }
            if (contentType.includes('yaml')) {
                this.e.env.libraries.yaml ||= await import('https://cdn.jsdelivr.net/npm/yaml@2.3.2/+esm')
                return this.e.env.libraries.yaml.parse(text)
            }
            const buffer = (['application/x-protobuf', 'application/msgpack', 'application/cbor'].includes(contentType)) ? ((new TextEncoder()).encode(text).buffer) : undefined
            if (contentType === 'application/x-protobuf') {
                await this.#installProtobuf()
                try {
                    root = await new Promise((resolve, reject) => { this.e.env.libraries.protobuf.load(buffer, (error, loadedRoot) => error?reject(error):resolve(loadedRoot)) }), protobufAttr = this.getAttribute('protobufd-type'), messageType = protobufAttr ? root.lookupType(protobufAttr) : root.nestedArray[0]
                    return MyMessage.toObject(messageType.decode(new Uint8Array(buffer)), { defaults: true, arrays: true, objects: true })
                } catch(e) {
                    this.dispatchEvent(new CustomEvent('error', {detail: {type: 'parse', message: e, input: response.url, fetchOptions}}))
                    if (this.errors === 'throw') { throw new Error(e); return } else { return {} }
                }
            }
            if (contentType === 'application/msgpack') {
                this.e.env.libraries.msgpack ||= await import('https://cdn.jsdelivr.net/npm/msgpack-lite@0.1.26/+esm')
                return this.e.env.libraries.msgpack.decode((new Uint8Array(buffer)))
            }
            if (contentType === 'application/cbor') {
                this.e.env.libraries.cbor ||= await import('https://cdn.jsdelivr.net/npm/cbor-js@0.1.0/+esm')
                return this.e.env.libraries.cbor.decode((new Uint8Array(buffer)))
            }
            return text
        }

        async #serialize(value) {
            if (this.#serializer) return await this.serializer(value)
            if (typeof value === 'string') return value
            let contentType = this.getAttribute('content-type') || this.targetOptions['Content-Type'] || this._contentType || 'application/json'
            if (!contentType.includes('/')) contentType = `application/${contentType}`
            if (contentType === 'application/json') return JSON.stringify(value)
            if (contentType.includes('protobuf')) {
                await this.#installProtobuf()
                let schema = this.getAttribute('protobuf-schema'), type = this.getAttribute('protobuf-type')
                if (!schema.includes('{') && (this.e.env.options.protobuf?.schemas ??{})[schema]) schema = this.e.env.options.protobuf.schemas[schema]
                const root = this.e.env.libraries.protobuf.parse(schema).root
                if (type) return (root.lookupType(type)).encodeText(value)
                const typeClass = root.lookupType(type), message = typeClass.create()
                for (const [k, v] in Object.entries(value)) message[k] = v
                return typeClass.encodeText(message)
            }
            if (contentType === 'application/msgpack') {
                this.e.env.libraries.msgpack ||= await import('https://cdn.jsdelivr.net/npm/msgpack-lite@0.1.26/+esm')
                return this.e.env.libraries.msgpack.encode(value) //ArrayBuffer
            }
            if (contentType === 'application/cbor') {
                this.e.env.libraries.cbor ||= await import('https://cdn.jsdelivr.net/npm/cbor-js@0.1.0/+esm')
                return this.e.env.libraries.cbor.encode(value) // ArrayBuffer
            }
            if (contentType === 'text/html' || contentType === 'text/md') {
                if (!(value instanceof Node)) return 
                let text = value?.outerHTML ?? value.textContent
                if (contentType === 'text/md') {
                    await this.#installRemarkable()
                    let mdOptions = {...this.e.env.options.remarkable}
                    if (this.hasAttribute('md')) mdOptions = {...mdOptions, ...Object.fromEntries((this.e.utils.parseObjectAttribute(this.getAttribute('md')) || {}).entries())}
                    this.e.env.libraries.remarkable.set(mdOptions)
                    text = this.e.env.libraries.remarkable.render(text)
                }
                return text
            }
            if (contentType === 'text/css') {
                if (value instanceof Node) return (await (new CSSStyleSheet()).replace(value.textContent)).cssRules.map(rule => rule.cssText).join('\n')
                if (value instanceof CSSStyleSheet) return value.cssRules.map(rule => rule.cssText).join('\n')
            }
            if (contentType === 'application/hjson') {
                this.e.env.libraries.hjson ||= await import('https://cdn.jsdelivr.net/npm/hjson@3.2.2/+esm')
                return this.e.env.libraries.hjson.stringify(value)
            }
            if (contentType.includes('yaml')) {
                this.e.env.libraries.yaml ||= await import('https://cdn.jsdelivr.net/npm/yaml@2.3.2/+esm')
                return this.e.env.libraries.yaml.stringify(value)
            }
        }

        #createBound(value, mode) {
            const setBound = v => mode === 'resource' ? (this.#boundResource = v) : (this.#boundTarget = v),
                getBound = () => mode === 'resource' ? this.#boundResource : this.#boundTarget,  
                setBoundController = v => mode === 'resource' ? (this.#boundResourceController = v) : (this.#boundTargetController = v), 
                getBoundController = () => mode === 'resource' ? this.#boundResourceController : this.#boundTargetController,
                setBoundObserver = v => mode === 'resource' ? (this.#boundResourceObserver = v) : (this.#boundTargetObserver = v), 
                getBoundObserver = () => mode === 'resource' ? this.#boundResourceObserver : this.#boundTargetObserver, 
                setCount = v => mode === 'resource' ? (this.#boundResourceRefreshCount = v) : (this.#boundTargetRefreshCount = v), 
                getCount = () => mode === 'resource' ? this.#boundResourceRefreshCount : this.#boundTargetRefreshCount
            let useValue = value ?? '|'
            //if (this.#rewriteRules.length) for (const [rx, p] of this.#rewriteRules) { if (useValue.match(rx)) useValue = p; break }
            const useFlags = ['!', '$', '_'], startsWithFlag = useFlags.includes(useValue[0])
            if (useValue.includes('|') || startsWithFlag) {
                let [closest, selector, useRefresh] = startsWithFlag ? ['', '', useValue] : useValue.split('|').map(s => decodeURIComponent(s).trim()), 
                [use, refreshOn] = !useRefresh ? ['$', 'change']
                    : (useFlags.includes(useRefresh[0]) ? [ useRefresh[0] , useRefresh.slice(1).trim() || 'change']: ['!' , useRefresh]) 
                const scope = startsWithFlag ? this : (closest ? (this.closest(closest) ?? this.getRootNode()) : this.parentElement)
                if (!selector) {
                    setBound(scope)
                } else if (selector.includes('[') && selector.endsWith(']')) {
                    setBound(this.#sliceAndStep(selector, Array.from(scope.querySelectorAll(selector))))
                } else { setBound(scope.querySelector(selector)) }
                if (selector) {
                    const processRecords = records => {
                        const nodesToRemove = [], updatedNodes = [], addedNodes = [], newBind = []
                        for (const record of records) {
                            nodesToRemove.push(...(record?.removedNodes || []))
                            if (record?.target && record.target.matches(selector)) updatedNodes.push(record.target)
                            for (const addedNode of (record?.addedNodes || [])) if (addedNode?.matches && addedNode.matches(selector)) addedNodes.push(addedNode)
                        }
                        let alreadyBound = getBound()
                        if (!Array.isArray(alreadyBound)) alreadyBound = [alreadyBound]
                        for (const node of alreadyBound) if (node.isConnected && node?.matches && node.matches(selector) && !nodesToRemove.includes(node)) newBind.push(node)
                        for (const node of updatedNodes) if (node.isConnected && node?.matches && node.matches(selector) && !newBind.includes(node) && !nodesToRemove.includes(node)) newBind.push(node)
                        for (const node of addedNodes) if (node.isConnected && node?.matches && node.matches(selector) && !newBind.includes(node) && !nodesToRemove.includes(node)) newBind.push(node)
                        newBind.sort((a, b) => ((a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) ? -1 : 1) )
                        setBound((selector.includes('[') && selector.endsWith(']')) ? this.#sliceAndStep(selector, newBind) : newBind)
                    }
                    let observer = getBoundObserver()
                    if (observer) processRecords(observer.takeRecords())
                    observer && (observer.disconnect())
                    setBoundObserver(new MutationObserver(processRecords))
                    observer = getBoundObserver()
                    observer.observe(scope, {subtree: true, childList: true, attributes: true, attributeOldValue: true})
                }
                if (refreshOn) {
                    let boundController = getBoundController()
                    if (boundController) boundController.abort()
                    setBoundController(new AbortController())
                    boundController = getBoundController()
                    const stepRefresh = refreshOn.includes('[') && refreshOn.endsWith(']') 
                    let [start=0, end=1, step=0] = refreshOn.split('[').pop().slice(0, -1).split(':').map(s => (parseInt(s) || 0)), bound = getBound()
                    const bindNodes = Array.isArray(bound) ? bound : [bound], eventNames = refreshOn.split(',').map(s => s.trim())
                    if (mode === 'resource') {
                        for (const eventName of eventNames) {
                            for (const node of bindNodes) {
                                node.addEventListener(eventName, event => {
                                    const proceed = true
                                    let count = getCount()
                                    if (stepRefresh) proceed = (count >= start) && (count < end)
                                    setCount(count + 1)
                                    count = getCount()
                                    if (proceed && stepRefresh && step) proceed = !!((step === 1) ? (count % 2) : (count % step === 0))
                                    if (use === '!') { 
                                        this.#refresh(event) 
                                    } else if (use === '_') {
                                        this.#refresh(bound)
                                    } else if (Array.isArray(bound)) {                                    
                                        this.#refresh(bound.map(node => this.e.getValue(node)))
                                    } else { this.#refresh(this.e.getValue(node)) }
                                }, {signal: boundController.signal})
                            }
                        }
                    } else {
                        /*this.addEventListener('_apply', event => {
                            if (use === '!') {
                                for (const eventName of eventNames) for (const node of bindNodes) node.dispatchEvent(new CustomEvent(eventName, {detail: event.detail}))
                            } else if (use === '_') {
                                for (const node of bindNodes) this.e.setValue(node, event.detail)
                            } else {
                                let data, flag, transform, sourceElement, context 
                                if (!Array.isArray(event.detail) && (event.detail instanceof Object)) {
                                    ({data, flag, transform, sourceElement, context} = event.detail)
                                } else { data = event.detail }
                                for (const node of bindNodes) this.e.sinkData(node, data, flag, transform, sourceElement, context)
                            }
                        }, {signal: boundController.signal})*/
                    }
                }
            } else {
                let url = this.#resolveUrl(useValue)
                if (url.startsWith('wss://') || url.includes('!')) {
                    let eventSource, eventPayloadList = ['message']
                    if (url.startsWith('wss://')) {
                        eventSource = new WebSocket(url)
                    } else {
                        const [sourceUrl, eventList] = this.e.utils.splitOnce(url, '!').map(s => s.trim())
                        eventSource = new EventSource(sourceUrl)
                        if (eventList) eventPayloadList = eventList.split(',')
                    }
                    if (eventSource) {
                        eventSource.addEventListener('open', event => {
                            let boundController = getBoundController()
                            if (boundController) boundController.abort()
                            setBound(eventSource)
                            setBoundController(new AbortController())
                            boundController = getBoundController()
                            if (mode === 'resource') {
                                for (const eventName of eventPayloadList) {
                                    eventSource.addEventListener(eventName, event => {
                                        this.#refresh(this.#parse(event.data))
                                    }, {signal: boundController.signal})
                                }
                            } else {
                                if (typeof eventSource.send === 'function') {
                                    /*this.addEventListener('_apply', async event => {
                                        eventSource.send(await this.#serialize(event.detail))
                                    }, {signal: boundController.signal})*/
                                }
                            }
                        })
                    }
                } else {
                    let boundController = getBoundController()
                    if (boundController) boundController.abort()
                    setBoundController(new AbortController())
                    boundController = getBoundController()
                    setBound(url)
                    if (mode === 'resource') {
                        if (useValue.includes(':#')) {
                            window.addEventListener('hashchange', event => {
                                const resource = this.#resource
                                this.#resource = undefined
                                this.resource = resource
                            }, {signal: boundController.signal})
                        }

                    } else if (mode === 'target') {
                        /*this.addEventListener('_apply', event => {
                            let targetOptions = this.targetOptions, 
                                requestOptions = (targetOptions.eEnv) ? Object.assign({...this.e.env.options.rewriteRules[targetOptions.eEnv] || {}}, targetOptions) : targetOptions
                            fetch(getBound(), requestOptions)
                        }, {signal: boundController.signal})*/
                    }
                }
            }
        }

        set resource(value) {
            if (this.#resource === value) return
            this.#createBound(value, 'resource')
            this.#resource = value
            this.#refresh()
        }
        get resource() { return this.#resource }

        get boundResource() { 
            const resourceAttrVal = this.getAttribute('resource')
            if (resourceAttrVal && !this.#resource) {
                this.#createBound(resourceAttrVal, 'resource')
                this.#resource = resourceAttrVal
            }
            return this.#boundResource 
        }

        set target(value) { 
            if (this.#target === value) return
            this.#createBound(value, 'target')
            this.#target = value
        }
        get target() { return this.#target }

        get boundTarget() { 
            const targetAttrVal = this.getAttribute('target')
            if (targetAttrVal && !this.#target) {
                this.#createBound(targetAttrVal, 'target')
                this.#target = targetAttrVal
            }
            return this.#boundTarget
        }

        set transform(value) { this.#transform = value }
        get transform() { return this.#transform }

        set apply(value) { this.#apply = value }
        get apply() { return this.#apply }

        #buildRewrites() {
            if ((this.getAttribute('rewrite') ?? '') !== (this.#rewrite ?? '')) {
                let value = this.getAttribute('rewrite')
                this.#rewriteRules = []
                let rewriteRulesThis = this.e.utils.parseObjectAttribute(value) ?? {}, 
                rewriteRulesObject = (rewriteRulesThis.eEnv) ? Object.assign({...this.e.env.options.rewriteRules[rewriteRulesThis.eEnv] || {}}, rewriteRulesThis) : rewriteRulesThis
                for (const [re, p] of Object.entries(rewriteRulesObject)) this.#rewriteRules.push([Number.isInteger(Number(re)) ? re : new RegExp(re), p])
            }
        }

        set rewrite(value) {
            this.#buildRewrites()
            this.#rewrite = value
        }
        get rewrite() { return this.#rewrite }

        get rewriteRules() { 
            this.#buildRewrites()
            return this.#rewriteRules ?? [] 
        }

        set errors(value) { this.#errors = value }
        get errors() { return this.#errors ?? this.e.env.options.errors }

        set parser(value) { this.#parser = this.e.utils.resolveMeta(this, 'e-processor', value) }
        get parser() { return this.#parser }

        set serializer(value) { this.#serializer = this.e.utils.resolveMeta(this, 'e-processor', value) }
        get serializer() { return this.#serializer }

        set options(value) {
            this.#options = this.e.utils.parseObjectAttribute(value)
            this.#optionsString = value
        }
        get options() { return this.#optionsString }

        set ['resource-options'](value) {
            this.#resourceOptions = this.e.utils.parseObjectAttribute(value)
            this.#resourceOptionsString = value
        }
        get ['resource-options']() { return this.#resourceOptionsString }

        get resourceOptions() { return {...this.#options, ...this.#resourceOptions} }

        set ['target-options'](value) {
            this.#targetOptions = this.e.utils.parseObjectAttribute(value)
            this.#targetOptionsString = value
        }
        get ['target-options']() { return this.#targetOptionsString }

        get targetOptions() { return {...this.#options, ...this.#targetOptions} }

        /*set processor(value) { this.#processor = this.e.utils.resolveMeta(this, 'e-processor', value) }
        get processor() { return this.#processor }*/

    }
</script>