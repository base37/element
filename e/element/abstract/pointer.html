<style></style>
<template><slot></slot></template>
<script>
    class extends `meta` {

        #mode
        #router
        #pointer
        #processor

        #scope
        #selector
        #match
        #bind
        #bindController
        #as

        #errors

    	constructor() {
    		super()
            Object.defineProperties(this, {
                _mode: {configurable: true, enumerable: false, set: value => this.#mode = value, get: () => this.#mode}, 
                _router: {get: () => this.#router}, 
                _pointer: {get: () => this.#pointer}, 
                _rawResponse: {get: async () => {
                    let resource = this.resource
                    return resource ? await fetch(this.e.getURL(new URL(resource, this.baseURI).href)) : new Response('null', {status: 599})
                }},
                _parse: {configurable: true, writable: true, value: async (response) => {
                    switch(this._mode) {
                    case 'processor':
                    case 'schema':
                        return response
                    default: 
                        return await response.text()
                    }
                }},
                _useResponse: {configurable: false, get: async () => {
                    let resource = this.resource
                    if (resource && resource.startsWith('$')) {
                        let useResponse = {}, scope, query
                        if (this.#bind) {
                            let [, scopeQuery] = this.e.utils.splitOnce(resource, ').').map(s => s.trim());
                            [scope,query] = this.e.utils.splitOnce(scopeQuery, '.').map(s => s.trim())
                        } else { [,scope,query] = this.e.utils.splitOnce(resource, '.').map(s => s.trim()) }
                        if (scope !== 'eSelf' && !scope.startsWith('eSubtree')) [query, scope] = [scope, 'eSelf']
                        if (scope === 'eSelf') {
                            useResponse = query ? (this.#bind ?? this)[query] : (this.#bind ?? this)
                        } else if (scope.startsWith('eSubtree')) {
                            scope = scope.replace('eSubtree', '')
                            let subTree = (this.#bind || this).querySelectorAll(scope[0] === '(' ? scope.slice(1, -1).trim() : ':scope > *')
                            useResponse = Array.from(subTree)
                            scope = scope.slice(1).trim()
                            if (query) {
                                if (query.startsWith('@')) {
                                    useResponse = useResponse.map(n => n.getAttribute(query.slice(1)))
                                } else {
                                    useResponse = useResponse.map(n => n[query])
                                }
                            } 
                        } else if (query && query.includes('.') || query.includes('[') || query.includes('(') || query.includes('{') || query.includes(' ')) {
                            if (!window.jsonata) {
                                const scriptTag = document.createElement('script')
                                scriptTag.setAttribute('src', 'https://cdn.jsdelivr.net/npm/jsonata/jsonata.min.js')
                                document.head.append(scriptTag)
                                await this.e.utils.waitUntil(() => window.jsonata)
                            }
                            try {
                                useResponse = window.jsonata(query).evaluate((this.#bind ?? this)[scope] ?? {})
                            } catch(e) {
                                this.dispatchEvent(new CustomEvent('error', {detail: {type: 'parse', message: e, input: (this.#bind ?? this)[scope], resource}}))
                                if (this.errors === 'throw') { throw new Error(e); return }
                            }
                        } else { useResponse = (query ? (bind[scope] ?? {})[query] : (this.#bind ?? this)[scope]) ?? {} }
                        return useResponse
                    }
                    if (this._mode === 'processor') return await this._parse(`${this}`)
                    if (this._mode === 'schema') return await this._parse(`${this}`)
                    return await this._parse(await this._rawResponse)
                }}, 
                _activate: {value: async () => {
                    const scopeElement = this.#match ? ((this.#scope ? this.closest(this.#scope) : this.getRootNode()) ?? this.getRootNode()) : this.parentElement, recordLoadEnd = () => {
                        window.requestAnimationFrame(() => {
                            this.dispatchEvent(new CustomEvent('loadended'))
                            delete this.e.env.loadingRegistry[this]
                            if (!Object.keys(this.e.env.loadingRegistry).length) this.e.env.eDataset.dispatchEvent(new CustomEvent('loadended'))
                        })
                    }
                    if (!this.#match) return await this._as(await this._useResponse, 'add', scopeElement, scopeElement.previousElementSibling, scopeElement.nextElementSibling, {}).then(() => recordLoadEnd())
                    const processRecords = async recordsToProcess => {
                        const queue = {}
                        for (const record of recordsToProcess) {
                            if (record.type === 'childList') {
                                for (const addedNode of record.addedNodes) if (typeof addedNode.matches === 'function' && addedNode.matches(this.#selector||':scope')) queue[addedNode] = ['add', addedNode, record.previousSibling, record.nextSibling]
                                for (const removedNode of record.removedNodes) if (typeof removedNode.matches === 'function' && removedNode.matches(this.#selector||':scope')) queue[removedNode] = ['remove', removedNode, record.previousSibling, record.nextSibling]
                            }
                        }
                        const queueValues = Object.values(queue)
                        if (queueValues.length) {
                            const useResponse = await this._useResponse
                            for (const queueValue of queueValues) this._as(useResponse, ...queueValue)
                        }
                    }
                    this.e.createObserver(this, scopeElement, processRecords, processRecords)
                    const useResponse = await this._useResponse, matches = scopeElement.querySelectorAll(this.#selector||':scope'), promises = []
                    for (const matched of matches) promises.push(this._as(useResponse, 'add', matched, 
                        matched.previousElementSibling, matched.nextElementSibling, Object.assign({}, 
                            ...matched.getAttributeNames().map(a => ({[a]: matched.getAttribute(a)})))))
                    Promise.all(promises).then(() => recordLoadEnd())
                }},
                _refresh: {configurable: true, writable: true, value: async (payload) => {
                    let useResponse = payload ? payload : await this._useResponse
                    const scopeElement = this.#match ? ((this.#scope ? this.closest(this.#scope) : this.getRootNode()) ?? this.getRootNode()) : this.parentElement
                    if (!this.#match) return await this._as(useResponse, 'add', scopeElement, scopeElement.previousElementSibling, scopeElement.nextElementSibling, {})
                    for (const matched of scopeElement.querySelectorAll(this.#selector||':scope')) this._as(useResponse, 'add', matched, 
                        matched.previousElementSibling, matched.nextElementSibling, Object.assign({}, 
                            ...matched.getAttributeNames().map(a => ({[a]: matched.getAttribute(a)}))))
                }},
                _as: {configurable: true, writable: true, value: async (useResponse, addOrRemove, node, previousSibling, nextSibling, oldAttributeValues) => {
                    console.log(useResponse, addRemoveOrUpdate, node, previousSibling, nextSibling, oldAttributeValues)
                }}
            })
            /*Object.defineProperty(this, '_pointer', {configurable: false, writable: false, value: Object.defineProperties({}, { _parse: {value: this._parse.bind(this)} }) })*/
    	}

		static get observedAttributes() { return (super.observedAttributes || []).concat('resource', 'match', 'as', 'errors', 'processor') }

        async connectedCallback() {
            const selfObserver = new MutationObserver(events => {
                for (const event of events) this.dispatchEvent(new CustomEvent('change', {detail: event}))
            })
            selfObserver.observe(this, { attributes: true, attributeOldValue: true })
            if (!Object.keys(this.e.env.loadingRegistry).length) this.e.env.eDataset.dispatchEvent(new CustomEvent('loadstarted'))
            this.e.env.loadingRegistry[this] = true
            this.dispatchEvent(new CustomEvent('loadstarted'))
            this.addEventListener('sinkData', event => {
                if (this.#pointer && this.#pointer.startsWith('$.eData')) this._refresh()
            })            
            this.addEventListener('change', event => {
                if (this.#pointer && this.#pointer.startsWith('$.eDataset')) this._refresh()
            })            
            await this._activate()
        }

// $(scope|selector!eventName)... -> bind to scope|selector node, and return the data from the node, ... re-rendering whenever it emits 'eventName' event
// $(scope|selector)!eventName -> bind to $() node, but return only the data from the 'eventName' event when it occurs

// https://example.com -> implicitly return the parsed Response through to this.as and optionally re-render after this.send() method call
// wss://example.com/path -> implicitly return the MessageEvent.data object through to this.as and re-render on event message event, use this.send() to push data
// https://example.com/see!eventName -> use for Server-Sent Events, returning the event data when the 'eventName' event is received

        toString() { return this.resource ?? '' }

        set resource(value) {
            if (value) {
                if (value.startsWith('$(') && value.includes(')')) {
                    if (this.#bindController) this.#bindController.abort()
                    const bindMatch = value.split(')')[0].slice(2)
                    let bindScope, bindSelector, bindEvents
                    if (bindMatch.includes('|')) {
                        [bindScope, bindSelector] = this.e.utils.splitOnce(bindMatch, '|').map(s => s.trim())
                        bindScope = this.closest(bindScope)
                        if (!bindScope) {
                            this.dispatchEvent(new CustomEvent('error', {detail: {type: 'bind:scope', message: e, attribute: 'resource', input: value}}))
                            if (this.errors === 'throw') { throw new Error(e); return }
                            bindScope ||= this.getRootNode()
                        }
                    } else {
                        bindScope = this.getRootNode()
                        bindSelector = bindMatch
                    }
                    if (bindSelector.includes('!')) [bindSelector, bindEvents] = this.e.utils.splitOnce(bindSelector, '!').map(s => s.trim())
                    this.#bind = bindSelector ? (bindScope.querySelector(bindSelector)) : bindScope
                    if (!this.#bind) {
                        this.dispatchEvent(new CustomEvent('error', {detail: {type: 'bind:selector', message: e, attribute: 'resource', input: value}}))
                        if (this.errors === 'throw') { throw new Error(e); return }
                        this.#bind ||= this.getRootNode()
                    }
                    if (this.#bind instanceof ShadowRoot) this.#bind = this.#bind.host
                    const eventsToBind = bindEvents ? bindEvents.split(',') : ['change', 'sinkData']
                    this.#bindController = new AbortController()
                    for (const eventName of eventsToBind) {
                        bindScope.addEventListener(eventName, event => {
                            if (!bindSelector || event.target.matches(bindSelector)) this._refresh()
                        }, {signal: this.#bindController.signal})
                    }
                    if (value.includes(')!')) {
                        const [, eventPayloadList] = this.e.utils.splitOnce(value, ')!'), eventPayloads = eventPayloadList.split(',')
                        for (const eventPayload of eventPayloads) {
                            bindScope.addEventListener(eventPayload, event => {
                                if (!bindSelector || event.target.matches(bindSelector)) this._refresh(event.detail)
                            }, {signal: this.#bindController.signal})
                        }   
                    }
                    this.#router = undefined
                    this.#pointer = value
                } else if ((value !== '/') && (value.startsWith('/') || value.startsWith('./') || value.startsWith('../') || value.includes('://'))) {
                    this.#pointer = value
                    let eventSource, eventPayloadList = ['message']
                    if (this.#pointer.startsWith('wss://') || this.#pointer.startsWith('ws://')) {
                        eventSource = new WebSocket(this.#pointer)                        
                    } else if (this.#pointer.includes('!')) {
                        const [sourceUrl, eventList] = this.e.utils.splitOnce(this.#pointer, '!').map(s => s.trim())
                        eventSource = new EventSource(sourceUrl)
                        if (eventList) eventPayloadList = eventList.split(',')
                    }
                    eventSource.addEventListener('open', event => {
                        this.#bindController = new AbortController()
                        for (const eventName of eventPayloadList) {
                            eventSource.addEventListener(eventName, event => {
                                this._refresh(event.data)
                            }, {signal: this.#bindController.signal})
                        }
                    })
                } else if (value.includes(':')) {
                    [this.#router, this.#pointer] = this.e.utils.splitOnce(value, ':').map(s => s.trim())
                } else {
                    this.#router = undefined
                    this.#pointer = value
                }
                let flag, flagMap = {'/': document.location.pathname, '#': document.location.hash, '?': document.location.search}
                if (this.#pointer && Object.keys(flagMap).includes(this.#pointer[0])) {
                    flag = this.#pointer[0]
                    if (flag === '?' && (this.#pointer[1] === '[') && (this.#pointer.slice(-1) === ']')) {
                        this.#pointer = (new URLSearchParams(flagMap[flag])).get(this.#pointer.slice(2, -1))
                    } else {
                        if (this.#pointer === flag) {
                            this.#pointer = flagMap[flag].slice(1)
                        } else {
                            try {
                                this.#pointer = flagMap[flag].replace(new RegExp(this.#pointer), '')
                            } catch(e) { this.#pointer = flagMap[flag].replace(this.#pointer, '') }
                        }
                    }
                } else { this.#pointer ||= this.e.env.modes[this.#mode].pointer }
            } else {
                this.#router = undefined
                this.#pointer = undefined
            }
        }
        get resource() {
            if (this.#pointer && this.#pointer.startsWith('$')) return this.#pointer
            if (this.#pointer && (this.#pointer !== '/') && (this.#pointer.startsWith('/') || this.#pointer.startsWith('./') || this.#pointer.startsWith('../') || this.#pointer.includes('://'))) return this.#pointer
            let router = this.#router ? (this.e.resolveMeta(this, 'e-router', this.#router) ?? this.e.resolveMeta(this, 'e-router')) : undefined
            return router ? router[this._mode](this.#pointer) : undefined
        }

        get router() { return this.#router }

        get pointer() { return this.#pointer }

        get scope() { return this.#scope }
        get selector() { return this.#selector }

        get bind() { return this.#bind }        

        set match(value) { 
            this.#match = value
            if (!value) {
                this.#scope = undefined
                this.#selector = undefined
                return
            }
            if (!value.includes('|')) {
                this.#scope = undefined
                this.#selector = value
                return
            }
            [this.#scope, this.#selector] = this.e.utils.splitOnce(value, '|').map(s => s.trim())
        }
        get match() { return this.#match }

        set as(value) { this.#as = value }
        get as() { return this.#as }

        set errors(value) { this.#errors = value }
        get errors() { return this.#errors ?? this.e.env.options.errors }

        set processor(value) { this.#processor = this.e.resolveMeta(this, 'e-processor', value) }
        get processor() { return this.#processor }

    }
</script>