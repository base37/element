<style></style>
<template><slot></slot></template>
<script>
    class extends `meta` {

        #mode
        #router
        #pointer
        #processor
        #serializer
        #fetchOptions

        #scope
        #selector
        #match
        #bind
        #bindController
        #transform
        #apply
        #rewrite
        #rewriteRules = {}
        #to

        #fetchOptionsString = ''
        #fetchOptions = {}

        #refreshCount = 0

        #errors

    	constructor() {
    		super()
            Object.defineProperties(this, {
                _mode: {configurable: true, enumerable: false, set: value => this.#mode = value, get: () => this.#mode}, 
                _router: {get: () => this.#router}, 
                _pointer: {get: () => this.#pointer}, 
                _rawResponse: {get: async () => {
                    let resource = this.resource
                    return resource ? await fetch(this.e.getURL(new URL(resource, this.baseURI).href)) : new Response('null', {status: 599})
                }},
                _parse: {configurable: true, writable: true, value: async (response) => {
                    switch(this._mode) {
                    case 'processor':
                    case 'schema':
                    case 'socket':
                        return response
                    default: 
                        return await response.text()
                    }
                }},
                _useResponse: {configurable: false, get: async () => {
                    let resource = this.resource
                    if (resource && resource.startsWith('$')) {
                        let useResponse = {}, scope, query
                        if (this.#bind) {
                            let [, scopeQuery='eSelf'] = this.e.utils.splitOnce(resource, ').').map(s => s.trim())
                            if (scopeQuery) [scope,query] = this.e.utils.splitOnce(scopeQuery, '.').map(s => s.trim())
                        } else { 
                            [,scope,...query] = resource.split('.').map(s => s.trim())
                            query = query.join('.') 
                        }
                        if (scope && scope.startsWith('eSubtree')) {
                            scope = scope.replace('eSubtree', '')
                            let subTree = (this.#bind || this).querySelectorAll(scope[0] === '(' ? scope.slice(1, -1).trim() : ':scope > *')
                            useResponse = Array.from(subTree)
                            scope = scope.slice(1).trim()
                            if (query) {
                                if (query.startsWith('@')) {
                                    useResponse = useResponse.map(n => n.getAttribute(query.slice(1)))
                                } else {
                                    useResponse = useResponse.map(n => n[query])
                                }
                            }
                        } else { useResponse = this.#bind ?? this }
                        if (query && (query.includes('.') || query.includes('[') || query.includes('(') || query.includes('{') || query.includes(' '))) {
                            if (!window.jsonata) {
                                const scriptTag = document.createElement('script')
                                scriptTag.setAttribute('src', 'https://cdn.jsdelivr.net/npm/jsonata/jsonata.min.js')
                                document.head.append(scriptTag)
                                await this.e.utils.waitUntil(() => window.jsonata)
                            }
                            try {
                                useResponse = await window.jsonata(query).evaluate(useResponse)
                            } catch(e) {
                                this.dispatchEvent(new CustomEvent('error', {detail: {type: 'parse', message: e, input: useResponse, resource}}))
                                if (this.errors === 'throw') { throw new Error(e); return }
                            }
                        } else if (query) { useResponse = useResponse[query] ?? {} }
                        return useResponse
                    }
                    if (['processor', 'schema', 'socket'].includes(this._mode)) return await this._parse(`${this}`)
                    return await this._parse(await this._rawResponse)
                }}, 
                _activate: {value: async () => {
                    const scopeElement = this.#match ? ((this.#scope ? this.closest(this.#scope) : this.getRootNode()) ?? this.getRootNode()) : this.parentElement, recordLoadEnd = () => {
                        window.requestAnimationFrame(() => {
                            this.dispatchEvent(new CustomEvent('loadended'))
                            delete this.e.env.loadingRegistry[this]
                            if (!Object.keys(this.e.env.loadingRegistry).length) this.e.env.eDataset.dispatchEvent(new CustomEvent('loadended'))
                        })
                    }
                    if (!this.#match) return await this._as(await this._useResponse, 'add', scopeElement, scopeElement.previousElementSibling, scopeElement.nextElementSibling, {}).then(() => recordLoadEnd())
                    const processRecords = async recordsToProcess => {
                        const queue = {}
                        for (const record of recordsToProcess) {
                            if (record.type === 'childList') {
                                for (const addedNode of record.addedNodes) if (typeof addedNode.matches === 'function' && addedNode.matches(this.#selector||':scope')) queue[addedNode] = ['add', addedNode, record.previousSibling, record.nextSibling]
                                for (const removedNode of record.removedNodes) if (typeof removedNode.matches === 'function' && removedNode.matches(this.#selector||':scope')) queue[removedNode] = ['remove', removedNode, record.previousSibling, record.nextSibling]
                            }
                        }
                        const queueValues = Object.values(queue)
                        if (queueValues.length) {
                            const useResponse = await this._useResponse
                            for (const queueValue of queueValues) this._as(useResponse, ...queueValue)
                        }
                    }
                    if (this._observer) processRecords(this._observer.takeRecords())
                    this._observer && (this._observer.disconnect() || (delete this._observer))
                    this._observer = new MutationObserver(processRecords)
                    this._observer.observe(scopeElement, {subtree: true, childList: true, attributes: true, attributeOldValue: true})
                    const useResponse = await this._useResponse, matches = scopeElement.querySelectorAll(this.#selector||':scope'), promises = []
                    for (const matched of matches) promises.push(this._as(useResponse, 'add', matched, 
                        matched.previousElementSibling, matched.nextElementSibling, Object.assign({}, 
                            ...matched.getAttributeNames().map(a => ({[a]: matched.getAttribute(a)})))))
                    Promise.all(promises).then(() => recordLoadEnd())
                }},
                _refresh: {configurable: true, writable: true, value: async (payload) => {
                    let useResponse = payload ? payload : await this._useResponse
                    const scopeElement = this.#match ? ((this.#scope ? this.closest(this.#scope) : this.getRootNode()) ?? this.getRootNode()) : this.parentElement
                    if (!this.#match) return await this._as(useResponse, 'add', scopeElement, scopeElement.previousElementSibling, scopeElement.nextElementSibling, {})
                    for (const matched of scopeElement.querySelectorAll(this.#selector||':scope')) this._as(useResponse, 'add', matched, 
                        matched.previousElementSibling, matched.nextElementSibling, Object.assign({}, 
                            ...matched.getAttributeNames().map(a => ({[a]: matched.getAttribute(a)}))))
                }},
                _as: {configurable: true, writable: true, value: async (useResponse, addOrRemove, node, previousSibling, nextSibling, oldAttributeValues) => {
                    console.log(useResponse, addRemoveOrUpdate, node, previousSibling, nextSibling, oldAttributeValues)
                }}
            })
    	}

		static get observedAttributes() { return (super.observedAttributes || []).concat('resource', 'transform', 'match', 'apply', 'rewrite', 'errors', 'processor') }

        async connectedCallback() {
            const selfObserver = new MutationObserver(events => {
                for (const event of events) this.dispatchEvent(new CustomEvent('change', {detail: event}))
            })
            selfObserver.observe(this, { attributes: true, attributeOldValue: true })
            if (!Object.keys(this.e.env.loadingRegistry).length) this.e.env.eDataset.dispatchEvent(new CustomEvent('loadstarted'))
            this.e.env.loadingRegistry[this] = true
            this.dispatchEvent(new CustomEvent('loadstarted'))
            this.addEventListener('sinkData', event => {
                if (this.#pointer && this.#pointer.startsWith('$.eData')) this._refresh()
            })            
            this.addEventListener('change', event => {
                if (this.#pointer && this.#pointer.startsWith('$.eDataset')) this._refresh()
            })            
            await this._activate()
        }

        toString() { return this.resource ?? '' }

        async _refresh(payload) {
            // event, Node, Array of Nodes, value, Websocket, EventSource, URL
            if (!this.#bind) return
            let result
            if (typeof this.#bind === 'string') {
                const fetchOptions = Object.assign({}, (this.e.env.options.fetchOptions[this.#fetchOptions.eBase] ?? {}), this.#fetchOptions)
                delete fetchOptions.eBase
                if (payload instanceof Object) {
                    fetchOptions = {...fetchOptions, ...payload}
                } else if (payload) {
                    fetchOptions.method ||= 'POST'
                    fetchOptions.body = `${payload}`
                }
                const rewriteRules = Object.assign({}, (this.e.env.options.rewriteRules[this.#rewriteRules.eBase] ?? {}), this.#rewriteRules)
                delete rewriteRules.eBase
                let response = await fetch(this.#bind, fetchOptions)
                if (response.status >= 400) {
                    const status = `${response.status}`
                    if (status in rewriteRules) response = await fetch(this.#resolveUrl(rewriteRules[status]), fetchOptions)
                    if (response.status >= 400) {
                        this.dispatchEvent(new CustomEvent('error', {detail: {type: 'refresh', status: response.status, input: response.url, fetchOptions}}))
                        if (this.errors === 'throw') { throw new Error(response.text()); return } else if (this.errors === 'hide') { return }
                    }
                }
                result = await this.#parse(response)
            } else { 
                if (typeof payload === 'string') {
                    if ((this.#bind instanceof WebSocket) || (this.#bind instanceof EventSource)) result = this.#parse(payload)
                } else { result = payload }
            }
            let transform = this.transform || this.getAttribute('transform')
            if (transform) {
                if (!window.jsonata) {
                    const scriptTag = document.createElement('script')
                    scriptTag.setAttribute('src', 'https://cdn.jsdelivr.net/npm/jsonata/jsonata.min.js')
                    document.head.append(scriptTag)
                    await this.e.utils.waitUntil(() => window.jsonata)
                }
                try {
                    result await window.jsonata(transform).evaluate(result)
                } catch(e) {
                    this.dispatchEvent(new CustomEvent('error', {detail: {type: 'transform', message: e, input: result}}))
                    if (this.errors === 'throw') { throw new Error(e); return } else if (this.errors === 'hide') { result = {} }
                }
            }
            let match = this.match || this.getAttribute('match'), target
            if (match) {
                let [closest, selector] = match.split('|').map(s => decodeURIComponent(s).trim())
                let scope = closest ? (this.closest(closest) ?? this.getRootNode()) : this.parentElement
                if (!selector) {
                    target = scope
                } else if (selector.includes('[') && selector.endsWith(']')) {
                    target = this.#sliceAndStep(selector, Array.from(scope.querySelectorAll(selector)))
                } else { target = scope.querySelector(selector) }
            } else { target = this.parentElement }
            this.apply(result, target)
        }

        async #parse(response) {
            if (this.#parser) return await (this.e.resolveMeta(this, 'e-processor', this.#parser))?.func(response)
            const typeCheck = (response instanceof Response) || (typeof response === 'text')
            if (!typeCheck && (response instanceof Object)) return response
            response = typeCheck ? response : `${response}`
            let contentType = this.getAttribute('content-type') || undefined
            if (!contentType && (response instanceof Response)) {
                contentType ||= response.headers.get('Content-Type') || undefined
                contentType = (response.url.endsWith('.json') || contentType.includes('json')) ? 'application/json' : contentType
                contentType = (response.url.endsWith('.proto') || contentType.includes('protobuf')) ? 'application/x-protobuf' : contentType
                contentType = (response.url.endsWith('.yaml') || contentType.includes('yaml')) ? 'application/x-yaml' : contentType
                contentType ||= response.url.endsWith('.hjson') ? 'application/hjson' : undefined
                contentType ||= response.url.endsWith('.msgpack') ? 'application/msgpack' : undefined
                contentType ||= response.url.endsWith('.cbor') ? 'application/cbor' : undefined
            }
            contentType ||= 'application/json'
            if (!contentType.includes('/')) contentType = `application/${contentType}`
            if (contentType === 'application/json') return (response instanceof Response) ? await response.json() : JSON.parse(response)
            const buffer = (response instanceof Response) ? (await response.arrayBuffer()) : ( (new TextEncoder()).encode(response).buffer ) , 
            if (contentType.includes('protobuf')) {
                if (!this.e.env.libraries.protobuf) {
                    const s = document.createElement('script')
                    s.setAttribute('src', 'https://cdn.jsdelivr.net/npm/protobufjs@7.2.5/dist/protobuf.min.js')
                    document.head.append(s)
                    this.e.utils.waitUntil(() => window.protobuf).then(() => this.e.env.libraries.protobuf = window.protobuf) 
                }
                try {
                    await this.e.utils.waitUntil(() => this.e.env.libraries.protobuf)
                    root = await new Promise((resolve, reject) => { this.e.env.libraries.protobuf.load(buffer, (error, loadedRoot) => error?reject(error):resolve(loadedRoot)) }), protobufAttr = this.getAttribute('protobuf'), messageType = protobufAttr ? root.lookupType(protobufAttr) : root.nestedArray[0]
                    return MyMessage.toObject(messageType.decode(new Uint8Array(buffer)), { defaults: true, arrays: true, objects: true })
                } catch(e) {
                    this.dispatchEvent(new CustomEvent('error', {detail: {type: 'parse', message: e, input: response.url, fetchOptions}}))
                    if (this.errors === 'throw') { throw new Error(e); return } else { return {} }
                }
            }
            if (contentType === 'application/msgpack') {
                this.e.env.libraries.msgpack ||= await import('https://cdn.jsdelivr.net/npm/msgpack-lite@0.1.26/+esm')
                return this.e.env.libraries.msgpack.decode((new Uint8Array(buffer)))
                // msgpack.encode({"foo": "bar"}) -> arrayBuffer
            }
            if (contentType === 'application/cbor') {
                this.e.env.libraries.cbor ||= await import('https://cdn.jsdelivr.net/npm/cbor-js@0.1.0/+esm')
                return this.e.env.libraries.cbor.decode((new Uint8Array(buffer)))
                // cobr.encode({"foo": "bar"}) -> arrayBuffer
            }

            const text = (response instanceof Response) ? await response.text() : response 
            if (contentType === 'application/hjson') {
                this.e.env.libraries.hjson ||= await import('https://cdn.jsdelivr.net/npm/hjson@3.2.2/+esm')
                return this.e.env.libraries.hjson.parse(text)
                //this.e.env.libraries.hjson.stringify(obj)
            }
            if (contentType.includes('yaml')) {
                this.e.env.libraries.yaml ||= await import('https://cdn.jsdelivr.net/npm/yaml@2.3.2/+esm')
                return this.e.env.libraries.yaml.parse(text)
            }
            return text
        }

        #sliceAndStep(selector, list) {
            let [start=0, end=bind.length, step=0] = selector.split('[').pop().slice(0, -1).split(':').map(s => (parseInt(s) || 0))
            list = list.slice(start, end)
            if (!step) return list
            return (step === 1) ? list.filter((v, i) => (i+1) % 2) : list.filter((v, i) => (i+1) % step === 0)            
        }

        apply(result, target) {
            target = Array.isArray(target) ? target : [target]
            for (const t of target) this.e.setValue(t, result)
        }

        set resource(value) {
            if (this.#resource === value) return
            let rewrite = [], rewriteRules = (this.#rewriteRules.eBase) ? Object.assign({...this.e.env.options.rewriteRules[this.#rewriteRules.eBase] || {}}, this.#rewriteRules) : {...this.#rewriteRules}, useValue = value ?? '|'
            delete rewriteRules.eBase        
            for (const [re, p] of Object.entries(rewriteRules)) rewrite.push([new RegExp(re), p])
            if (rewrite.length) for (const [rx, p] of rewrite) { if (useValue.match(rx)) useValue = p; break }
            if (useValue.includes('|')) {
                [closest, selector, useRefresh] = useValue.split('|').map(s => decodeURIComponent(s).trim()), 
                [use, refreshOn] = !useRefresh ? ['$', 'change']
                    : (['!', '$', '_'].includes(useRefresh[0]) ? [ useRefresh[0] , useRefresh.slice(1).trim() || 'change']: ['!' , useRefresh]) 
                this.#scope = closest ? (this.closest(closest) ?? this.getRootNode()) : this.parentElement
                if (!selector) {
                    this.#bind = this.#scope
                } else if (selector.includes('[') && selector.endsWith(']')) {
                    this.#bind = this.#sliceAndStep(selector, Array.from(this.#scope.querySelectorAll(selector)))
                } else { this.#bind = this.#scope.querySelector(selector) }
                if (selector) {
                    const processRecords = records => {
                        const nodesToRemove = [], updatedNodes = [], addedNodes = [], newBind = []
                        for (const record of records) {
                            nodesToRemove.push(...(record?.removedNodes || []))
                            if (record?.target && record.target.matches(selector)) updatedNodes.push(record.target)
                            for (const addedNode of (record?.addedNodes || [])) if (addedNode.matches(selector)) addedNodes.push(addedNode)
                        }
                        for (const node of this.#bind) if (node.isConnected && node.matches(selector) && !nodesToRemove.includes(node)) newBind.push(node)
                        for (const node of updatedNodes) if (node.isConnected && node.matches(selector) && !newBind.includes(node) && !nodesToRemove.includes(node)) newBind.push(node)
                        for (const node of addedNodes) if (node.isConnected && node.matches(selector) && !newBind.includes(node) && node.matches(selector) && !nodesToRemove.includes(node)) newBind.push(node)
                        newBind.sort((a, b) => ((a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) ? -1 : 1) )
                        this.#bind = (selector.includes('[') && selector.endsWith(']')) ? this.#sliceAndStep(selector, newBind) : newBind
                    }
                    if (this.#scopeObserver) processRecords(this.#scopeObserver.takeRecords())
                    this.#scopeObserver && (this.#scopeObserver.disconnect())
                    this.#scopeObserver = new MutationObserver(processRecords)
                    this.#scopeObserver.observe(this.#scope, {subtree: true, childList: true, attributes: true, attributeOldValue: true})
                }
                if (refreshOn) {
                    if (this.#bindController) this.#bindController.abort()
                    const stepRefresh = refreshOn.includes('[') && refreshOn.endsWith(']') 
                    let [start=0, end=1, step=0] = refreshOn.split('[').pop().slice(0, -1).split(':').map(s => (parseInt(s) || 0))
                    const bindNodes = Array.isArray(this.#bind) ? this.#bind : [this.#bind]
                    for (const eventName of refreshOn.split(',').map(s => s.trim())) {
                        for (const node of bindNodes) {
                            node.addEventListener(eventName, event => {
                                const proceed = true
                                if (stepRefresh) proceed = (this.#refreshCount >= start) && (this.#refreshCount < end)
                                this.#refreshCount = this.#refreshCount + 1
                                if (proceed && stepRefresh && step) proceed = !!((step === 1) ? (this.#refreshCount % 2) : (this.#refreshCount % step === 0))
                                if (use === '!') { 
                                    this._refresh(event) 
                                } else if (use === '_') {
                                    this._refresh(this.#bind)
                                } else if (Array.isArray(this.#bind)) {                                    
                                    this._refresh(this.#bind.map(node => this.e.getValue(node)))
                                } else { this._refresh(this.e.getValue(node)) }
                            }, {signal: this.#bindController.signal})
                        }
                    }
                }
            } else {
                let url = this.#resolveUrl(useValue)
                if (url.startsWith('wss://') || url.includes('!')) {
                    let eventSource, eventPayloadList = ['message']
                    if (url.startsWith('wss://')) {
                        eventSource = new WebSocket(url)
                    } else {
                        const [sourceUrl, eventList] = this.e.utils.splitOnce(url, '!').map(s => s.trim())
                        eventSource = new EventSource(sourceUrl)
                        if (eventList) eventPayloadList = eventList.split(',')
                    }
                    if (eventSource) {
                        eventSource.addEventListener('open', event => {
                            if (this.#bindController) this.#bindController.abort()
                            this.#bind = eventSource
                            this.#bindController = new AbortController()
                            for (const eventName of eventPayloadList) {
                                eventSource.addEventListener(eventName, event => {
                                    this._refresh(this.#parse(event.data))
                                }, {signal: this.#bindController.signal})
                            }
                        })
                    }
                } else {
                    if (this.#bindController) this.#bindController.abort()
                    this.#bindController = null
                    this.#bind = url
                }
            }
            this.#resource = value
        }
        get resource() { return this.#resource }

        #resolveUrl(useValue) {
            if (useValue.includes(':') && !useValue.includes('://')) {
                let [routerName, routerPointer] = this.e.utils.splitOnce(useValue, ':'), router = this.e.resolveMeta(this, 'e-router', routerName)
                if ((routerPointer.startsWith('/') || routerPointer.startsWith('?') || routerPointer.startsWith('#'))) {
                    const map = {'/': document.location.pathname.slice(1), '#': document.location.hash.slice(1), '?': document.location.search.slice(1)}
                    if (routerPointer[0] === '?' && (routerPointer === '[') && (routerPointer.slice(-1) === ']')) {
                        routerPointer = (new URLSearchParams(map[routerPointer[0]])).get(routerPointer.slice(2, -1))
                    } else {
                        if (routerPointer === routerPointer[0]) {
                            routerPointer = map[routerPointer[0]]
                        } else {
                            try {
                                routerPointer = map[routerPointer[0]].match(new RegExp(routerPointer.slice(1)))[0]
                            } catch(e) { routerPointer = undefined }
                        }
                    }
                }
                return router ? router[this.#mode](routerPointer) : this.e.getURL(new URL(`${this.#mode}/${routerPointer || this.e.env.modes[this.#mode].pointer}.${this.e.env.modes[this.#mode].suffix}`, this.baseURI).href)
            } else if (useValue.includes('/')) {
                return this.e.getURL(new URL(useValue, this.baseURI).href) 
            } else { return this.e.getURL(new URL(`${this.#mode}/${useValue}.${this.e.env.modes[this.#mode].suffix}`, this.baseURI).href) }
        }

        get bind() { return this.#bind }        

        set match(value) { 
            this.#match = value
            if (!value) {
                this.#scope = undefined
                this.#selector = undefined
                return
            }
            if (!value.includes('|')) {
                this.#scope = undefined
                this.#selector = value
                return
            }
            [this.#scope, this.#selector] = this.e.utils.splitOnce(value, '|').map(s => s.trim())
        }
        get match() { return this.#match }

        set transform(value) { this.#transform = value }
        get transform() { return this.#transform }

        set apply(value) { this.#apply = value }
        get apply() { return this.#apply }

        set rewrite(value) {
            this.#rewriteRules = this.e.utils.parseObjectAttribute(value) ?? {}
            this.#rewrite = value
        }
        get rewrite() { return this.#rewrite }

        set errors(value) { this.#errors = value }
        get errors() { return this.#errors ?? this.e.env.options.errors }

        set processor(value) { this.#processor = this.e.utils.resolveMeta(this, 'e-processor', value) }
        get processor() { return this.#processor }

        set ['fetch-options'](value) {
            this.#fetchOptions = this.e.utils.parseObjectAttribute(value)
            this.#fetchOptionsString = value
        }
        get ['fetch-options']() { return this.#fetchOptionsString }

    }
</script>