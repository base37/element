<style></style>
<template></template>
<script>
    class extends `meta` {

        #resource
        #target
        #transform
        #apply
        #errors
        #rewrite
        #rewriteRules = []
        #boundResource
        #boundResourceController
        #boundTarget
        #boundTargetController
        #boundResourceObserver
        #boundTargetObserver
        #boundResourceRefreshCount = 0
        #boundTargetRefreshCount = 0
        #options = ''
        #optionsMap = {}
        #use

    	constructor() {
    		super()
            Object.defineProperties(this, {
                _mode: {configurable: true, enumerable: false, value: 'pointer'}, 
                _contentType: {configurable: true, enumerable: false, value: undefined}, 
                _isReference: {configurable: true, enumerable: false, value: false}, 
                _apply: {configurable: true, enumerable: false, value: async (result, target) => {
                        target = Array.isArray(target) ? target : [target]
                        for (const t of target) this.e.setValue(t, result)
                    }
                }
            })
    	}

		static get observedAttributes() { return (super.observedAttributes || []).concat('resource', 'target', 'apply', 'transform', 'rewrite', 'errors',
            'options') }

        async connectedCallback() {}

        toString() { return this.resource ?? '' }

        #sliceAndStep(sig, list) {
            let [start=0, end=list.length, step=0] = sig.split(':').map(s => (parseInt(s) || 0))
            if (end === 0) end = list.length
            list = list.slice(start, end)
            if (!step) return list
            return (step === 1) ? list.filter((v, i) => (i+1) % 2) : list.filter((v, i) => (i+1) % step === 0)            
        }

        #resolveUrl(useValue) {
            if (useValue.includes(':') && !useValue.includes('://')) {
                let [routerName, routerPointer] = this.e.utils.splitOnce(useValue, ':'), router = this.e.utils.resolveMeta(this, 'e-router', routerName)
                if ((routerPointer.startsWith('/') || routerPointer.startsWith('?') || routerPointer.startsWith('#'))) {
                    const map = {'/': document.location.pathname.slice(1), '#': document.location.hash.slice(1), '?': document.location.search.slice(1)}
                    if (routerPointer[0] === '?' && (routerPointer === '[') && (routerPointer.slice(-1) === ']')) {
                        routerPointer = (new URLSearchParams(map[routerPointer[0]])).get(routerPointer.slice(2, -1))
                    } else {
                        if (routerPointer === routerPointer[0]) {
                            routerPointer = map[routerPointer[0]]
                        } else {
                            try {
                                routerPointer = map[routerPointer[0]].match(new RegExp(routerPointer.slice(1)))[0]
                            } catch(e) { routerPointer = undefined }
                        }
                    }
                }
                const rewriteRules = this.rewriteRules
                if (routerPointer && rewriteRules.length) for (const [rx, p] of rewriteRules) if ((rx instanceof RegExp) && routerPointer.match(rx)) return this.#resolveUrl(p) 
                return router ? router[this._mode](routerPointer) : this.e.getURL(new URL(`${this._mode}/${routerPointer || this.e.env.modes[this._mode].pointer}.${this.e.env.modes[this._mode].suffix}`, this.baseURI).href)
            } else if (useValue.includes('/')) {
                return this.e.getURL(new URL(useValue, this.baseURI).href) 
            } else { return this.e.getURL(new URL(`${this._mode}/${useValue}.${this.e.env.modes[this._mode].suffix}`, this.baseURI).href) }
        }

        async #refresh(payload) {
            const boundResource = this.boundResource, compileRequestOptions = async v => {
                let optionsMap = this.optionsMap, requestOptions = {...(this.e.env.variables[optionsMap.eEnv] || {}), ...optionsMap}
                if (v instanceof Object) {
                    requestOptions.body = await this.#serialize(v)
                } else if (v) {
                    requestOptions.method ||= 'POST'
                    requestOptions.body = `${v}`
                }
                return requestOptions
            }
            if (!boundResource) return
            let result
            if (!payload && (typeof boundResource === 'string')) {
                let contentType = this.getAttribute('content-type') || this._contentType || undefined
                if (this._isReference && ((contentType === 'application/javascript') || boundResource.endsWith('.mjs') || boundResource.endsWith('.js'))) {
                    result = await import(boundResource)
                } else if (contentType === 'application/schema+json') { 
                    result = boundResource
                } else {
                    const req = fetch(boundResource, compileRequestOptions(payload))
                    if (this._isReference) {
                        if ((contentType === 'application/wasm') || boundResource.endsWith('.wasm')) {
                            result = await WebAssembly.instantiateStreaming(req)
                        } else { result = req.then(r => r.body) }
                    } else {
                        let response = await req
                        if (response.status >= 400) {
                            const rewriteRules = this.rewriteRules
                            if (rewriteRules.length) for (const [rx, p] of rewriteRules) if (rx == response.status) { 
                                response = await fetch(this.#resolveUrl(p), requestOptions)
                                break 
                            } 
                            if (response.status >= 400) {
                                this.dispatchEvent(new CustomEvent('error', {detail: {type: 'refresh', status: response.status, input: response.url, requestOptions}}))
                                if (this.errors === 'throw') { throw new Error(response.text()); return } else if (this.errors === 'hide') { return }
                            }
                        }
                        result = await this.#parse(response)
                    }
                }
            } else { result = payload ?? boundResource }
            let transform = this.transform || this.getAttribute('transform')
            if (transform) {
                if (!this.e.env.libraries.jsonata && !document.querySelector('script[src="https://cdn.jsdelivr.net/npm/jsonata/jsonata.min.js"]')) {
                    const scriptTag = document.createElement('script')
                    scriptTag.setAttribute('src', 'https://cdn.jsdelivr.net/npm/jsonata/jsonata.min.js')
                    document.head.append(scriptTag)
                    await this.e.utils.waitUntil(() => window.jsonata)
                    this.e.env.libraries.jsonata = window.jsonata
                }
                await this.e.utils.waitUntil(() => this.e.env.libraries.jsonata)
                try { 
                    const variables = []
                    if (transform.includes('$env')) variables.push(`$env := ${JSON.stringify(this.e.env, ['eDataset', 'modes', 'options', 'variables'])}`)
                    if (transform.includes('$this')) variables.push(`$this := ${JSON.stringify(this.valueOf())}`)
                    if (variables.length) transform = `( ${variables.join(' ; ')} ; ${transform})`
                    result = await this.e.env.libraries.jsonata(transform).evaluate(result) 
                } catch(e) {
                    this.dispatchEvent(new CustomEvent('error', {detail: {type: 'transform', message: e, input: result}}))
                    if (this.errors === 'throw') { throw new Error(e); return } else if (this.errors === 'hide') { result = {} }
                }
            }
            const boundTarget = this.boundTarget ?? this.parentElement
            if (typeof boundTarget === 'string') {
                fetch(this.#resolveUrl(boundTarget), compileRequestOptions(result))
            } else { this._apply(result, Array.isArray(boundTarget) ? boundTarget : [boundTarget]) }
        }

        async #parse(value) {
            return (typeof this.eParser === 'function') ? (await this.eParser(value)) : (await this.e.parse(value, this))
        }

        async #serialize(value) {
            return (typeof this.eSerializer === 'function') ? (await this.eSerializer(value)) : (await this.e.serialize(value, this))
        }

        #createBound(value, mode) {
            const setBound = v => mode === 'resource' ? (this.#boundResource = v) : (this.#boundTarget = v),
                getBound = () => mode === 'resource' ? this.#boundResource : this.#boundTarget,  
                setBoundController = v => mode === 'resource' ? (this.#boundResourceController = v) : (this.#boundTargetController = v), 
                getBoundController = () => mode === 'resource' ? this.#boundResourceController : this.#boundTargetController,
                setBoundObserver = v => mode === 'resource' ? (this.#boundResourceObserver = v) : (this.#boundTargetObserver = v), 
                getBoundObserver = () => mode === 'resource' ? this.#boundResourceObserver : this.#boundTargetObserver, 
                setCount = v => mode === 'resource' ? (this.#boundResourceRefreshCount = v) : (this.#boundTargetRefreshCount = v), 
                getCount = () => mode === 'resource' ? this.#boundResourceRefreshCount : this.#boundTargetRefreshCount
            let useValue = value ?? '|'
            const useFlags = ['!', '$', '_'], startsWithFlag = useFlags.includes(useValue[0])
            if (useValue.includes('|') || startsWithFlag) {
                let [closest, selector, useRefresh] = startsWithFlag ? ['', '', useValue] : useValue.split('|').map(s => decodeURIComponent(s).trim()), 
                [use, refreshOn] = !useRefresh ? ['$', 'change']
                    : (useFlags.includes(useRefresh[0]) ? [ useRefresh[0] , useRefresh.slice(1).trim() || 'change']: ['!' , useRefresh]) 
                let scope
                if (startsWithFlag) {
                    scope = this
                } else if (useValue.startsWith('|')) {
                    scope = this.parentElement
                } else if (useValue.startsWith(':|') || useValue.startsWith(':root|')) {
                    scope = this.getRootNode()
                } else if (useValue.startsWith(':host|')) {
                    scope = this.getRootNode()
                    if (scope instanceof ShadowRoot) scope = scope.host
                } else if (useValue.startsWith(':document|')) {
                    scope = document
                } else { scope = this.closest(closest) }
                if (!scope) return
                if (mode === 'resource') this.#use = use
                if (!selector) {
                    setBound(scope)
                } else if (selector.includes('{') && selector.endsWith('}')) {
                    let [selectorStem, sig] = selector.split('{')
                    setBound(this.#sliceAndStep(sig.slice(0, -1), Array.from(scope.querySelectorAll(selectorStem))))
                } else { setBound(scope.querySelector(selector)) }
                if (selector) {
                    const processRecords = records => {
                        let [selectorStem,] = selector.split('{')
                        const nodesToRemove = [], updatedNodes = [], addedNodes = [], newBind = []
                        for (const record of records) {
                            nodesToRemove.push(...(record?.removedNodes || []))
                            if (record?.target && record.target.matches(selectorStem)) updatedNodes.push(record.target)
                            for (const addedNode of (record?.addedNodes || [])) if (addedNode?.matches && addedNode.matches(selectorStem)) addedNodes.push(addedNode)
                        }
                        let alreadyBound = getBound()
                        if (!Array.isArray(alreadyBound)) alreadyBound = [alreadyBound]
                        for (const node of alreadyBound) if (node.isConnected && node?.matches && node.matches(selectorStem) && !nodesToRemove.includes(node)) newBind.push(node)
                        for (const node of updatedNodes) if (node.isConnected && node?.matches && node.matches(selectorStem) && !newBind.includes(node) && !nodesToRemove.includes(node)) newBind.push(node)
                        for (const node of addedNodes) if (node.isConnected && node?.matches && node.matches(selectorStem) && !newBind.includes(node) && !nodesToRemove.includes(node)) newBind.push(node)
                        newBind.sort((a, b) => ((a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) ? -1 : 1) )
                        setBound((selector.includes('{') && selector.endsWith('}')) ? this.#sliceAndStep(selector.split('{').pop().slice(0, -1), newBind) : newBind)
                    }
                    let observer = getBoundObserver()
                    if (observer) processRecords(observer.takeRecords())
                    observer && (observer.disconnect())
                    observer = setBoundObserver(new MutationObserver(processRecords))
                    observer.observe(scope, {subtree: true, childList: true, attributes: true, attributeOldValue: true})
                }
                if (refreshOn && (mode === 'resource')) {
                    let boundController = getBoundController()
                    if (boundController) boundController.abort()
                    boundController = setBoundController(new AbortController())
                    const [refreshFrom, refreshStep=''] = refreshOn.split('{')
                    let [start=0, end=0, step=0] = refreshStep.slice(0, -1).split(':').map(s => (parseInt(s) || 0)), bound = getBound()
                    const bindNodes = Array.isArray(bound) ? bound : [bound], eventNames = refreshFrom.split(',').map(s => s.trim())
                    for (let eventName of eventNames) {
                        for (const node of bindNodes) {
                            if ((useRefresh === '!') && (eventNames.length === 1) && eventName==='change' && !node.eDataset && !['input', 'select', 'textarea'].includes(node.tagName.toLowerCase())) {
                                eventName = 'click'
                            }
                            node.addEventListener(eventName, event => {
                                let proceed = true, count = getCount()
                                if (refreshStep) proceed = (count >= start) && (!end || (count < end))
                                setCount(count + 1)
                                count = getCount()
                                if (proceed && refreshStep && step) proceed = !!((step === 1) ? (count % 2) : (count % step === 0))
                                if (!proceed) return
                                if (use === '!') {
                                    this.#refresh(event)
                                } else if (use === '$') {
                                    this.#refresh(bound)
                                } else if (Array.isArray(bound)) {
                                    this.#refresh(bound.map(node => this.e.getValue(node)))
                                } else { this.#refresh(this.e.getValue(node)) }
                            }, {signal: boundController.signal})
                        }
                    }
                }
            } else {
                let url = this.#resolveUrl(useValue), boundController = getBoundController()
                if (boundController) boundController.abort()
                setBound(url)
                if (useValue.includes(':#')) {
                    boundController = setBoundController(new AbortController())
                    window.addEventListener('hashchange', event => {
                        const resource = this.#resource
                        this.#resource = undefined
                        this.resource = resource
                    }, {signal: boundController.signal})
                }
            }
        }

        set resource(value) {
            if (this.#resource === value) return
            this.#createBound(value, 'resource')
            this.#resource = value
            if (!this.#use) {
                this.#refresh()
            } else if (this.#use === '$') {
                this.#refresh(this.#boundResource)
            } else if (this.#use === '_') {
                this.#refresh(Array.isArray(this.#boundResource) ? this.#boundResource.map(n => this.e.getValue(n)) : this.e.getValue(this.#boundResource))
            }
        }
        get resource() { return this.#resource }
        get boundResource() { 
            const resourceAttrVal = this.getAttribute('resource')
            if (resourceAttrVal && !this.#resource) {
                this.#createBound(resourceAttrVal, 'resource')
                this.#resource = resourceAttrVal
            }
            return this.#boundResource 
        }

        set target(value) { 
            if (this.#target === value) return
            this.#createBound(value, 'target')
            this.#target = value
        }
        get target() { return this.#target }
        get boundTarget() { 
            const targetAttrVal = this.getAttribute('target')
            if (targetAttrVal && !this.#target) {
                this.#createBound(targetAttrVal, 'target')
                this.#target = targetAttrVal
            }
            return this.#boundTarget
        }

        set transform(value) { this.#transform = value }
        get transform() { return this.#transform }

        set apply(value) { this.#apply = value }
        get apply() { return this.#apply }

        set rewrite(value) {
            if ((this.getAttribute('rewrite') ?? '') !== (this.#rewrite ?? '')) {
                let value = this.getAttribute('rewrite')
                this.#rewriteRules = []
                let rewriteRulesThis = this.e.utils.parseObjectAttribute(value) ?? {}, 
                rewriteRulesObject = (rewriteRulesThis.eEnv) ? Object.assign({...this.e.env.variables[rewriteRulesThis.eEnv] || {}}, rewriteRulesThis) : rewriteRulesThis
                for (const [re, p] of Object.entries(rewriteRulesObject)) this.#rewriteRules.push([Number.isInteger(Number(re)) ? re : new RegExp(re), p])
            }
            this.#rewrite = value
        }
        get rewrite() { return this.#rewrite }
        get rewriteRules() { 
            const attrRewrite = this.getAttribute('rewrite')
            if (attrRewrite && attrRewrite!== this.#rewrite) this.rewrite = attrRewrite
            return this.#rewriteRules
        }

        set options(value) {
            this.#optionsMap = this.e.utils.parseObjectAttribute(value)
            this.#options = value
        }
        get options() { return this.#options }
        get optionsMap() { 
            const attrOptions = this.getAttribute('options')
            if (attrOptions && attrOptions!== this.#options) this.options = attrOptions
            return this.#optionsMap 
        }

        set errors(value) { this.#errors = value }
        get errors() { return this.#errors ?? this.e.env.options.errors }

    }
</script>