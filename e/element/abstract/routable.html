<style></style>
<template><slot></slot></template>
<script>
    class extends `meta` {

        #mode
        #router
        #pointer

        #scope
        #match
        #as

        #errors

    	constructor() {
    		super()
            Object.defineProperties(this, {
                _mode: {configurable: true, enumerable: false, set: value => this.#mode = value, get: () => this.#mode}, 
                _router: {get: () => this.#router}, 
                _pointer: {get: () => this.#pointer}, 
                _rawResponse: {get: async () => {
                    let resource = this.resource
                    return resource ? await fetch(this.e.getURL(new URL(resource, this.baseURI).href)) : new Response('null', {status: 599})
                }},
                _parse: {configurable: true, writable: true, value: async (response) => {
                    switch(this._mode) {
                    case 'processor':
                    case 'schema':
                        return response
                    default: 
                        return await response.text()
                    }
                }},
                _useResponse: {configurable: false, get: async () => {
                        if (this._mode === 'processor') return await this._parse(`${this}`)
                        if (this._mode === 'schema') return await this._parse(`${this}`)
                        return await this._parse(await this._rawResponse)
                }}, 
                _activate: {value: async () => {
                    const scopeElement = this.#match ? ((this.#scope ? this.closest(this.#scope) : this.getRootNode()) ?? this.getRootNode()) : this.parentElement, recordLoadEnd = () => {
                        window.requestAnimationFrame(() => {
                            this.dispatchEvent(new CustomEvent('loadended'))
                            delete this.e.env.routableLoadingRegistry[this]
                            if (!Object.keys(this.e.env.routableLoadingRegistry).length) this.e.env.eDataset.dispatchEvent(new CustomEvent('loadended'))
                        })                        
                    }
                    if (!this.#match) return await this._as(await this._useResponse, 'add', scopeElement, scopeElement.previousElementSibling, scopeElement.nextElementSibling, {}).then(() => recordLoadEnd())
                    const processRecords = async recordsToProcess => {
                        const queue = {}
                        for (const record of recordsToProcess) {
                            if (record.type === 'childList') {
                                for (const addedNode of record.addedNodes) if (typeof addedNode.matches === 'function' && addedNode.matches(this.#match||':scope')) queue[addedNode] = ['add', addedNode, record.previousSibling, record.nextSibling]
                                for (const removedNode of record.removedNodes) if (typeof removedNode.matches === 'function' && removedNode.matches(this.#match||':scope')) queue[removedNode] = ['remove', removedNode, record.previousSibling, record.nextSibling]
                            }
                        }
                        const queueValues = Object.values(queue)
                        if (queueValues.length) {
                            const useResponse = await this._useResponse
                            for (const queueValue of queueValues) this._as(useResponse, ...queueValue)
                        }
                    }
                    this.e.createObserver(this, scopeElement, processRecords, processRecords)
                    const useResponse = await this._useResponse, matches = scopeElement.querySelectorAll(this.#match||':scope'), promises = []
                    for (const matched of matches) promises.push(this._as(useResponse, 'add', matched, 
                        matched.previousElementSibling, matched.nextElementSibling, Object.assign({}, 
                            ...matched.getAttributeNames().map(a => ({[a]: matched.getAttribute(a)})))))
                    Promise.all(promises).then(() => recordLoadEnd())
                }},
                _as: {configurable: true, writable: true, value: async (useResponse, addOrRemove, node, previousSibling, nextSibling, oldAttributeValues) => {
                    console.log(useResponse, addRemoveOrUpdate, node, previousSibling, nextSibling, oldAttributeValues)
                }}
            })
            Object.defineProperty(this, '_routable', {configurable: false, writable: false, value: Object.defineProperties({}, { _parse: {value: this._parse.bind(this)} }) })
    	}

		static get observedAttributes() { return (super.observedAttributes || []).concat('router', 'pointer', 'scope', 'match', 'as') }

        async connectedCallback() {
            const parseShortHand = (attributeName) => {
                const split = this.e.utils.splitOnce(attributeName, ':')
                if (split[0]) this.setAttribute('router', split[0])
                if (!this.hasAttribute('match') && split[1].includes('.')) {
                    const matchSplit = this.e.utils.splitOnce(split[1], '.')
                    if (matchSplit[0]) this.setAttribute('pointer', matchSplit[0])
                    if (matchSplit[1]) this.setAttribute('match', matchSplit[1])
                } else if (split[1]) { this.setAttribute('pointer', split[1]) }
                this.removeAttribute(attributeName)
            }, selfObserver = new MutationObserver(events => {
                for (const event of events) {
                    if (event.attributeName.includes(':') && !this.getAttribute(event.attributeName) && !this.hasAttribute('router') && !this.hasAttribute('pointer')) parseShortHand(event.attributeName)
                    this.dispatchEvent(new CustomEvent('change', {detail: event}))
                }
            })
            for (const attribute of this.attributes) if (!attribute.value && attribute.name.includes(':')) parseShortHand(attribute.name)
            selfObserver.observe(this, { attributes: true, attributeOldValue: true })
            if (!Object.keys(this.e.env.routableLoadingRegistry).length) this.e.env.eDataset.dispatchEvent(new CustomEvent('loadstarted'))
            this.e.env.routableLoadingRegistry[this] = true
            this.dispatchEvent(new CustomEvent('loadstarted'))
            await this._activate()
        }

        toString() { return this.resource ?? '' }

        get resource() {
            if (this.#pointer) {
                if (this.#pointer.startsWith('/') || this.#pointer.startsWith('./') || this.#pointer.startsWith('../') || this.#pointer.includes('://')) {
                    return this.#pointer
                } else if (this.#router) {
                    return this.#router[this._mode](this.#pointer)
                } else { return }
            } else { return this.#router ? this.#router[this._mode]() : undefined }
        }

        set router(value) { this.#router = this.e.resolveMeta(this, 'e-router', value) }
        get router() { return this.#router }

        set pointer(value) {
            if (!value) {
                this.#pointer = this.e.env.modes[this.#mode].pointer
            } else if (value.startsWith('/') || value.startsWith('./') || value.startsWith('../') || value.includes('://')) {
                this.#pointer = value
            } else {
                let flag, flagMap = {'/': document.location.pathname, '#': document.location.hash, '?': document.location.search}
                if (Object.keys(flagMap).includes(value[0])) {
                    flag = value[0]
                    if (flag === '?' && (value[1] === '[') && (value.slice(-1) === ']')) {
                        this.#pointer = (new URLSearchParams(flagMap[flag])).get(value.slice(2, -1))
                    } else { 
                        this.#pointer = (flagMap[flag].match(new RegExp(value.slice(1))) ?? [])[0] 
                    }
                }
            }
        }
        get pointer() { return this.#pointer }

        set scope(value) { this.#scope = value }
        get scope() { return this.#scope }

        set match(value) { this.#match = value }
        get match() { return this.#match }

        set as(value) { this.#as = value }
        get as() { return this.#as }

        set errors(value) { this.#errors = value }
        get errors() { return this.#errors }

    }
</script>