<style></style>
<template></template>
<script>
    export default class extends `./map` {

        #isRouter
        #routes = {
            '#': v => v ? document.location.hash = v : document.location.hash.slice(1),
            '?': v => v ? document.location.search = v : document.location.search.slice(1),
            '/': v => v ? document.location.pathname = v : document.location.pathname.slice(1)
        }


        static portType = 'DOM'

        constructor() {
            super()
            Object.defineProperty(this, '_getPort', {
                value: (portExpression) => this.#getPort(portExpression)
            })
            Object.defineProperty(this, '_applyFromCells', {
                value: (value, cell, countLabel, counter, event, selector, scope) => this.#applyFromCells(value, cell, countLabel, counter, event, selector, scope)
            })
        }

        #getPort(portExpression) {
            if (!portExpression || (typeof portExpression !== 'string')) return
            const direction = this.direction, cells = this.cells
            if ((direction !== 'toCell') && (direction !== 'fromCell')) return
            if (!cells) return
            let useDefaultEvents, selector, scope, eventNames = [], routeHandler = this.#routes[portExpression]
            if (portExpression === ':' || (typeof routeHandler === 'function')) {
                this.#isRouter = true
                scope = this.E.env.router
                selector = portExpression
                eventNames = ['change']
            } else {
                if (portExpression[0] === '#') portExpression = `:document|${portExpression}`
                let [scopeExpression, selectorEvents] = portExpression.split(/\|(?!\=)/g).map(s => s.trim())
                scope = this.E.utils.resolveScope(scopeExpression, this)
                if (!scope) return
                let selectorEventsLastIndexOf = selectorEvents.lastIndexOf('!')
                useDefaultEvents = true
                if (selectorEventsLastIndexOf === -1) {
                    selector = selectorEvents
                } else {
                    selector = selectorEvents.slice(0, selectorEventsLastIndexOf)
                    eventNames = selectorEvents.slice(selectorEventsLastIndexOf + 1).split(',').map(s => s.trim()).filter(s => !!s)
                    useDefaultEvents = !eventNames.length
                }
            }
            if (this.direction === 'toCell') {
                if (useDefaultEvents) eventNames = Array.from(new Set(Object.values(this.E.env.options.defaultEventTypes).concat(['click'])))
                for (const eventName of eventNames) {
                    scope.addEventListener(eventName, async event => {
                        if (this.#isRouter) { this._applyToCells(routeHandler ? routeHandler() : this.E.flatten(scope), event); return }
                        if (selector && !event.target.matches(selector)) return
                        if (useDefaultEvents && (event.type !== (this.E.env.options.defaultEventTypes[event.target.tagName.toLowerCase()] ?? 'click'))) return
                        if (!this.allow) event.preventDefault()
                        const value = this.E.flatten(event.target)
                        this._applyToCells([value], event)
                    }, { signal: this._abortController.signal })
                }
                this.touch = () => {
                    if (!scope) return
                    if (this.#isRouter) { this._applyToCells(routeHandler ? routeHandler() : this.E.flatten(scope)); return }
                    this._applyToCells(this.E.flatten(selector ? scope.querySelectorAll(selector) : [scope]))
                }
            }
            return [scope, [selector, scope]]
        }

        #applyFromCells(value, cell, countLabel, counter, event, selector, scope) {
            if (this.#isRouter) {
                this.E.runTransform(this.transform, value, this, { cell: { value, name: cell.name, [countLabel]: counter }, event: this.E.flatten(event), target: selector, router: this.E.flatten(scope) })
                    .then(data => {
                        if (data == undefined) return
                        if (this.#routes[selector]) {
                            this.#routes[selector](data)
                        } else if (data instanceof Object) {
                            for (let [routerProperty, routerArg] of Object.entries(data)) {
                                if (routerProperty.includes('(')) routerProperty = routerProperty.split('(')[0]
                                if (typeof this.E.env.router[routerProperty] === 'function') {
                                    this.E.env.router[routerProperty](routerArg)
                                } else {
                                    this.E.env.router[routerProperty] = routerArg
                                }
                            }
                        }
                    })
                return
            }
            let targets = this.E.utils.resolveSelector(selector, scope)
            const transform = this.transform,
                seek = (transform.includes('$seek(')) ? ((t, qs) => qs ? this.E.flatten(this.E.utils.resolveScopedSelector(qs, t) ?? {}) : this.E.flatten(t)) : undefined
            if (!Array.isArray(targets)) targets = [targets]
            for (const target of targets) this.E.runTransform(transform, value, this, { cell: { value, name: cell.name, [countLabel]: counter }, event: this.E.flatten(event), seek: seek ? seek.bind(this, target) : undefined, target: this.E.flatten(target) })
                .then(data => this.E.applyData(target, data))
        }

    }
</script>