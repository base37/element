<style></style>
<template></template>
<script>
    export default class extends `./map` {

        #options

        static portType = 'Remote'

        constructor() {
            super()
            Object.defineProperty(this, '_getPort', {
                value: portExpression => this.#getPort(portExpression, signal)
            })
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('options') }

        get options() { return this.E.utils.safeGet(this, this.#options, 'options') }
        set options(value) { this.#options = value }

        #getPort(portExpression, signal) {
            if (!portExpression || (typeof portExpression !== 'string') || !(signal instanceof AbortSignal)) return
            const direction = this.direction, cells = this.cells
            if (!cells) return
            const [urlExpression, eventsExpression] = portExpression.split('!').map(s => s.trim()), remoteUrl = this.E.resolveUrl(urlExpression)
            if (!remoteUrl) return
            this.E.env.ports[remoteUrl] ||= {}
            let handler, name = remoteUrl, singleton
            if (remoteUrl.startsWith('ws://') || remoteUrl.startsWith('wss://')) {
                if (!this.E.env.ports[remoteUrl].singleton) {
                    let options = this.options ?? {}
                    if (typeof options === 'string') options = this.E.resolveVariables('${' + options + '}')
                    if (!(options instanceof Object)) return
                    singleton = new WebSocket(remoteUrl, options.protocols)
                    if (options.binaryType) singleton.binaryType = options.binaryType
                }
                if (direction === 'fromCell') {
                    handler = (value, port, proxyMapElement, init) => {
                        // need to handle closed sockets...
                        this.E.serialize(value, this).then(serializedValue => port.singleton.send(serializedValue))
                    }
                } else if (direction === 'toCell') {
                    // need to handle closed sockets...
                    port.singleton.addEventListener('message', event => {
                        this.E.parse(event.data, this).then(parsedValue => this.E.saveToCell(parsedValue))
                    }, signal)
                } else { return }
            }
            if (!remoteUrl.startsWith('https://') && !remoteUrl.startsWith('http://')) return
            if (portExpression.startsWith('wt://')) {

            } else if ((direction === 'toCell') && portExpression.startsWith('sse://')) {
                if (!this.E.env.ports[remoteUrl].singleton) {
                    let options = this.options ?? {}
                    if (typeof options === 'string') options = this.E.resolveVariables('${' + options + '}')
                    if (!(options instanceof Object)) return
                    singleton = new EventSource(remoteUrl, options.withCredentials)
                }
                if (eventsExpression) {
                    for (const eventName of eventsExpression.split(',').map(s => s.trim()).filter(s => !!s)) {
                        port.singleton.addEventListener(eventName, event => {
                            this.E.parse(event.data, this).then(parsedValue => this.E.saveToCell(parsedValue, eventName))
                        }, signal)
                    }
                }
                port.singleton.addEventListener('message', event => {
                    this.E.parse(event.data, this).then(parsedValue => this.E.saveToCell(parsedValue, 'message'))
                }, signal)
            } else {
                return
            }

            if (!name || (typeof handler !== 'function')) return
            this.E.env.ports[name] ||= {}
            this.E.env.ports[name].type = this.constructor.portType
            this.E.env.ports[name].singleton = singleton
            this.E.env.ports[name][direction] = { handler, name, direction }
            return this.E.env.ports[name]

        }

    }
</script>