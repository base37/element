<style></style>
<template></template>
<script>
    class extends `meta` {

        static {
            #peers = {}
        }

        #db
        #dbName
        #module
        #query
        #storeName

        #types = {}
        #sets = []
        #ledger = {}
        #schedule = {}
        #peer
        #peers = []
        #abortController

        #_hash = async value => {
            this.e.env.libraries.multiformats ||= await import('https://cdn.jsdelivr.net/npm/multiformats@12.1.2/+esm')
            this.e.env.libraries.multiformatsCodecsJson ||= await import('https://cdn.jsdelivr.net/npm/multiformats@12.1.2/src/codecs/json.min.js')
            this.e.env.libraries.multiformatsHashesSha2 ||= await import('https://cdn.jsdelivr.net/npm/multiformats@12.1.2/src/hashes/sha2-browser.js')
            this.e.env.libraries.multiformats.CID()
            const bytes = this.e.env.libraries.multiformatsCodecsJson.encode(value), 
                hash = await this.e.env.libraries.multiformatsHashesSha2.sha256.digest(bytes), 
                cid = this.e.env.libraries.multiformats.CID.create(1, this.e.env.libraries.multiformatsCodecsJson.code, hash)
            return cid.toString()
        }

        #_db_r2p(req) {
            return new Promise((resolve, reject) => {
                req.onabort = req.onerror = () => reject(req.error)
                req.oncomplete = req.onsuccess = () => resolve(req.result)
            })
        }
        #_db_gs() {
            const req = indexedDB.open(this.dbName)
            req.onupgradeneeded = () => req.result.createObjectStore(this.storeName)
            const dbp = this.#_db_r2p(req)
            return (mode, cb) => dbp.then(db => cb(db.transaction(this.storeName, mode).objectStore(this.storeName)))
        }
        #_db_get(key) {
            return Array.isArray(key) ? this.#_db_gs('readonly', store => Promise.all(key.map((k) => this.#_db_r2p(store.get(k)))))
                : this.#_db_gs('readonly', store => this.#_db_r2p(store.get(key)))
        }
        #_db_set(map, value) {
            if (map instanceof Object) {
                return this.#_db_gs('readwrite', store => {
                    for (const ent of Object.entries(map)) store.put(ent[1], ent[0])
                    return this.#_db_r2p(store.transaction)
                })
            } else if (typeof map === 'string') {
                return this.#_db_gs('readwrite', store => {
                    store.put(value, map)
                    return this.#_db_r2p(store.transaction)
                })
            }
        }
        #_db_update(key, updater) {
            return this.#_db_gs('readwrite', store => 
            new Promise((resolve, reject) => {
                store.get(key).onsuccess = () => {
                    try {
                        store.put(updater(this.result), key)
                        resolve(this.#_db_r2p(store.transaction))
                    } catch (e) { reject(e) }
                }
            }))
        }
        #_db_del(key) {
            if (Array.isArray(key)) {
                return this.#_db_gs('readwrite', store => {
                    for (const k of key) store.delete(k)
                    return this.#_db_r2p(store.transaction)
                })
            } else {
                return this.#_db_gs('readwrite', store => {
                    store.delete(key)
                    return this.#_db_r2p(store.transaction)
                })
            }
        }
        #_db_clear() {
            return this.#_db_gs('readwrite', store => {
                store.clear()
                return this.#_db_r2p(store.transaction)
            })
        }
        #_db_keys() { return this.#_db_gs('readonly', store => this.#_db_r2p(store.getAllKeys())) }
        #_db_values() { return this.#_db_gs('readonly', store => this.#_db_r2p(store.getAll())) }
        #_db_entries() {
            return this.#_db_gs('readonly', store => Promise.all([
                    this.#_db_r2p(store.getAll()),
                    this.#_db_r2p(store.getAllKeys()),
                ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]))
            )
        }

        #hash = async value => {
            const hasher = (this.e.env.map.get(this) ?? {}).hasher ?? this.#module.hasher ?? this.#_hash
            return await hasher(value)
        }

        constructor() {
            super()
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('db', 'query', 'content-type') }

        async connectedCallback() {
            window.setTimeout(() => {
                window.setInterval(() => {
                    const r = () => this.dispatchEvent(new CustomEvent('clock', {detail: `clock-${Math.floor(Date.now()/1000)}`}))
                    window.requestIdleCallback ? window.requestIdleCallback(r) : r()
                }, 1000)
            }, (Date.now()/1000%1)*1000)
            this.addEventListener('clock', event => {
                const r = () => this.send(this.#schedule[event.detail])
                window.requestIdleCallback ? window.requestIdleCallback(r) : r()                
            })

        }        

        async receive(packet) {
            if (!packet || !Array.isArray(packet) || !packet.every(item => (Array.isArray(item) && item.length ===3))) return
            let itemsToSave = [], itemsToSend = []
            for (const item of packet) {
                const [metadata, record, attachments]
                if (!item.every(i => (i instanceof Object))) continue
                if (!metadata.type || !this.#types[metadata.type] || !Object.keys(record).length) continue
                if (!(await this.#types[metadata.type].validate(record))) continue
                metadata.hash = await this.#hash(record), receiveCount = parseInt(this.#ledger[metadata.hash] ?? 0) || 0
                if (receiveCount) {
                    const sendAt = `clock-${Math.ceil((Date.now()/1000)+receiveCount)}`
                    this.#schedule[sendAt] ||= []
                    this.#schedule[sendAt].push(item)
                } else { itemsToSend.push(item) }
                this.#ledger[metadata.hash] = receiveCount + 1
            }
            this.send(itemsToSend)
            for (const set of this.#sets) { 
                for (const item of itemsToSend) {
                    const t = `$boolean(${this.e.expandTransform(set[2], this)})`, belongs = await this.env.libraries.jsonata(t).evaluate(record)
                    if (belongs) {
                        metadata.sets ||= []
                        metadata.sets.push(set[1])
                    }
                }
                if (metadata.sets.length) itemsToSave.push(item)                
            }
            if (itemsToSave.length) {
                const toSave = Object.fromEntries(itemsToSave.map(t => [t[0].hash, t[1]]))
                this.#_db_set(toSave)
                this.dispatchEvent(new CustomEvent('change', {detail: itemsToSave.map(t => t[1])}))                
            }
        }

        send(packet) {
            if (!packet || !Array.isArray(packet) || !packet.length) return
            for (const peer of this.constructor.#peers[this.#dbName]) peer.send(packet)
        }

        save(record) {
            if (!record || !(record instanceof Object) || Array.isArray(record) || !Object.keys(record).length) return
            const toSave = {[(await this.#hash(record))]: record}
            this.#_db_set(toSave)
            this.dispatchEvent(new CustomEvent('change', {detail: [record]}))
        }

        set db(value) {
            this.#db = value
            const dbUrl = this.e.resolveUrl(value)
            this.#dbName = await this.#hash(dbUrl)
            this.#module = await import(manifestUrl)
            if (this.##abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            this.constructor.#peers[this.#dbName] ||= []
            if (!this.constructor.#peers[this.#dbName].length) {
                for (const uri of (this.#module.peers ?? [])) {
                    let [protocol, id] = uri.includes('://') ? uri.split('://') : ['peer', uri]
                    const peerObj = {uri, protocol, id}
                    if (protocol === 'https' || protocol === 'http') {
                        peerObj.send = async (value) => peerObj.receive(await fetch(`${protocol}://${id}`, 
                            {method: 'POST', body: this.e.serialize(value, this)}))
                    } else if (protocol === 'sse') {
                        peerObj.events = ['message']
                        if (id.includes('!')) {
                            const idSplit = id.split('!').map(s => s.trim())
                            id = idSplit[0]
                            peerObj.events = idSplit[1].split(',').map(s => s.trim())
                        }
                        peerObj.eventSource = new EventSource(`https://${id}`)
                        peerObj.send = async (value) => await this.e.parse(await fetch(`${protocol}://${id}`, 
                            {method: 'POST', body: (await this.e.serialize(value, this))}), this)
                    } else if (protocol === 'wss') {
                        peerObj.webSocket = new WebSocket(`wss://${id}`)
                        peerObj.send = async (value) => peerObj.webSocket.send(await this.e.serialize(value, this))

                    } else {
                        this.e.env.libraries.peerjs ||= await import('https://cdn.jsdelivr.net/npm/peerjs@1.5.1/+esm')
                        peerObj.peer ||= new this.e.env.libraries.peerjs.Peer()
                        peerObj.connection = peerObj.connect(id)
                        peerObj.send = async value => peerObj.connection.send(await this.e.serialize(value, this))

                    }
                    this.constructor.#peers[this.#dbName].push(peerObj)
                }
            }
            for (const peerObj of this.constructor.#peers[this.#dbName]) {
                if (peerObj.protocol === 'https' || peerObj.protocol === 'http') {
                    peerObj.receive = response => this.receive(await this.e.parse(response, this))
                } else if (peerObj.protocol === 'sse') {
                    for (eventName of peerObj.events) {
                        peerObj.eventSource.addEventListener(eventName, event => {
                            this.receive(await this.e.parse(event.data, this))
                        })
                    }
                } else if (peerObj.protocol === 'wss') {
                    peerObj.webSocket.addEventListener('message', event => {
                        this.receive(await this.e.parse(event.data, this))
                    })
                } else {
                    peerObj.connection.on('data', async data => this.receive(await this.e.parse(data, this)))
                }
            }
        }
        get db() { 
            const attrDb = this.getAttribute('db')
            if (this.#db !== attrDb) this.db = attrDb
            return this.#db
        }
        get dbName() {
            const attrDb = this.getAttribute('db')
            if (this.#db !== attrDb) this.db = attrDb
            return this.#dbName            
        }

        get module() { return this.#module }

        set query(value) {
            this.#query = value
            this.#storeName = await this.#hash(value)
        }
        get query() { 
            const attrQuery = this.getAttribute('query')
            if (this.#query !== attrQuery) this.query = attrQuery
            return this.#query 
        }
        get storeName() {
            const attrQuery = this.getAttribute('query')
            if (this.#query !== attrQuery) this.query = attrQuery
            return this.#storeName
        }

        get value() { return this.#_db_values() }


    }
</script>