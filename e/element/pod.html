<style></style>
<template></template>
<script>
    class extends `meta` {

        static #peers = {}
        static #ledger = {}
        static #receiveQueue = {}
        static #sendQueue = {}
        static #queryMap = {}

        #db
        #dbName
        #module
        #query
        #storeName

        #types = {}
        #sets = []
        #schedule = {}
        #abortController

        #_hash = async value => {
            this.e.env.libraries.multiformats ||= await import('https://cdn.jsdelivr.net/npm/multiformats@12.1.2/+esm')
            this.e.env.libraries.multiformatsCodecsJson ||= await import('https://cdn.jsdelivr.net/npm/multiformats@12.1.2/src/codecs/json.min.js')
            this.e.env.libraries.multiformatsHashesSha2 ||= await import('https://cdn.jsdelivr.net/npm/multiformats@12.1.2/src/hashes/sha2-browser.js')
            this.e.env.libraries.multiformats.CID()
            const bytes = this.e.env.libraries.multiformatsCodecsJson.encode(value), 
                hash = await this.e.env.libraries.multiformatsHashesSha2.sha256.digest(bytes), 
                cid = this.e.env.libraries.multiformats.CID.create(1, this.e.env.libraries.multiformatsCodecsJson.code, hash)
            return cid.toString()
        }

        #_db_r2p(req) {
            return new Promise((resolve, reject) => {
                req.onabort = req.onerror = () => reject(req.error)
                req.oncomplete = req.onsuccess = () => resolve(req.result)
            })
        }
        #_db_gs() {
            const req = indexedDB.open(this.dbName)
            req.onupgradeneeded = () => req.result.createObjectStore(this.storeName)
            const dbp = this.#_db_r2p(req)
            return (mode, cb) => dbp.then(db => cb(db.transaction(this.storeName, mode).objectStore(this.storeName)))
        }
        #_db_get(key) {
            return Array.isArray(key) ? this.#_db_gs('readonly', store => Promise.all(key.map((k) => this.#_db_r2p(store.get(k)))))
                : this.#_db_gs('readonly', store => this.#_db_r2p(store.get(key)))
        }
        #_db_set(map, value) {
            if (map instanceof Object) {
                return this.#_db_gs('readwrite', store => {
                    for (const ent of Object.entries(map)) store.put(ent[1], ent[0])
                    return this.#_db_r2p(store.transaction)
                })
            } else if (typeof map === 'string') {
                return this.#_db_gs('readwrite', store => {
                    store.put(value, map)
                    return this.#_db_r2p(store.transaction)
                })
            }
        }
        #_db_update(key, updater) {
            return this.#_db_gs('readwrite', store => 
            new Promise((resolve, reject) => {
                store.get(key).onsuccess = () => {
                    try {
                        store.put(updater(this.result), key)
                        resolve(this.#_db_r2p(store.transaction))
                    } catch (e) { reject(e) }
                }
            }))
        }
        #_db_del(key) {
            if (Array.isArray(key)) {
                return this.#_db_gs('readwrite', store => {
                    for (const k of key) store.delete(k)
                    return this.#_db_r2p(store.transaction)
                })
            } else {
                return this.#_db_gs('readwrite', store => {
                    store.delete(key)
                    return this.#_db_r2p(store.transaction)
                })
            }
        }
        #_db_clear() {
            return this.#_db_gs('readwrite', store => {
                store.clear()
                return this.#_db_r2p(store.transaction)
            })
        }
        #_db_keys() { return this.#_db_gs('readonly', store => this.#_db_r2p(store.getAllKeys())) }
        #_db_values() { return this.#_db_gs('readonly', store => this.#_db_r2p(store.getAll())) }
        #_db_entries() {
            return this.#_db_gs('readonly', store => Promise.all([
                    this.#_db_r2p(store.getAll()),
                    this.#_db_r2p(store.getAllKeys()),
                ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]))
            )
        }

        #hash = async value => {
            const hasher = (this.e.env.map.get(this) ?? {}).hasher ?? this.#module.hasher ?? this.#_hash
            return await hasher(value)
        }

        constructor() {
            super()
            if (!this.constructor.sendQueueProcessor) {
                this.constructor.sendQueueProcessor = true
                window.setTimeout(() => {
                    window.setInterval(() => {
                        const r = () => {
                            const clockIndex = `clock-${Math.floor(Date.now()/1000)}`
                            for (const dbName in this.#sendQueue) {
                                if (this.#sendQueue[dbName][clockIndex]) this.send(this.#sendQueue[dbName][clockIndex], dbName)
                            }
                        }
                        window.requestIdleCallback ? window.requestIdleCallback(r) : r()
                    }, 1000)
                }, (Date.now()/1000%1)*1000)
            }
            if (!this.constructor.receiveQueueProcessor) {
                this.constructor.receiveQueueProcessor = true
                const requestIdleCallback = window.requestIdleCallback ?? (cb, options) => window.setTimeout(cb, options.timeout ?? 1000), 
                    runReceive = async () => { await this.receive(); requestIdleCallback(async () => await runReceive() , {timeout: 1000}) }
                requestIdleCallback(async () => await runReceive() , {timeout: 1000})
            }
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('db', 'query', 'content-type') }

        async connectedCallback() {}

        static async receive() {
            for (const dbName of this.#receiveQueue) {
                let itemsToSave = [], recordsToSend = []
                for (const item of this.#receiveQueue[dbName]) {
                    const [hasher, record] = item
                    if (!hasher || (typeof hasher !== 'function')) continue
                    if (!record || !(record instanceof Object) || Array.isArray(record) || !Object.keys(record).length) continue
                    this.constructor#ledger[dbName] ||= {}
                    const hash = await hasher(record), receiveCount = parseInt(this.constructor#ledger[dbName][hash] ?? 0) || 0
                    if (receiveCount) {
                        const sendAt = `clock-${Math.ceil((Date.now()/1000)+receiveCount)}`
                        this.#sendQueue[dbName][sendAt] ||= []
                        this.#sendQueue[dbName][sendAt].push(record)
                    } else { recordsToSend.push(record) }
                    this.constructor#ledger[dbName][hash] = receiveCount + 1
                    for (const [storeName, query] of Object.entries(this.constructor.#queryMap[this.#dbName])) {
                        const t = `$boolean(${this.e.expandTransform(query, this)})`, belongs = await this.env.libraries.jsonata(t).evaluate(record)
                        if (belongs) itemsToSave.push([hash, record])
                    }
                }
                if (recordsToSend.length) this.send(records, dbName)
                if (itemsToSave.length) {
                    const toSave = Object.fromEntries(itemsToSave)
                    this.#_db_set(toSave), detail = itemsToSave.map(i => i[1])
                    for (const pod of this.#pods[dbName]) pod.dispatchEvent(new CustomEvent('change', {detail}))
                }
            }
        }

        static send(packet, dbName) {
            if (!packet || !Array.isArray(packet) || !packet.length) return
            for (const peer of this.#peers[dbName]) peer.send(packet)
        }

        set db(value) {
            if (value === this.#db) return
            const oldDb = this.#db ? this.#db : null
            this.#db = value
            const dbUrl = this.e.resolveUrl(value)
            this.#dbName = await this.#hash(dbUrl)
            this.#module = await import(manifestUrl)
            this.constructor.#pods[this.#dbName] ||= []
            this.constructor.#pods[this.#dbName].push(this)
            this.constructor#ledger[this.#dbName] ||= {}
            this.constructor#sendQueue[this.#dbName] ||= {}
            this.constructor#queryMap[this.#dbName] ||= {}
            if (oldDb) {
                if (this.#abortController) this.#abortController.abort()
                this.#abortController = new AbortController()
                const oldDbUrl = this.e.resolveUrl(oldDb), oldDbName = await this.#hash(oldDbUrl), 
                    index = (this.constructor.#pods[oldDbName] ?? []).indexOf(this)
                if (index > -1) {
                    this.constructor.#pods[oldDbName].splice(index, 1)
                    if (!this.constructor.#pods[oldDbName].length) {
                        if (this.constructor.#pods[oldDbName]) delete this.constructor.#pods[oldDbName]
                        delete this.constructor#ledger[this.#dbName]
                        delete this.constructor#sendQueue[this.#dbName]
                        delete this.constructor#queryMap[this.#dbName]
                    }
                } 
            }
            const storeName = this.storeName 
            this.constructor.#queryMap[this.#dbName][storeName] = this.query
            this.constructor.#peers[this.#dbName] ||= []
            const getPacket = async response => {
                const packet = await this.e.parse(response, this)
                if (packet && Array.isArray(packet) && packet.every(i => ((i instanceof Object) && !Array.isArray(i)))) {
                    this.constructor.#receiveQueue[this.dbName] ||= []
                    this.constructor.#receiveQueue[this.dbName].push(...packet.map(r => ([this.#hash, r])))
                }
            }
            if (!this.constructor.#peers[this.#dbName].length) {
                for (const uri of (this.#module.peers ?? [])) {
                    let [protocol, id] = uri.includes('://') ? uri.split('://') : ['peer', uri]
                    const peerObj = {uri, protocol, id}
                    if (protocol === 'https' || protocol === 'http') {
                        peerObj.send = async (value) => {
                            getPacket(await fetch(`${protocol}://${id}`, {method: 'POST', body: this.e.serialize(value, this)}))
                        } 
                    } else if (protocol === 'sse') {
                        peerObj.events = ['message']
                        if (id.includes('!')) {
                            const idSplit = id.split('!').map(s => s.trim())
                            id = idSplit[0]
                            peerObj.events = idSplit[1].split(',').map(s => s.trim())
                        }
                        peerObj.eventSource = new EventSource(`https://${id}`)
                        peerObj.send = async (value) => await fetch(`${protocol}://${id}`, {method: 'POST', body: this.e.serialize(value, this)})
                        for (eventName of peerObj.events) peerObj.eventSource.addEventListener(eventName, event => getPacket(event.data))
                    } else if (protocol === 'wss') {
                        peerObj.webSocket = new WebSocket(`wss://${id}`)
                        peerObj.send = async (value) => peerObj.webSocket.send(await this.e.serialize(value, this))
                        peerObj.webSocket.addEventListener('message', event => getPacket(event.data))
                    } else {
                        this.e.env.libraries.peerjs ||= await import('https://cdn.jsdelivr.net/npm/peerjs@1.5.1/+esm')
                        peerObj.peer ||= new this.e.env.libraries.peerjs.Peer()
                        peerObj.connection = peerObj.connect(id)
                        peerObj.send = async value => peerObj.connection.send(await this.e.serialize(value, this))
                        peerObj.connection.on('data', async data => getPacket(data))
                    }
                    this.constructor.#peers[this.#dbName].push(peerObj)
                }
            }
        }
        get db() { 
            const attrDb = this.getAttribute('db')
            if (this.#db !== attrDb) this.db = attrDb
            return this.#db
        }
        get dbName() {
            const attrDb = this.getAttribute('db')
            if (this.#db !== attrDb) this.db = attrDb
            return this.#dbName            
        }

        get module() { return this.#module }

        set query(value) {
            this.#query = value
            this.#storeName = await this.#hash(value)
        }
        get query() { 
            const attrQuery = this.getAttribute('query')
            if (this.#query !== attrQuery) this.query = attrQuery
            return this.#query 
        }
        get storeName() {
            const attrQuery = this.getAttribute('query')
            if (this.#query !== attrQuery) this.query = attrQuery
            return this.#storeName
        }

        get value() { return this.#_db_values() }


    }
</script>