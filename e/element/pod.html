<style></style>
<template></template>
<script>
    class extends `meta` {

        #manifest
        #module
        #types = {}
        #sets = []
        #ledger = {}
        #schedule = {}
        #peer
        #peers = []
        #abortController

        #_hash = async value => {
            this.e.env.libraries.multiformats ||= await import('https://cdn.jsdelivr.net/npm/multiformats@12.1.2/+esm')
            this.e.env.libraries.multiformatsCodecsJson ||= await import('https://cdn.jsdelivr.net/npm/multiformats@12.1.2/src/codecs/json.min.js')
            this.e.env.libraries.multiformatsHashesSha2 ||= await import('https://cdn.jsdelivr.net/npm/multiformats@12.1.2/src/hashes/sha2-browser.js')
            this.e.env.libraries.multiformats.CID()
            const bytes = this.e.env.libraries.multiformatsCodecsJson.encode(value), 
                hash = await this.e.env.libraries.multiformatsHashesSha2.sha256.digest(bytes), 
                cid = this.e.env.libraries.multiformats.CID.create(1, this.e.env.libraries.multiformatsCodecsJson.code, hash)
            return cid.toString()
        }

        #_r2p(req) {
            return new Promise((resolve, reject) => {
                req.onabort = req.onerror = () => reject(req.error)
                req.oncomplete = req.onsuccess = () => resolve(req.result)
            })
        }
        #_gs() { 
            const req = indexedDB.open('ePod')
            req.onupgradeneeded = () => req.result.createObjectStore(this.name)
            const dbp = this.#_r2p(req)
            return (mode, cb) => dbp.then(db => cb(db.transaction(this.name, mode).objectStore(this.name)))
        }
        #_get(key) { 
            return Array.isArray(key) ? this.#_gs('readonly', store => Promise.all(key.map((k) => this.#_r2p(store.get(k)))))
                : this.#_gs('readonly', store => this.#_r2p(store.get(key)))
        }
        #_set(map, value) {
            if (map instanceof Object) {
                return this.#_gs('readwrite', store => {
                    for (const ent of Object.entries(map)) store.put(ent[1], ent[0])
                    return this.#_r2p(store.transaction)
                })
            } else if (typeof map === 'string') {
                return this.#_gs('readwrite', store => {
                    store.put(value, map)
                    return this.#_r2p(store.transaction)
                })
            }
        }
        #_update(key, updater) {
            return this.#_gs('readwrite', store => 
            new Promise((resolve, reject) => {
                store.get(key).onsuccess = () => {
                    try {
                        store.put(updater(this.result), key)
                        resolve(this.#_r2p(store.transaction))
                    } catch (e) { reject(e) }
                }
            }))
        }
        #_del(key) {
            if (Array.isArray(key)) {
                return this.#_gs('readwrite', store => {
                    for (const k of key) store.delete(k)
                    return this.#_r2p(store.transaction)
                })
            } else {
                return this.#_gs('readwrite', store => {
                    store.delete(key)
                    return this.#_r2p(store.transaction)
                })
            }
        }
        #_clear() {
            return this.#_gs('readwrite', store => {
                store.clear()
                return this.#_r2p(store.transaction)
            })
        }
        #_keys() { return this.#_gs('readonly', store => this.#_r2p(store.getAllKeys())) }
        #_values() { return this.#_gs('readonly', store => this.#_r2p(store.getAll())) }
        #_entries() {
            return this.#_gs('readonly', store => Promise.all([
                    this.#_r2p(store.getAll()),
                    this.#_r2p(store.getAllKeys()),
                ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]))
            )
        }

        #hash = async value => {
            const hasher = (this.e.env.map.get(this) ?? {}).hasher ?? this.#module.hasher ?? this.#_hash
            return await hasher(value)
        }

        constructor() {
            super()
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('manifest', 'content-type') }

        async connectedCallback() {
            await this.utils.waitUntil(() => this.env.libraries.libp2p)        
            window.setTimeout(() => {
                window.setInterval(() => {
                    const r = () => this.dispatchEvent(new CustomEvent('clock', {detail: `clock-${Math.floor(Date.now()/1000)}`}))
                    window.requestIdleCallback ? window.requestIdleCallback(r) : r()
                }, 1000)
            }, (Date.now()/1000%1)*1000)
            this.addEventListener('clock', event => {
                const r = () => this.send(this.#schedule[event.detail])
                window.requestIdleCallback ? window.requestIdleCallback(r) : r()                
            })

        }        

        set(query) {
            if (!query) return
            let thisSet
            for (const s of this.#sets) if (s.includes(query)) { thisSet = s; break }
            if (!thisSet) thisSet = this.#sets[this.#sets.push([null, (await this.#hash(query)), query])-1]
        }

        async receive(packet) {
            if (!packet || !Array.isArray(packet) || !packet.every(item => (Array.isArray(item) && item.length ===3))) return
            let itemsToSave = [], itemsToSend = []
            for (const item of packet) {
                const [metadata, record, attachments]
                if (!item.every(i => (i instanceof Object))) continue
                if (!metadata.type || !this.#types[metadata.type] || !Object.keys(record).length) continue
                if (!(await this.#types[metadata.type].validate(record))) continue
                metadata.hash = await this.#hash(record), receiveCount = parseInt(this.#ledger[metadata.hash] ?? 0) || 0
                if (receiveCount) {
                    const sendAt = `clock-${Math.ceil((Date.now()/1000)+receiveCount)}`
                    this.#schedule[sendAt] ||= []
                    this.#schedule[sendAt].push(item)
                } else { itemsToSend.push(item) }
                this.#ledger[metadata.hash] = receiveCount + 1
            }
            this.send(itemsToSend)
            for (const set of this.#sets) { 
                for (const item of itemsToSend) {
                    const t = `$boolean(${this.e.expandTransform(set[2], this)})`, belongs = await this.env.libraries.jsonata(t).evaluate(record)
                    if (belongs) {
                        metadata.sets ||= []
                        metadata.sets.push(set[1])
                    }
                }
                if (metadata.sets.length) itemsToSave.push(item)                
            }
            if (const item of itemsToSave) {
                

            }
        }

        send(record) {
            if (!records || !Array.isArray(records) || !records.length) return
            for (const peer of this.#peers) peer.send(records)
        }

        set manifest(value) {
            this.#manifest = value
            this.#module = await import(this.e.resolveUrl(value))
            if (!this.e.env.libraries.ajv) {
                let ajvOptions = {...this.e.env.options.ajv, ...((this.#module.options?.ajvOptions) ?? {})}
                this.e.env.libraries.ajv = new (await import('https://cdn.jsdelivr.net/npm/ajv@8.12.0/+esm')).default(ajvOptions)
                const addFormats = (await import('https://cdn.jsdelivr.net/npm/ajv-formats/+esm')).default
                addFormats(this.e.env.libraries.ajv)
            }
            for (const [type, url] of this.#module.types) this.#types[type] = { url, validate: this.e.env.libraries.ajv.getSchema(typeSchemaUrl) }
            if (this.##abortController) this.#abortController.abort()
            this.#abortController = new AbortController()
            this.#sets = {}
            for (const [label, query] of Object.entries(this.#module.sets ?? {})) this.#sets[label] = [(await this.#hash(query.trim())), query]
            this.#peers = []
            for (const uri of (this.#module.peers ?? [])) {
                let [protocol, id] = uri.includes('://') ? uri.split('://') : ['peer', uri]
                const peerObj = {uri, protocol, id}
                if (protocol === 'https' || protocol === 'http') {
                    peerObj.send = async (value) => await this.e.parse(await fetch(`${protocol}://${id}`, 
                        {method: 'POST', body: this.e.serialize(value, this)}), this)
                    
                } else if (protocol === 'sse') {
                    peerObj.eventSource = new EventSource(`https://${id}`)
                    peerObj.send = async (value) => await this.e.parse(await fetch(`${protocol}://${id}`, 
                        {method: 'POST', body: (await this.e.serialize(value, this))}), this)

                } else if (protocol === 'wss') {
                    peerObj.webSocket = new WebSocket(`wss://${id}`)
                    peerObj.send = async (value) => peerObj.webSocket.send(await this.e.serialize(value, this))

                } else {
                    this.e.env.libraries.peerjs ||= await import('https://cdn.jsdelivr.net/npm/peerjs@1.5.1/+esm')
                    this.#peer ||= new this.e.env.libraries.peerjs.Peer()
                    peerObj.connection = this.#peer.connect(id)
                    peerObj.send = async (value) => peerObj.connection.send(await this.e.serialize(value, this))

                }
            }



        }
        get manifest() { return this.#manifest }

        get module() { return this.#module }


















    }
</script>