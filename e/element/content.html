<style></style>
<template><slot></slot></template>
<script>
    class extends `./abstract/routable` {

    	constructor() {
    		super()
            Object.defineProperties(this, {
                _mode: {configurable: false, enumerable: false, writable: false, value: 'content'}, 
                _parse: {configurable: false, enumerable: false, writable: false, value: async (response) => {
                    let text = await response.text()
                    if (response.status >= 400) this.dispatchEvent(new CustomEvent('error', {detail: {type: 'load', status: response.status, message: text}}))
                    return text 
                }},
                _as: {configurable: false, enumerable: false, writable: false, value: async (useResponse, addOrRemove, node, previousSibling, nextSibling, oldAttributeValues) => {
                    if (addOrRemove !== 'add') return 
                    let [useContentScope, preProcessor] = (this.as||'').split(';', 2).map(s => s.trim())
                    if (`${useResponse}` == useResponse) useResponse = [useResponse]
                    if (preProcessor) {
                        let preProcessFunction = this.e.resolveMeta(this, 'e-processor', preProcessor)?.func
                        if (preProcessFunction) useResponse = await preProcessFunction(useResponse)
                    }
                    if (useContentScope.startsWith('@')) {
                        node.setAttribute(useContentScope.slice(1), useResponse)
                    } else {
                        const validContentScopes = ['innerHTML', 'innerText', 'textContent', 'value']
                        if (!validContentScopes.includes(useContentScope)) useContentScope = 'innerHTML'
                        useContentScope ||= 'innerHTML'
                        node[useContentScope] = useResponse
                    }
                }}
            })
    	}

		static get observedAttributes() { return (super.observedAttributes || []).concat() }

    }
</script>