<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #apply
        #applyMap
        #boundResource
        #boundResourceController
        #boundResourceEventNames = []
        #boundResourceObserver
        #boundResourceRefreshCount = 0
        #boundTarget
        #boundTargetController
        #boundTargetObserver
        #boundTargetRefreshCount = 0
        #boundTargetUpdated = true
        #cycle = []
        #cycleTracker
        #errors
        #options = ''
        #optionsMap = {}
        #resource
        #rewrite
        #rewriteRules = []
        #target
        #transform
        #targetEvents = []
        #use
        #value

        constructor() {
            super()
            Object.defineProperties(this, {
                _apply: { configurable: true, enumerable: false, value: async (result, target) => { } },
                _contentType: { configurable: true, enumerable: false, value: undefined },
                _isReference: { configurable: true, enumerable: false, value: false },
                _mode: { configurable: true, enumerable: false, value: 'pointer' }
            })
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('apply', 'errors', 'options', 'resource', 'rewrite', 'target', 'transform') }

        async connectedCallback() { }

        toString() { return this.resource ?? '' }

        async parse(value) { return await this.parser(value, this) }

        async serialize(value, contentType) { return await this.serializer(value, this, contentType) }

        get apply() { return this.E.utils.safeGet(this, this.#apply, 'apply') }
        set apply(value) {
            if (this.#apply === value) return
            this.#applyMap = this.E.utils.parseObjectAttribute(value, this)
            this.#apply = value
        }

        get applyMap() {
            const attrApply = this.getAttribute('apply')
            if (attrApply && attrApply !== this.#apply) this.apply = attrApply
            return this.#applyMap
        }

        get boundResource() {
            const resourceAttrVal = this.getAttribute('resource')
            if (resourceAttrVal && !this.#resource) {
                this.#createBound(resourceAttrVal, 'resource')
                this.#resource = resourceAttrVal
            }
            return this.#boundResource
        }

        get boundResourceEventNames() { return this.#boundResourceEventNames }

        get boundTarget() {
            const targetAttrVal = this.getAttribute('target')
            if (targetAttrVal !== !this.#target) this.target = targetAttrVal
            return this.#boundTarget
        }

        get contentType() { return this.E.utils.getContentType(this) }

        get cycle() { return this.#cycle }

        get errors() { return this.E.utils.safeGet(this, this.#errors, 'errors') ?? this.E.env.options.errors }
        set errors(value) { this.#errors = value }

        get options() { return this.E.utils.safeGet(this, this.#options, 'options') }
        set options(value) {
            if (this.#options === value) return
            this.#optionsMap = this.E.utils.parseObjectAttribute(value, this)
            this.#options = value
        }

        get optionsMap() {
            const attrOptions = this.getAttribute('options')
            if (attrOptions && attrOptions !== this.#options) this.options = attrOptions
            return this.#optionsMap
        }

        get parser() {
            const parser = (this.E.env.map.get(this) ?? {}).parser
            return (typeof parser === 'function') ? parser : this.E.parse.bind(this.E)
        }

        get resource() { return this.E.utils.safeGet(this, this.#resource, 'resource') }
        set resource(value) {
            if (this.#resource === value) return
            this.#createBound(value, 'resource')
            this.#resource = value
            const autoRefresh = !this.#use || !this.#boundResourceEventNames.length || ((this.#use !== '!') && this.#boundResourceEventNames.includes('change'))
            const boundTarget = this.boundTarget
            if (!boundTarget || (typeof boundTarget === 'string')) return
            if (this.#use === '$') {
                if (autoRefresh) this.#refresh(this.#boundResource)
            } else if (this.#use === '_') {
                if (autoRefresh) {
                    let resourceValue = Array.isArray(this.#boundResource)
                        ? this.#boundResource.map(n => this.E.getValue(n)).filter(n => !!n) : this.E.getValue(this.#boundResource)
                    if (!resourceValue || (Array.isArray(resourceValue) && !resourceValue.length)) return
                    this.#refresh(resourceValue)
                }
            } else if (this.#use !== '!') {
                if (autoRefresh) this.#refresh()
            }
        }

        get rewrite() { return this.E.utils.safeGet(this, this.#rewrite, 'rewrite') }
        set rewrite(value) {
            if (this.#rewrite === value) return
            this.#rewriteRules = []
            let rewriteRulesThis = this.E.utils.parseObjectAttribute(value, this) ?? {},
                rewriteRulesObject = (rewriteRulesThis.eEnv) ? Object.assign({ ...this.E.env.variables[rewriteRulesThis.eEnv] || {} }, rewriteRulesThis) : rewriteRulesThis
            for (const [re, p] of Object.entries(rewriteRulesObject)) this.#rewriteRules.push([Number.isInteger(Number(re)) ? re : new RegExp(re), p])
            this.#rewrite = value
        }

        get rewriteRules() {
            const attrRewrite = this.getAttribute('rewrite')
            if (attrRewrite && attrRewrite !== this.#rewrite) this.rewrite = attrRewrite
            return this.#rewriteRules
        }

        get serializer() {
            const serializer = (this.E.env.map.get(this) ?? {}).serializer
            return (typeof serializer === 'function') ? serializer : this.E.serialize.bind(this.E)
        }

        get target() { return this.E.utils.safeGet(this, this.#target, 'target') }
        set target(value) {
            if (this.#target === value) return
            this.#createBound(value, 'target')
            this.#target = value
        }

        get transform() {
            return this.E.utils.safeGet(this, this.#transform, 'transform')
        }
        set transform(value) {
            if (this.#transform === value) return
            this.#transform = value
        }

        get value() { return this.#value }

        #createBound(value, mode) {
            const setBound = v => mode === 'resource' ? (this.#boundResource = v) : (this.#boundTarget = v),
                getBound = () => mode === 'resource' ? this.#boundResource : this.#boundTarget,
                setBoundController = v => mode === 'resource' ? (this.#boundResourceController = v) : (this.#boundTargetController = v),
                getBoundController = () => mode === 'resource' ? this.#boundResourceController : this.#boundTargetController,
                setBoundObserver = v => mode === 'resource' ? (this.#boundResourceObserver = v) : (this.#boundTargetObserver = v),
                getBoundObserver = () => mode === 'resource' ? this.#boundResourceObserver : this.#boundTargetObserver,
                setCount = v => mode === 'resource' ? (this.#boundResourceRefreshCount = v) : (this.#boundTargetRefreshCount = v),
                getCount = () => mode === 'resource' ? this.#boundResourceRefreshCount : this.#boundTargetRefreshCount
            let bindStatement = value ?? '|'
            const useFlags = ['!', '$', '_']
            if (mode === 'target') this.#targetEvents = []
            if (mode === 'resource') {
                this.#boundResourceEventNames = []
                if (this.#cycleTracker) window.clearInterval(this.#cycleTracker)
            }
            if (bindStatement.startsWith('#')) bindStatement = `:|${bindStatement}`
            //if (bindStatement === '$') bindStatement = '|$'
            if (bindStatement.includes('|')) {
                let bindStatementSplit = bindStatement.split('|').map(s => decodeURIComponent(s).trim()), useRefresh = useFlags.includes(bindStatement[0]) ? bindStatement : bindStatementSplit[2],
                    [use, refreshOn] = !useRefresh ? ['$', 'change'] : (useFlags.includes(useRefresh[0]) ? [useRefresh[0], useRefresh.slice(1).trim() || 'change'] : ['!', useRefresh])
                let scope = this.E.utils.resolveScope(bindStatementSplit[0], this, useFlags), eventNameTagMap = { form: 'submit', input: 'change', select: 'change', textarea: 'change' }
                const attachEventListener = (node, eventName, use, useRefresh, start, end, refreshStep, bound, boundController) => {
                    if (!node) return
                    const tag = node.tagName.toLowerCase()
                    if (useFlags.includes(useRefresh) && (this.#boundResourceEventNames.length === 1) && eventName === 'change' && !node.eDataset) eventName = eventNameTagMap[tag] ?? 'click'
                    //if (this.id == 'test') console.log('pointer.html: line 193', node.id, eventName)
                    node.addEventListener(eventName, event => {
                        if ((eventName === 'submit') || (node.tagName.toLowerCase() === 'a' && node.hasAttribute('href'))) event.preventDefault()
                        let proceed = true, count = getCount()
                        if (refreshStep) proceed = (count >= start) && (!end || (count < end))
                        setCount(count + 1)
                        count = getCount()
                        if (proceed && refreshStep && step) proceed = !!((step === 1) ? (count % 2) : (count % step === 0))
                        if (!proceed) return
                        if (use === '!') {
                            //if (this.id == 'test') console.log('pointer.html: line 201')
                            this.#refresh(event)
                        } else if (use === '$') {
                            this.#refresh(bound)
                        } else if (use === '_') {
                            let resourceValue = Array.isArray(bound) ? bound.map(n => this.E.getValue(n)).filter(n => !!n) : this.E.getValue(bound)
                            if ((!Array.isArray(resourceValue) && resourceValue) || (Array.isArray(resourceValue) && resourceValue.length)) {
                                this.#refresh(Array.isArray(bound) ? bound.map(n => this.E.getValue(n)) : this.E.getValue(bound))
                            }
                        } else {
                            this.#refresh(this.E.getValue(node))
                        }
                    }, { signal: boundController.signal })
                }
                if (!scope) return
                setBound(this.E.utils.resolveSelector(scope, bindStatementSplit[1]), this)
                const processRecords = records => {
                    let oldBound = getBound(), newBound = this.E.utils.resolveSelector(scope, bindStatementSplit[1], this)
                    setBound(newBound)
                    oldBound = Array.isArray(oldBound) ? oldBound : [oldBound]
                    newBound = Array.isArray(newBound) ? newBound : [newBound]
                    let oldBoundSet = new Set(oldBound), newBoundSet = new Set(newBound)
                    if (mode === 'target' && (oldBound.some(b => !newBoundSet.has(b)) || newBound.some(b => !oldBoundSet.has(b)))) this.#boundTargetUpdated = true
                    if (mode === 'resource') {
                        if (refreshOn) {
                            const boundController = getBoundController(), [refreshFrom, refreshStep = ''] = refreshOn.split('{')
                            let [start = 0, end = 0, step = 0] = refreshStep.slice(0, -1).split(':').map(s => (parseInt(s) || 0)), bound = getBound()
                            for (let eventName of this.#boundResourceEventNames) {
                                //for (const node of newBound) attachEventListener(node, eventName, use, useRefresh, start, end, refreshStep, bound, boundController)
                            }
                        }
                    }
                    const autoRefresh = !this.#use || !this.#boundResourceEventNames.length || this.#boundResourceEventNames.includes('change')
                    //console.log('pointer.html: line 232', autoRefresh)
                    //if (autoRefresh) this.#refresh()
                }
                let observer = getBoundObserver()
                if (observer) processRecords(observer.takeRecords())
                observer && (observer.disconnect())
                observer = setBoundObserver(new MutationObserver(processRecords))
                observer.observe(scope, { subtree: true, childList: true, attributes: true, attributeOldValue: true })
                if (mode === 'resource') this.#use = use
                if (refreshOn) {
                    let boundController = getBoundController()
                    if (boundController) boundController.abort()
                    boundController = setBoundController(new AbortController())
                    const [refreshFrom, refreshStep = ''] = refreshOn.split('{')
                    let [start = 0, end = 0, step = 0] = refreshStep.slice(0, -1).split(':').map(s => (parseInt(s) || 0)), bound = getBound()
                    const bindNodes = Array.isArray(bound) ? bound : [bound], eventNames = refreshFrom.split(',').map(s => s.trim())
                    if (mode === 'resource') {
                        this.#boundResourceEventNames = eventNames
                        for (let eventName of eventNames) {
                            for (const node of bindNodes) attachEventListener(node, eventName, use, useRefresh, start, end, refreshStep, bound, boundController)
                        }
                    } else {
                        const targetAttrVal = this.getAttribute('target')
                        if (use === '!' && targetAttrVal && targetAttrVal.includes('!')) this.#targetEvents = eventNames
                    }
                }
            } else if ((bindStatement[0] === '`') && bindStatement.endsWith('`')) {
                bindStatement = bindStatement.slice(1, -1)
                let boundController = getBoundController()
                if (bindStatement.includes('(') && bindStatement.endsWith(')')) {
                    let [globalName, args] = bindStatement.split('(').map(s => s.trim())
                    args = args.slice(0, -1).split(',').map(s => s.trim()).map(arg => this.E.getVariable(arg, this))
                    if (window[globalName] && (typeof window[globalName] === 'function')) {
                        if (boundController) boundController.abort()
                        setBound(new window[globalName](...args))
                    }
                } else if (typeof window[bindStatement]) {
                    if (boundController) boundController.abort()
                    setBound(window[bindStatement])
                }
            } else if (bindStatement.includes(';')) {
                let [url, functionInvoker = 'default()', cycleStatement = '0:once:idle'] = bindStatement.split(';'), boundController = getBoundController()
                let [functionName = 'default', args = ''] = functionInvoker.split('(')
                args = args.slice(0, -1)
                new Promise((resolve, reject) => {
                    url = this.E.resolveUrl(url, this)
                    let contentType = this.E.utils.getContentType(this, url)
                    if (contentType === 'application/wasm') {
                        this.E.compileRequestOptions(null, this, null, null, contentType).then(requestOptions => this.E.utils.getWasm(url, requestOptions)).then(moduleImport => resolve(moduleImport.instance.exports[functionName]))
                    } else {
                        import(url).then(moduleImport => resolve(moduleImport[functionName]))
                    }
                }).then(baseFunc => {
                    if (boundController) boundController.abort()
                    setBound(baseFunc)
                    if (mode === 'resource') {
                        this.#cycle = cycleStatement.split(':')
                        let [period = '0', recur = 'once', mode = 'lazy'] = this.#cycle
                        let periodMs
                        if (period.endsWith('s')) {
                            periodMs = parseFloat(period) * 1000
                        } else if (period.endsWith('m')) {
                            periodMs = parseFloat(period) * 1000 * 60
                        } else if (period.endsWith('h')) {
                            periodMs = parseFloat(period) * 1000 * 60 * 60
                        } else if (period.endsWith('d')) {
                            periodMs = parseFloat(period) * 1000 * 60 * 60 * 24
                        } else {
                            periodMs = parseFloat(period)
                        }
                        periodMs = Math.round(periodMs)
                        const requestIdleCallback = window.requestIdleCallback || ((cb) => setTimeout(cb, 0)), run = () => {
                            const runResult = baseFunc(...(args.slice(0, -1).split(',').map(s => s.trim()).map(arg => this.E.getVariable(arg, this))))
                            if (recur === 'every' && mode === 'lazy' && (runResult instanceof Promise)) runResult.then(() => window.setTimeout(() => window.requestIdleCallback(() => run()), periodMs))
                        }
                        const recurFunction = recur === 'every' ? window.setInterval : window.setTimeout
                        this.#cycleTracker = recurFunction(() => {
                            if (mode === 'force') {
                                run()
                            } else {
                                window.requestIdleCallback(() => run())
                            }
                        }, periodMs)
                    }
                })
            } else {
                let url = this.E.resolveUrl(bindStatement, this), boundController = getBoundController()
                if (boundController) boundController.abort()
                setBound(url)
                if ((mode === 'resource') && bindStatement.includes(':#')) {
                    boundController = setBoundController(new AbortController())
                    window.addEventListener('hashchange', event => {
                        const resource = this.#resource
                        this.#resource = undefined
                        this.resource = resource
                    }, { signal: boundController.signal })
                }
            }
        }

        async #refresh(payload) {
            const boundResource = this.boundResource
            if (!boundResource) return
            let result
            if (!payload && ((typeof boundResource === 'string') || (typeof boundResource === 'function'))) {
                const requestOptions = await this.E.compileRequestOptions(payload, this)
                let contentType = this.E.utils.getContentType(this, typeof boundResource === 'string' ? boundResource : undefined)
                if (this._isReference && (contentType === 'application/javascript')) {
                    result = await import(boundResource)
                } else if (contentType === 'application/schema+json') {
                    result = boundResource
                } else if (typeof boundResource === 'function') {
                    result = await boundResource({
                        method: requestOptions.method ?? 'GET',
                        headers: {
                            'Content-Type': contentType,
                            ...requestOptions
                        },
                        url: new URL(this.#resource)
                    },
                        payload)
                } else {
                    const req = fetch(boundResource, requestOptions)
                    if (this._isReference) {
                        if (contentType === 'application/wasm') {
                            result = this.E.utils.getWasm(req)
                        } else { result = req.then(r => r.body) }
                    } else {
                        let response = await req
                        if (response.status >= 400) {
                            const rewriteRules = this.rewriteRules
                            if (rewriteRules.length) for (const [rx, p] of rewriteRules) if (rx == response.status) { response = await fetch(this.E.resolveUrl(p, this), requestOptions); break }
                            if (response.status >= 400) this.E.utils.processError('refresh', response.text(), this, response)
                        }
                        result = await this.parse(response)
                    }
                }
            } else { result = payload ?? boundResource }
            let transform = (this.transform ?? '').trim()
            if (transform && transform.startsWith('$') && !/[({]+|(\$\.)/.test(transform)) transform = this.E.getVariable(transform)
            if (transform) {
                if (result instanceof HTMLElement) {
                    result = this.E.flatten(result)
                } else if (Array.isArray(result) && result.every(n => n instanceof HTMLElement)) {
                    result = result.map(n => this.E.flatten(n))
                }
                result = await this.E.runTransform(transform, result, this.E.getValue(this), this)
            }
            const boundTarget = this.boundTarget ?? this.parentElement
            let valueUpdated = true
            try { valueUpdated = (JSON.stringify(this.#value ?? null) !== JSON.stringify(result ?? null)) } catch (e) { }
            if ((this._mode !== 'theme') && !this.hasAttribute('force') && !this.#boundTargetUpdated && !valueUpdated) return
            this.#boundTargetUpdated = false
            this.#value = result
            if ((this._mode !== 'theme') && !this.hasAttribute('allow-empty') && !(result instanceof Node) && (result === undefined || result === null || result === '' || (Array.isArray(result) && !result.length) || ((result instanceof Object) && !Object.keys(result).length))) return
            if (typeof boundTarget === 'string') {
                const requestOptions = await this.E.compileRequestOptions(result, this), optionsKeys = Object.keys(requestOptions)
                if (requestOptions.body && !requestOptions.method) {
                    navigator.sendBeacon(this.E.resolveUrl(boundTarget, this), requestOptions.body)
                } else { fetch(this.E.resolveUrl(boundTarget, this), requestOptions) }
            } else if (typeof boundTarget === 'function') {
                if (payload) {
                    let targetArgs = []
                    const apply = (this.apply || '')
                    if (this.#target && !this.#target.startsWith('`') && !this.#target.includes(';')) {
                        const requestOptions = await this.E.compileRequestOptions(result, this),
                            contentType = this.E.utils.getContentType(this, this.#target)
                        targetArgs.push({
                            method: requestOptions.method ?? 'GET',
                            headers: { 'Content-Type': contentType },
                            url: new URL(this.#target)
                        }, result)
                    } else if (apply === '...') {
                        targetArgs = Array.isArray(result) ? result : [result]
                    } else if (apply && Array.isArray(result)) {
                        targetArgs = apply.split(',').filter(v => !!v).map(s => this.E.getVariable(s.trim(), this))
                        for (let i = 0; i < Math.max(targetArgs.length, result.length); i++) targetArgs[i] = result[i] ?? targetArgs[i]
                    } else { targetArgs = [result] }
                    boundTarget(...targetArgs)
                }
            } else if (boundTarget instanceof Object && !(boundTarget instanceof HTMLElement) && !Array.isArray(boundTarget)) {
                let apply = this.apply || '', [subName, args] = apply.split('(').map(s => s.trim())
                if (typeof args === 'string') args = args.slice(0, -1)
                if (args && subName && (typeof boundTarget[subName] == 'function')) {
                    if (result) {
                        let targetArgs = []
                        if (typeof args === 'string') {
                            args.split(',').forEach(s => {
                                s = s.trim()
                                if (s === '') {
                                    targetArgs.push(result)
                                } else if (s === '...') {
                                    targetArgs.push(...(Array.isArray(result) ? result : [result]))
                                } else { targetArgs.push(this.E.getVariable(s, this)) }
                            })
                        } else { targetArgs = [result] }
                        boundTarget[subName](...targetArgs)
                    }
                } else if (subName && (boundTarget[subName] instanceof Object) && (result instanceof Object)) {
                    Object.assign(boundTarget[subName], result)
                } else if (result instanceof Object) { Object.assign(boundTarget, result) }
            } else {
                if (this.#targetEvents.length) {
                    for (const eventName of this.#targetEvents) for (const target of (Array.isArray(boundTarget) ? boundTarget : [boundTarget])) {
                        if (target instanceof EventTarget) target.dispatchEvent(new CustomEvent(eventName, { detail: result }))
                    }
                } else {
                    this._apply(result, Array.isArray(boundTarget) ? boundTarget : [boundTarget])
                }
            }
            this.dispatchEvent(new CustomEvent('change', { detail: { payload, result, transform } }))
        }

    }
</script>