<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #apply
        #applyMap
        #boundResource
        #boundResourceController
        #boundResourceObserver
        #boundResourceRefreshCount = 0
        #boundTarget
        #boundTargetController
        #boundTargetObserver
        #boundTargetRefreshCount = 0
        #boundTargetUpdated = true
        #cycle = []
        #cycleTracker
        #errors

        #newBind //maybe not?

        #options = ''
        #optionsMap = {}
        #resource
        #rewrite
        #rewriteRules = []
        #target
        #transform
        #targetEvents = []
        #use
        #value

        constructor() {
            super()
            Object.defineProperties(this, {
                _apply: { configurable: true, enumerable: false, value: async (result, target) => { } },
                _contentType: { configurable: true, enumerable: false, value: undefined },
                _isReference: { configurable: true, enumerable: false, value: false },
                _mode: { configurable: true, enumerable: false, value: 'pointer' }
            })
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('apply', 'errors', 'options', 'resource', 'rewrite', 'target', 'transform') }

        async connectedCallback() { }

        toString() { return this.resource ?? '' }

        async parse(value) { return await this.parser(value, this) }

        async serialize(value, contentType) { return await this.serializer(value, this, contentType) }

        get apply() { return this.E.utils.safeGet(this, this.#apply, 'apply') }
        set apply(value) {
            if (this.#apply === value) return
            this.#applyMap = this.E.utils.parseObjectAttribute(value, this)
            this.#apply = value
        }

        get applyMap() {
            const attrApply = this.getAttribute('apply')
            if (attrApply && attrApply !== this.#apply) this.apply = attrApply
            return this.#applyMap
        }

        get boundResource() {
            const resourceAttrVal = this.getAttribute('resource')
            if (resourceAttrVal && !this.#resource) {
                this.#createBound(resourceAttrVal, 'resource')
                this.#resource = resourceAttrVal
            }
            return this.#boundResource
        }

        get boundTarget() {
            const targetAttrVal = this.getAttribute('target')
            if (targetAttrVal !== !this.#target) this.target = targetAttrVal
            return this.#boundTarget
        }

        get cycle() { return this.#cycle }

        get errors() { return this.E.utils.safeGet(this, this.#errors, 'errors') ?? this.E.env.options.errors }
        set errors(value) { this.#errors = value }

        get options() { return this.E.utils.safeGet(this, this.#options, 'options') }
        set options(value) {
            if (this.#options === value) return
            this.#optionsMap = this.E.utils.parseObjectAttribute(value, this)
            this.#options = value
        }

        get optionsMap() {
            const attrOptions = this.getAttribute('options')
            if (attrOptions && attrOptions !== this.#options) this.options = attrOptions
            return this.#optionsMap
        }

        get parser() {
            const parser = (this.E.env.map.get(this) ?? {}).parser
            return (typeof parser === 'function') ? parser : this.E.parse.bind(this.E)
        }

        get resource() { return this.E.utils.safeGet(this, this.#resource, 'resource') }
        set resource(value) {
            if (this.#resource === value) return
            this.#createBound(value, 'resource')
            this.#resource = value
            if (!this.#use) { this.#refresh(); return }
            const boundTarget = this.boundTarget
            if (!boundTarget || (typeof boundTarget === 'string')) return
            if (this.#use === '$') {
                this.#refresh(this.#boundResource)
            } else if (this.#use === '_') {
                this.#refresh(Array.isArray(this.#boundResource) ? this.#boundResource.map(n => this.E.getValue(n)) : this.E.getValue(this.#boundResource))
            }
        }

        get rewrite() { return this.E.utils.safeGet(this, this.#rewrite, 'rewrite') }
        set rewrite(value) {
            if (this.#rewrite === value) return
            this.#rewriteRules = []
            let rewriteRulesThis = this.E.utils.parseObjectAttribute(value, this) ?? {},
                rewriteRulesObject = (rewriteRulesThis.eEnv) ? Object.assign({ ...this.E.env.variables[rewriteRulesThis.eEnv] || {} }, rewriteRulesThis) : rewriteRulesThis
            for (const [re, p] of Object.entries(rewriteRulesObject)) this.#rewriteRules.push([Number.isInteger(Number(re)) ? re : new RegExp(re), p])
            this.#rewrite = value
        }

        get rewriteRules() {
            const attrRewrite = this.getAttribute('rewrite')
            if (attrRewrite && attrRewrite !== this.#rewrite) this.rewrite = attrRewrite
            return this.#rewriteRules
        }

        get serializer() {
            const serializer = (this.E.env.map.get(this) ?? {}).serializer
            return (typeof serializer === 'function') ? serializer : this.E.serialize.bind(this.E)
        }

        get target() { return this.E.utils.safeGet(this, this.#target, 'target') }
        set target(value) {
            if (this.#target === value) return
            this.#createBound(value, 'target')
            this.#target = value
        }

        get transform() {
            return this.E.utils.safeGet(this, this.#transform, 'transform')
        }
        set transform(value) {
            if (this.#transform === value) return
            this.#transform = value
        }

        get value() { return this.#value }

        #createBound(value, mode) {
            const setBound = v => mode === 'resource' ? (this.#boundResource = v) : (this.#boundTarget = v),
                getBound = () => mode === 'resource' ? this.#boundResource : this.#boundTarget,
                setBoundController = v => mode === 'resource' ? (this.#boundResourceController = v) : (this.#boundTargetController = v),
                getBoundController = () => mode === 'resource' ? this.#boundResourceController : this.#boundTargetController,
                setBoundObserver = v => mode === 'resource' ? (this.#boundResourceObserver = v) : (this.#boundTargetObserver = v),
                getBoundObserver = () => mode === 'resource' ? this.#boundResourceObserver : this.#boundTargetObserver,
                setCount = v => mode === 'resource' ? (this.#boundResourceRefreshCount = v) : (this.#boundTargetRefreshCount = v),
                getCount = () => mode === 'resource' ? this.#boundResourceRefreshCount : this.#boundTargetRefreshCount
            let bindStatement = value ?? '|'
            const useFlags = ['!', '$', '_']
            this.#targetEvents = []
            if (mode === 'resource' && this.#cycleTracker) window.clearInterval(this.#cycleTracker)
            if (bindStatement.includes('|')) {
                let bindStatementSplit = bindStatement.split('|').map(s => decodeURIComponent(s).trim()), useRefresh = useFlags.includes(bindStatement[0]) ? bindStatement : bindStatementSplit[2],
                    [use, refreshOn] = !useRefresh ? ['$', 'change'] : (useFlags.includes(useRefresh[0]) ? [useRefresh[0], useRefresh.slice(1).trim() || 'change'] : ['!', useRefresh])
                let scope = this.E.utils.resolveScope(bindStatementSplit[0], this, useFlags)
                if (!scope) return
                setBound(this.E.utils.resolveSelector(scope, bindStatementSplit[1]))
                if (bindStatementSplit[1]) {
                    const processRecords = records => {
                        let oldBound = getBound(), newBound = this.E.utils.resolveSelector(scope, bindStatementSplit[1])
                        setBound(newBound)
                        oldBound = Array.isArray(oldBound) ? oldBound : [oldBound]
                        newBound = Array.isArray(newBound) ? newBound : [newBound]
                        let oldBoundSet = new Set(oldBound), newBoundSet = new Set(newBound)
                        if (mode === 'target' && (oldBound.some(b => !newBoundSet.has(b)) || newBound.some(b => !oldBoundSet.has(b)))) this.#boundTargetUpdated = true
                        this.#refresh()
                    }
                    let observer = getBoundObserver()
                    if (observer) processRecords(observer.takeRecords())
                    observer && (observer.disconnect())
                    observer = setBoundObserver(new MutationObserver(processRecords))
                    observer.observe(scope, { subtree: true, childList: true, attributes: true, attributeOldValue: true })
                }
                if (mode === 'resource') this.#use = use
                if (refreshOn) {
                    let boundController = getBoundController()
                    if (boundController) boundController.abort()
                    boundController = setBoundController(new AbortController())
                    const [refreshFrom, refreshStep = ''] = refreshOn.split('{')
                    let [start = 0, end = 0, step = 0] = refreshStep.slice(0, -1).split(':').map(s => (parseInt(s) || 0)), bound = getBound()
                    const bindNodes = Array.isArray(bound) ? bound : [bound], eventNames = refreshFrom.split(',').map(s => s.trim())
                    if (mode === 'resource') {
                        for (let eventName of eventNames) {
                            for (const node of bindNodes) {
                                if (!node) continue
                                if ((useRefresh === '!') && (eventNames.length === 1) && eventName === 'change' && !node.eDataset && !['input', 'select', 'textarea'].includes(node.tagName.toLowerCase())) eventName = 'click'
                                node.addEventListener(eventName, event => {
                                    let proceed = true, count = getCount()
                                    if (refreshStep) proceed = (count >= start) && (!end || (count < end))
                                    setCount(count + 1)
                                    count = getCount()
                                    if (proceed && refreshStep && step) proceed = !!((step === 1) ? (count % 2) : (count % step === 0))
                                    if (!proceed) return
                                    if (use === '!') {
                                        this.#refresh(event)
                                    } else if (use === '$') {
                                        this.#refresh(bound)
                                    } else if (Array.isArray(bound)) {
                                        this.#refresh(bound.map(node => this.E.getValue(node)))
                                    } else { this.#refresh(this.E.getValue(node)) }
                                }, { signal: boundController.signal })
                            }
                        }
                    } else {
                        const targetAttrVal = this.getAttribute('target')
                        if (use === '!' && targetAttrVal && targetAttrVal.includes('!')) this.#targetEvents = eventNames
                    }
                }
            } else if ((bindStatement[0] === '`') && bindStatement.endsWith('`')) {
                bindStatement = bindStatement.slice(1, -1)
                let [globalInvoker, subInvoker] = bindStatement.split('.').map(s => s.trim())
                args = args.slice(0, -1)
                let bindFunc = () => {
                    let bindThing
                    if (globalInvoker.includes('(') && globalInvoker.endsWith(')')) {
                        let [globalName, args] = globalInvoker.split('(').map(s => s.trim())
                        if (window[globalName] && (typeof window[globalName] === 'function'))
                            bindThing = this.#newBind ?? new window[globalName](...(args.slice(0, -1).split(',').map(s => s.trim()).map(arg => this.E.getVariable(arg, this))))
                    } else if (window[globalInvoker] && window[globalInvoker] instanceof Object) {
                        if (subInvoker && subInvoker.includes('(') && subInvoker.endsWith(')')) {
                            let [subName, args] = subInvoker.split('(').map(s => s.trim())
                            if (window[globalInvoker][subName] && (typeof window[globalInvoker][subName] === 'function'))
                                bindThing = this.#newBind ?? new window[globalInvoker][subName](...(args.slice(0, -1).split(',').map(s => s.trim()).map(arg => this.E.getVariable(arg, this))))
                        } else {
                            bindThing = () => {
                                const useArgs = args.slice(0, -1).split(',').map(s => s.trim()).map(arg => this.E.getVariable(arg, this))
                                if (subInvoker && (typeof window[globalInvoker][subInvoker] === 'function')) {
                                    window[globalInvoker][subInvoker](...useArgs)
                                } else if (subInvoker && (typeof window[globalInvoker][subInvoker] === 'object')) {
                                    Object.assign(window[globalInvoker][subInvoker], ...useArgs.filter(a => a instanceof Object))
                                } else if (globalInvoker && (typeof window[globalInvoker] === 'function')) {
                                    window[globalInvoker](...useArgs)
                                } else if (globalInvoker && (typeof window[globalInvoker] === 'object')) {
                                    Object.assign(window[globalInvoker], ...useArgs.filter(a => a instanceof Object))
                                }
                            }
                        }
                    }
                    this.#newBind = bindThing
                }
                if (boundController) boundController.abort()
                setBound(bindFunc)
            } else if (bindStatement.includes(';')) {
                let [url, functionInvoker = 'default()', cycleStatement = '0:once:idle'] = bindStatement.split(';'), boundController = getBoundController()
                let [functionName = 'default', args = ''] = functionInvoker.split('(')
                args = args.slice(0, -1)
                new Promise((resolve, reject) => {
                    url = this.E.resolveUrl(url, this)
                    let contentType = this.E.utils.getContentType(this, url)
                    if (contentType === 'application/wasm') {
                        this.E.compileRequestOptions(null, this, null, null, contentType).then(requestOptions => this.E.utils.getWasm(url, requestOptions)).then(moduleImport => resolve(moduleImport.instance.exports[functionName]))
                    } else {
                        import(url).then(moduleImport => resolve(moduleImport[functionName]))
                    }
                }).then(baseFunc => {
                    if (boundController) boundController.abort()
                    setBound(baseFunc)
                    if (mode === 'resource') {
                        this.#cycle = cycleStatement.split(':')
                        let [period = '0', recur = 'once', mode = 'lazy'] = this.#cycle
                        let periodMs
                        if (period.endsWith('s')) {
                            periodMs = parseFloat(period) * 1000
                        } else if (period.endsWith('m')) {
                            periodMs = parseFloat(period) * 1000 * 60
                        } else if (period.endsWith('h')) {
                            periodMs = parseFloat(period) * 1000 * 60 * 60
                        } else if (period.endsWith('d')) {
                            periodMs = parseFloat(period) * 1000 * 60 * 60 * 24
                        } else {
                            periodMs = parseFloat(period)
                        }
                        periodMs = Math.round(periodMs)
                        const requestIdleCallback = window.requestIdleCallback || ((cb) => setTimeout(cb, 0)), run = () => {
                            const runResult = baseFunc(...(args.slice(0, -1).split(',').map(s => s.trim()).map(arg => this.E.getVariable(arg, this))))
                            if (recur === 'every' && mode === 'lazy' && (runResult instanceof Promise)) runResult.then(() => window.setTimeout(() => window.requestIdleCallback(() => run()), periodMs))
                        }
                        const recurFunction = recur === 'every' ? window.setInterval : window.setTimeout
                        this.#cycleTracker = recurFunction(() => {
                            if (mode === 'force') {
                                run()
                            } else {
                                window.requestIdleCallback(() => run())
                            }
                        }, periodMs)
                    }
                })
            } else {
                let url = this.E.resolveUrl(bindStatement, this), boundController = getBoundController()
                if (boundController) boundController.abort()
                setBound(url)
                if ((mode === 'resource') && bindStatement.includes(':#')) {
                    boundController = setBoundController(new AbortController())
                    window.addEventListener('hashchange', event => {
                        const resource = this.#resource
                        this.#resource = undefined
                        this.resource = resource
                    }, { signal: boundController.signal })
                }
            }
        }

        async #refresh(payload) {
            const boundResource = this.boundResource
            if (!boundResource) return
            let result
            if (!payload && (typeof boundResource === 'string')) {
                let contentType = this.E.utils.getContentType(this, typeof boundResource === 'string' ? boundResource : undefined)
                if (this._isReference && (contentType === 'application/javascript')) {
                    result = await import(boundResource)
                } else if (contentType === 'application/schema+json') {
                    result = boundResource
                } else {
                    const requestOptions = await this.E.compileRequestOptions(payload, this), req = fetch(boundResource, requestOptions)
                    if (this._isReference) {
                        if (contentType === 'application/wasm') {
                            result = this.E.utils.getWasm(req)
                        } else { result = req.then(r => r.body) }
                    } else {
                        let response = await req
                        if (response.status >= 400) {
                            const rewriteRules = this.rewriteRules
                            if (rewriteRules.length) for (const [rx, p] of rewriteRules) if (rx == response.status) { response = await fetch(this.E.resolveUrl(p, this), requestOptions); break }
                            if (response.status >= 400) this.E.utils.processError('refresh', response.text(), this, response)
                        }
                        result = await this.parse(response)
                    }
                }
            } else { result = payload ?? boundResource }
            let transform = this.transform
            if (transform) {
                await this.E.installLibraryFromSrc('jsonata')
                if ((transform[0] === '$') && !transform.startsWith('$.') && !transform.slice(1).includes('$') && !transform.includes('{') && !transform.includes(':')) {
                    const variableValue = this.E.getVariable(transform, this)
                    if (typeof variableValue === 'string') transform = variableValue
                }
                try {
                    const variables = []
                    transform = await this.E.expandTransform(transform, this)
                    result = await this.E.env.libraries.jsonata(transform).evaluate(result)
                } catch (e) {
                    this.E.utils.processError('transform', e, this, e)
                }
            }
            const boundTarget = this.boundTarget ?? this.parentElement
            let valueUpdated = true
            try { valueUpdated = (JSON.stringify(this.#value ?? null) !== JSON.stringify(result ?? null)) } catch (e) { }
            if (!this.#boundTargetUpdated && !valueUpdated) return
            this.#boundTargetUpdated = false
            this.#value = result
            if (typeof boundTarget === 'string') {
                const requestOptions = await this.E.compileRequestOptions(result, this), optionsKeys = Object.keys(requestOptions)
                if (requestOptions.body && !requestOptions.method) {
                    navigator.sendBeacon(this.E.resolveUrl(boundTarget, this), requestOptions.body)
                } else { fetch(this.E.resolveUrl(boundTarget, this), requestOptions) }
            } else if (typeof boundTarget === 'function') {
                const targetArgs = [...(this.applyMap ?? [])]
                if (payload) {
                    if (Array.isArray(result)) {
                        targetArgs.push(...result)
                    } else {
                        targetArgs.push(result)
                    }
                }
                console.log('line 353', boundTarget, targetArgs)
                boundTarget(...targetArgs)
            } else {
                if (this.#targetEvents.length) {
                    for (const eventName of this.#targetEvents) for (const target of (Array.isArray(boundTarget) ? boundTarget : [boundTarget])) {
                        if (target instanceof EventTarget) target.dispatchEvent(new CustomEvent(eventName, { detail: result }))
                    }
                } else {
                    this._apply(result, Array.isArray(boundTarget) ? boundTarget : [boundTarget])
                }
            }
        }

    }
</script>