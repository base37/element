<style></style>
<template></template>
<script>
    class extends `meta` {

        #resource
        #target
        #transform
        #apply
        #applyMap
        #errors
        #rewrite
        #rewriteRules = []
        #boundResource
        #boundResourceController
        #boundTarget
        #boundTargetController
        #boundResourceObserver
        #boundTargetObserver
        #boundResourceRefreshCount = 0
        #boundTargetRefreshCount = 0
        #targetEvents = []
        #options = ''
        #optionsMap = {}
        #use

    	constructor() {
    		super()
            Object.defineProperties(this, {
                _mode: {configurable: true, enumerable: false, value: 'pointer'}, 
                _contentType: {configurable: true, enumerable: false, value: undefined}, 
                _isReference: {configurable: true, enumerable: false, value: false}, 
                _apply: {configurable: true, enumerable: false, value: async (result, target) => {}}
            })
    	}

		static get observedAttributes() { return (super.observedAttributes || []).concat('resource', 'target', 'apply', 'transform', 'rewrite', 'errors', 'options') }

        async connectedCallback() {}

        toString() { return this.resource ?? '' }

        #sliceAndStep(sig, list) {
            let [start=0, end=list.length, step=0] = sig.split(':').map(s => (parseInt(s) || 0))
            if (end === 0) end = list.length
            list = list.slice(start, end)
            if (!step) return list
            return (step === 1) ? list.filter((v, i) => (i+1) % 2) : list.filter((v, i) => (i+1) % step === 0)            
        }

        async #refresh(payload) {
            const boundResource = this.boundResource, compileRequestOptions = async v => {
                let optionsMap = this.optionsMap, requestOptions = {...(this.e.env.variables[optionsMap.eEnv] || {}), ...optionsMap},  headers = requestOptions.headers ?? {}, contentType = headers['Content-Type'] ?? headers['content-type'] ?? headers.contentType
                contentType ||= this.getAttribute('content-type') || this._contentType
                if (!contentType && v) contentType ||= 'application/json'
                if (contentType) {
                    requestOptions.headers = headers
                    requestOptions.headers['Content-Type'] = contentType
                }
                if (v instanceof Object) {
                    requestOptions.body = await this.#serialize(v, contentType)
                } else if (v) {
                    requestOptions.method ||= 'POST'
                    requestOptions.body = `${v}`
                }
                return requestOptions
            }
            if (!boundResource) return
            let result
            if (!payload && (typeof boundResource === 'string')) {
                let contentType = this.getAttribute('content-type') || this._contentType || undefined
                if (this._isReference && ((contentType === 'application/javascript') || boundResource.endsWith('.mjs') || boundResource.endsWith('.js'))) {
                    result = await import(boundResource)
                } else if (contentType === 'application/schema+json') { 
                    result = boundResource
                } else {
                    const requestOptions = await compileRequestOptions(payload), req = fetch(boundResource, requestOptions)
                    if (this._isReference) {
                        if ((contentType === 'application/wasm') || boundResource.endsWith('.wasm')) {
                            result = await WebAssembly.instantiateStreaming(req)
                        } else { result = req.then(r => r.body) }
                    } else {
                        let response = await req
                        if (response.status >= 400) {
                            const rewriteRules = this.rewriteRules
                            if (rewriteRules.length) for (const [rx, p] of rewriteRules) if (rx == response.status) { 
                                response = await fetch(this.e.resolveUrl(p, this), requestOptions)
                                break 
                            } 
                            if (response.status >= 400) {
                                this.dispatchEvent(new CustomEvent('error', {detail: {type: 'refresh', status: response.status, input: response.url, requestOptions}}))
                                if (this.errors === 'throw') { throw new Error(response.text()); return } else if (this.errors === 'hide') { return }
                            }
                        }
                        result = await this.#parse(response)
                    }
                }
            } else { result = payload ?? boundResource }
            let transform = this.transform || this.getAttribute('transform')
            if (transform) {
                await this.e._installJsonata()
                if ((transform[0] === '$') && !transform.startsWith('$.') && !transform.slice(1).includes('$') && !transform.includes('{') && !transform.includes(':')) {
                    const variableValue = this.e.getVariable(transform, this)
                    if (typeof variableValue === 'string') transform = variableValue
                }
                try { 
                    const variables = []
                    if (transform.includes('$env')) variables.push(`$env := ${JSON.stringify(this.e.env, ['eDataset', 'modes', 'options', 'variables'])}`)
                    if (transform.includes('$this')) variables.push(`$this := ${JSON.stringify(this.valueOf())}`)
                    for (const [vn, vv] of Object.entries(this.e.env.variables)) {
                        if ((vn === 'env') || (vn === 'this')) continue
                        if (transform.includes(`$${vn}`)) variables.push(`$${vn} := ${JSON.stringify(vv)}`)
                    }
                    if (variables.length) transform = `( ${variables.join(' ; ')} ; ${transform})`
                    result = await this.e.env.libraries.jsonata(transform).evaluate(result) 
                } catch(e) {
                    this.dispatchEvent(new CustomEvent('error', {detail: {type: 'transform', message: e, input: result}}))
                    if (this.errors === 'throw') { throw new Error(e); return } else if (this.errors === 'hide') { result = {} }
                }
            }
            const boundTarget = this.boundTarget ?? this.parentElement
            if (typeof boundTarget === 'string') {
                const requestOptions = await compileRequestOptions(result), optionsKeys = Object.keys(requestOptions)
                if (requestOptions.body && !requestOptions.method) {
                    navigator.sendBeacon(this.e.resolveUrl(boundTarget, this), requestOptions.body)
                } else { fetch(this.e.resolveUrl(boundTarget, this), requestOptions) }
            } else { 
                if (this.#targetEvents.length) {
                    for (const eventName of this.#targetEvents) {
                        for (const target of (Array.isArray(boundTarget) ? boundTarget : [boundTarget])) {
                            if (target instanceof EventTarget) target.dispatchEvent(new CustomEvent(eventName, {detail: payload}))
                        }
                    }
                } else {
                    this._apply(result, Array.isArray(boundTarget) ? boundTarget : [boundTarget]) 
                }
            }
        }

        async #parse(value) {
            const parser = (this.e.env.map.get(this) ?? {}).parser
            return (typeof parser === 'function') ? (await parser(value, this)) : (await this.e.parse(value, this))
        }

        async #serialize(value, contentType) {
            const serializer = (this.e.env.map.get(this) ?? {}).serializer
            return (typeof serializer === 'function') ? (await serializer(value, this, contentType)) : (await this.e.serialize(value, this, contentType))
        }

        #createBound(value, mode) {
            const setBound = v => mode === 'resource' ? (this.#boundResource = v) : (this.#boundTarget = v),
                getBound = () => mode === 'resource' ? this.#boundResource : this.#boundTarget,  
                setBoundController = v => mode === 'resource' ? (this.#boundResourceController = v) : (this.#boundTargetController = v), 
                getBoundController = () => mode === 'resource' ? this.#boundResourceController : this.#boundTargetController,
                setBoundObserver = v => mode === 'resource' ? (this.#boundResourceObserver = v) : (this.#boundTargetObserver = v), 
                getBoundObserver = () => mode === 'resource' ? this.#boundResourceObserver : this.#boundTargetObserver, 
                setCount = v => mode === 'resource' ? (this.#boundResourceRefreshCount = v) : (this.#boundTargetRefreshCount = v), 
                getCount = () => mode === 'resource' ? this.#boundResourceRefreshCount : this.#boundTargetRefreshCount
            let useValue = value ?? '|'
            const useFlags = ['!', '$', '_'], startsWithFlag = useFlags.includes(useValue[0])
            this.#targetEvents = []
            if (useValue.includes('|') || startsWithFlag) {
                let [closest, selector, useRefresh] = startsWithFlag ? ['', '', useValue] : useValue.split('|').map(s => decodeURIComponent(s).trim()), 
                [use, refreshOn] = !useRefresh ? ['$', 'change']
                    : (useFlags.includes(useRefresh[0]) ? [ useRefresh[0] , useRefresh.slice(1).trim() || 'change']: ['!' , useRefresh]) 
                let scope
                if (startsWithFlag) {
                    scope = this
                } else if (useValue.startsWith('|')) {
                    scope = this.parentElement
                } else if (useValue.startsWith(':|') || useValue.startsWith(':root|')) {
                    scope = this.getRootNode()
                } else if (useValue.startsWith(':host|')) {
                    scope = this.getRootNode()
                    if (scope instanceof ShadowRoot) scope = scope.host
                } else if (useValue.startsWith(':document|')) {
                    scope = document
                } else { scope = this.closest(closest) }
                if (!scope) return
                if (mode === 'resource') this.#use = use
                if (!selector) {
                    setBound(scope)
                } else if (selector.includes('{') && selector.endsWith('}')) {
                    let [selectorStem, sig] = selector.split('{')
                    setBound(this.#sliceAndStep(sig.slice(0, -1), Array.from(scope.querySelectorAll(selectorStem))))
                } else { setBound(scope.querySelector(selector)) }
                if (selector) {
                    const processRecords = records => {
                        if (!selector) {
                            setBound(scope)
                        } else if (selector.includes('{') && selector.endsWith('}')) {
                            let [selectorStem, sig] = selector.split('{')
                            setBound(this.#sliceAndStep(sig.slice(0, -1), Array.from(scope.querySelectorAll(selectorStem))))
                        } else { setBound(scope.querySelector(selector)) }
                        //this.#refresh()
                    }
                    let observer = getBoundObserver()
                    if (observer) processRecords(observer.takeRecords())
                    observer && (observer.disconnect())
                    observer = setBoundObserver(new MutationObserver(processRecords))
                    observer.observe(scope, {subtree: true, childList: true, attributes: true, attributeOldValue: true})
                }
                if (refreshOn) {
                    let boundController = getBoundController()
                    if (boundController) boundController.abort()
                    boundController = setBoundController(new AbortController())
                    const [refreshFrom, refreshStep=''] = refreshOn.split('{')
                    let [start=0, end=0, step=0] = refreshStep.slice(0, -1).split(':').map(s => (parseInt(s) || 0)), bound = getBound()
                    const bindNodes = Array.isArray(bound) ? bound : [bound], eventNames = refreshFrom.split(',').map(s => s.trim())
                    if (mode === 'resource') {
                        for (let eventName of eventNames) {
                            for (const node of bindNodes) {
                                if (!node) continue
                                if ((useRefresh === '!') && (eventNames.length === 1) && eventName==='change' && !node.eDataset && !['input', 'select', 'textarea'].includes(node.tagName.toLowerCase())) {
                                    eventName = 'click'
                                }
                                node.addEventListener(eventName, event => {
                                    let proceed = true, count = getCount()
                                    if (refreshStep) proceed = (count >= start) && (!end || (count < end))
                                    setCount(count + 1)
                                    count = getCount()
                                    if (proceed && refreshStep && step) proceed = !!((step === 1) ? (count % 2) : (count % step === 0))
                                    if (!proceed) return
                                    if (use === '!') {
                                        this.#refresh(event)
                                    } else if (use === '$') {
                                        this.#refresh(bound)
                                    } else if (Array.isArray(bound)) {
                                        this.#refresh(bound.map(node => this.e.getValue(node)))
                                    } else { this.#refresh(this.e.getValue(node)) }
                                }, {signal: boundController.signal})
                            }
                        }
                    } else { 
                        const targetAttrVal = this.getAttribute('target')
                        if (use === '!' && targetAttrVal && targetAttrVal.includes('!')) this.#targetEvents = eventNames
                    }
                }
            } else {
                let url = this.e.resolveUrl(useValue, this), boundController = getBoundController()
                if (boundController) boundController.abort()
                setBound(url)
                if (useValue.includes(':#')) {
                    boundController = setBoundController(new AbortController())
                    window.addEventListener('hashchange', event => {
                        const resource = this.#resource
                        this.#resource = undefined
                        this.resource = resource
                    }, {signal: boundController.signal})
                }
            }
        }

        set resource(value) {
            if (this.#resource === value) return
            this.#createBound(value, 'resource')
            this.#resource = value
            if (!this.#use) { this.#refresh(); return }
            const boundTarget = this.boundTarget
            if (!boundTarget || (typeof boundTarget === 'string')) return
            if (this.#use === '$') {
                this.#refresh(this.#boundResource)
            } else if (this.#use === '_') {
                this.#refresh(Array.isArray(this.#boundResource) ? this.#boundResource.map(n => this.e.getValue(n)) : this.e.getValue(this.#boundResource))
            }
        }
        get resource() { return this.#resource }
        get boundResource() { 
            const resourceAttrVal = this.getAttribute('resource')
            if (resourceAttrVal && !this.#resource) {
                this.#createBound(resourceAttrVal, 'resource')
                this.#resource = resourceAttrVal
            }
            return this.#boundResource 
        }

        set target(value) { 
            if (this.#target === value) return
            this.#createBound(value, 'target')
            this.#target = value
        }
        get target() { return this.#target }
        get boundTarget() { 
            const targetAttrVal = this.getAttribute('target')
            if (targetAttrVal !== !this.#target) this.target = targetAttrVal
            return this.#boundTarget
        }

        set transform(value) { this.#transform = value }
        get transform() { return this.#transform }

        set apply(value) { 
            this.#applyMap = this.e.utils.parseObjectAttribute(value, this)
            this.#apply = value 
        }
        get apply() { return this.#apply }
        get applyMap() { 
            const attrApply = this.getAttribute('apply')
            if (attrApply && attrApply!== this.#apply) this.apply = attrApply
            return this.#applyMap 
        }

        set rewrite(value) {
            if ((this.getAttribute('rewrite') ?? '') !== (this.#rewrite ?? '')) {
                let value = this.getAttribute('rewrite')
                this.#rewriteRules = []
                let rewriteRulesThis = this.e.utils.parseObjectAttribute(value, this) ?? {}, 
                rewriteRulesObject = (rewriteRulesThis.eEnv) ? Object.assign({...this.e.env.variables[rewriteRulesThis.eEnv] || {}}, rewriteRulesThis) : rewriteRulesThis
                for (const [re, p] of Object.entries(rewriteRulesObject)) this.#rewriteRules.push([Number.isInteger(Number(re)) ? re : new RegExp(re), p])
            }
            this.#rewrite = value
        }
        get rewrite() { return this.#rewrite }
        get rewriteRules() { 
            const attrRewrite = this.getAttribute('rewrite')
            if (attrRewrite && attrRewrite!== this.#rewrite) this.rewrite = attrRewrite
            return this.#rewriteRules
        }

        set options(value) {
            this.#optionsMap = this.e.utils.parseObjectAttribute(value, this)
            this.#options = value
        }
        get options() { return this.#options }
        get optionsMap() { 
            const attrOptions = this.getAttribute('options')
            if (attrOptions && attrOptions!== this.#options) this.options = attrOptions
            return this.#optionsMap 
        }

        set errors(value) { this.#errors = value }
        get errors() { return this.#errors ?? this.e.env.options.errors }

    }
</script>