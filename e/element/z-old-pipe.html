<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #abortController = new AbortController()
        #contentType
        #options
        #optionsMap = {}
        #pull
        #pullAbortController
        #push
        #pushAbortController
        #reader
        #send
        #source
        #sourceObject
        #sourceObjectAvailable = false
        #sync
        #syncAbortController
        #value
        #writeQueue = []
        #writer

        constructor() {
            super()
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat(':', 'content-type', 'options', 'push', 'pull', 'source', 'sync') }

        async connectedCallback() { }

        async read(detail, dryRun = false) {
            const reader = (this.E.env.map.get(this) ?? {}).reader ?? this.#reader
            if (typeof reader === 'function') {
                const result = await reader(detail, this), v = await this.#parse(result)
                if (dryRun) return v
                this.dispatchEvent(new CustomEvent('read', { detail: result }))
                this.#handleChange(v)
            } else {
                const parseTarget = (detail instanceof CustomEvent && (detail.detail !== undefined)) ? detail.detail : ((detail instanceof MessageEvent) ? detail.data : detail),
                    v = await this.#parse(parseTarget)
                if (dryRun) return v
                this.dispatchEvent(new CustomEvent('read', { detail }))
                this.#handleChange(v)
            }
        }

        async write(payload, useTransform, path) {
            if (this.#sourceObjectAvailable) {
                let transform
                if (useTransform && (useTransform = useTransform.trim())) {
                    useTransform = (this.E.resolveVariables(useTransform) ?? '', this).trim()
                    if (useTransform.startsWith('`') && useTransform.endsWith('`')) {
                        transform = useTransform.slice(1, -1).trim()
                    } else if (useTransform.startsWith('/') || useTransform.startsWith('./') || useTransform.startsWith('../')) {
                        path = useTransform
                        useTransform = undefined
                    } else { transform = useTransform }
                } else {
                    transform = this.transform
                    if (transform) transform = (this.E.resolveVariables(transform), this)
                }
                if (transform) {
                    let baseValue = null
                    try { baseValue = JSON.parse(JSON.stringify(this.#value ?? null)) } catch (e) { console.log('pipe.html: line 57', e) }
                    payload = await this.E.runTransform(transform, payload, baseValue, this)
                }
                const writer = (this.E.env.map.get(this) ?? {}).writer ?? this.#writer
                if (typeof writer === 'function') {
                    const p = this.contentType ? await this.#serialize(payload) : payload
                    await this.read(await writer(p, this))
                } else if (this.#sourceObject instanceof WebSocket) {
                    this.#sourceObject.write(await this.#serialize(payload))
                } else if (this.#sourceObject instanceof EventSource) {
                    fetch(this.#sourceObject.url, { ...(this.optionsMap ?? {}), body: (await this.#serialize(payload)) })
                } else if (this.#sourceObject instanceof WebTransport) {
                    writer(await this.#serialize(payload), this)
                } else if (this.#sourceObject instanceof EventTarget) {
                    this.#sourceObject.dispatchEvent(new CustomEvent(this.#source, { detail: payload }))
                } else if ((this.#sourceObject instanceof Object) && (payload instanceof Object)) {
                    await this.read(Object.assign(this.#sourceObject, payload))
                } else if (this.#sourceObject instanceof Function) {
                    await this.read(this.#sourceObject(payload))
                } else if (typeof this.#sourceObject === 'string') {
                    let { href: url, protocol, pathname } = new URL(path || '', this.#sourceObject)
                    url = this.E.resolveUrl(url)
                    if (typeof url === 'function') {
                        const contentType = this.contentType, p = contentType ? await this.#serialize(payload) : payload,
                            requestOptions = await this.E.compileRequestOptions(p, this),
                            context = { method: requestOptions.method ?? 'GET', headers: { 'Content-Type': contentType }, url: new URL(this.#sourceObject) }
                        await this.read(await url(context, p))
                    } else { await this.read(await fetch(url, { ...(this.optionsMap ?? {}), body: (await this.#serialize(payload)) })) }
                } else { return }
                this.dispatchEvent(new CustomEvent('write', { detail: payload }))
            } else { this.#writeQueue.push(payload) }
        }

        #connectSource(source) {
            this.#sourceObjectAvailable = false
            this.#writeQueue = []
            this.#reader = undefined
            this.#writer = undefined
            this.#abortController.abort()
            this.#abortController = new AbortController()
            source = this.E.resolveVariables(source, this)
            if (source[0] === '`' && source.endsWith('`')) {
                const [sourceWriteStatement, readerStatement] = source.slice(1, -1).split(' -> ', 2).map(s => s.trim()).filter(s => !!s)
                let [writerStatement, ...sourceStatement] = sourceWriteStatement.split('.').map(s => s.trim()).filter(s => !!s).reverse()
                if (writerStatement && !sourceStatement.length) {
                    sourceStatement = writerStatement
                    writerStatement = undefined
                } else { sourceStatement = sourceStatement.join('.') }
                this.#sourceObject = this.E.utils.resolveGlobal(sourceStatement, this)
                if (!this.#sourceObject) return
                let [writerName, writerArgs] = writerStatement.split('(').map(s => s.trim()).filter(s => !!s)
                writerArgs = (writerArgs ?? '').slice(0, -1).split(',').map(s => s.trim()).filter(s => !!s)
                this.#writer = payload => {
                    if (typeof this.#sourceObject[writerName] === 'function') {
                        this.#sourceObject[writerName](...writerArgs.map(a => this.E.resolveVariables(a, this)), payload)
                    } else if ((this.#sourceObject[writerName] instanceof Object) && (payload instanceof Object)) {
                        Object.assign(...this.#sourceObject[writerName], payload)
                    }
                }
                let [readerName, readerArgs] = readerStatement.split(/{|\(|\[/).map(s => s.trim()).filter(s => !!s)
                readerArgs = (readerArgs ?? '').slice(0, -1).split(',').map(s => s.trim()).filter(s => !!s)
                if (readerStatement.includes('(')) {
                    this.#reader = () => {
                        if (typeof this.#sourceObject[readerName] === 'function') return this.#sourceObject[readerName](...readerArgs.map(a => this.E.resolveVariables(a, this)))
                    }
                } else if (readerName[0] === '!') {
                    this.#sourceObject.addEventListener(readerName.slice(1), event => this.read(event))
                } else if (readerName) {
                    this.#reader = () => this.#sourceObject[readerName]
                }
                this.#sourceObjectAvailable = true
                Promise.all(this.#writeQueue.map(p => this.write(p))).then(() => this.read())
            } else if (source.startsWith('wss://')) {
                const makeSocket = () => {
                    const optionsMap = this.optionsMap ?? {}
                    this.#sourceObject = new WebSocket(source, optionsMap.protocols ?? [])
                    if (optionsMap.binaryType) this.#sourceObject.binaryType = optionsMap.binaryType
                    this.#sourceObject.addEventListener('open', event => {
                        this.#sourceObjectAvailable = true
                        for (const j of this.#writeQueue) this.write(j)
                    }, { once: true, signal: this.#abortController.signal })
                    this.#sourceObject.addEventListener('error', event => this.#sourceObjectAvailable = false, { signal: this.#abortController.signal })
                    this.#sourceObject.addEventListener('close', event => {
                        this.#sourceObjectAvailable = false
                        makeSocket()
                    }, { once: true, signal: this.#abortController.signal })
                    this.#sourceObject.addEventListener('message', event => this.read(event), { signal: this.#abortController.signal })
                }
                makeSocket()
            } else if (source.startsWith('sse://')) {
                const [url, events = ['message']] = source.split('!', 2)
                this.#sourceObject = new EventSource(url.replace('sse://', 'https://'), this.optionsMap)
                this.#sourceObject.addEventListener('open', event => {
                    this.#sourceObjectAvailable = true
                    for (const j of this.#writeQueue) this.write(j)
                }, { signal: this.#abortController.signal })
                for (const eventName of events) this.#sourceObject.addEventListener(eventName, event => this.read(event), { signal: this.#abortController.signal })
            } else if (source.startsWith('wt://')) {
                const makeTransport = () => {
                    const optionsMap = this.optionsMap ?? {}, { datagrams, sendOrder } = optionsMap
                    delete optionsMap.datagrams
                    delete optionsMap.sendOrder
                    this.#sourceObject = new WebTransport(via.replace('wt://', 'https://'), this.optionsMap)
                    this.#sourceObject.ready.then(() => {
                        this.#sourceObjectAvailable = true
                        for (const j of this.#writeQueue) this.write(j)
                    })
                    this.#sourceObject.closed.then(() => {
                        this.#sourceObjectAvailable = false
                        makeTransport()
                    })
                    let stream = datagrams ? this.#sourceObject.datagrams : createBidirectionalStream({ sendOrder })
                    Promise.resolve(stream).then(async stream => {
                        this.#reader = async () => {
                            const reader = stream.readable.getReader(), result = []
                            while (true) {
                                const { value, done } = await reader.read()
                                result.push(...value)
                                if (done) break
                            }
                            return result
                        }
                        this.#writer = async payload => this.#serialize(payload).then(d => stream.writable.write(Uint8Array.from((new TextEncoder()).encode(d))))
                        this.#sourceObjectAvailable = true
                    })
                }
                makeTransport()
            } else if (source.includes('://')) {
                this.#sourceObject = source
                this.#sourceObjectAvailable = true
                for (const j of this.#writeQueue) this.write(j)
            } else if (source) {
                this.#sourceObject = new EventTarget()
                this.addEventListener(source, event => this.read(event), { signal: this.#abortController.signal })
                this.#sourceObjectAvailable = true
                for (const j of this.#writeQueue) this.write(j)
            }
        }

        #handleChange(newValue) {
            if (JSON.stringify(newValue ?? null) !== JSON.stringify(this.#value ?? null)) {
                this.#value = newValue
                this.dispatchEvent(new CustomEvent('change', { detail: newValue }))
            }
        }

        async #parse(value, contentType) {
            const parser = (this.E.env.map.get(this) ?? {}).parser
            contentType ||= this.contentType
            return (typeof parser === 'function') ? (await parser(value, this, contentType)) : (await this.E.parse(value, this, contentType))
        }

        async #serialize(value, contentType) {
            const serializer = (this.E.env.map.get(this) ?? {}).serializer
            contentType ||= this.contentType
            return (typeof serializer === 'function') ? (await serializer(value, this, contentType)) : (await this.E.serialize(value, this, contentType))
        }

        get [':']() { return this.source }
        set [':'](value) { this.source = value }

        get contentType() { return this.E.utils.safeGet(this, this.#contentType, 'content-type', 'contentType') }
        set contentType(value) { this.#contentType = value }

        get ['content-type']() { return this.contentType }
        set ['content-type'](value) { this.contentType = value }

        get options() { return this.E.utils.safeGet(this, this.#options, 'options') }
        set options(value) {
            if (this.#options === value) return
            this.#optionsMap = this.E.utils.parseObjectAttribute(value, this)
            this.#options = value
        }

        get optionsMap() {
            const optionsAttr = this.getAttribute('options')
            if (this.#options !== optionsAttr) this.#optionsMap = this.E.utils.parseObjectAttribute(this.E.resolveVariables(optionsAttr, this), this)
            return this.#optionsMap
        }

        get pull() { return this.E.utils.safeGet(this, this.#pull, 'pull') }
        set pull(value) {
            if (this.#pull === value) return
            if (value) {
                let cellName = this.E.resolveVariables(value)
                if (this.#pullAbortController) this.#pullAbortController.abort()
                this.#pullAbortController = new AbortController()
                const signal = this.#pullAbortController.signal
                this.E.getCell(cellName).eventTarget.addEventListener('change', event => {
                    if (event.detail !== undefined && (event.detail !== this.#value)) this.write(event.detail)
                }, { signal })
            }
            this.#pull = value
        }

        get push() { return this.E.utils.safeGet(this, this.#push, 'push') }
        set push(value) {
            if (this.#push === value) return
            if (value) {
                let cellName = this.E.resolveVariables(value)
                if (this.#pushAbortController) this.#pushAbortController.abort()
                this.#pushAbortController = new AbortController()
                const signal = this.#pushAbortController.signal
                this.addEventListener('change', event => {
                    if (this.#value === undefined) return
                    this.E.getCell(cellName).set(this.#value)
                }, { once, signal })
            }
            this.#push = value
        }

        get source() { return this.E.utils.safeGet(this, this.#source, 'source') }
        set source(value) {
            if (this.#source === value) return
            this.#connectSource(value)
            this.#source = value
        }

        get sourceObject() { return this.#sourceObject }

        get sourceObjectAvailable() { return this.#sourceObjectAvailable }

        get sync() { return this.E.utils.safeGet(this, this.#sync, 'sync') }
        set sync(value) {
            if (this.#sync === value) return
            if (value) {
                let cellName = this.E.resolveVariables(value)
                if (this.#syncAbortController) this.#syncAbortController.abort()
                this.#syncAbortController = new AbortController()
                const signal = this.#syncAbortController.signal, once = true
                if (this.#value === undefined) {
                    this.addEventListener('change', event => {
                        if (this.#value === undefined) return
                        const cell = this.E.getCell(cellName)
                        if (cell.get() === undefined) cell.set(this.#value)
                    }, { once, signal })
                } else {
                    const cell = this.E.getCell(cellName)
                    if (cell.get() === undefined) cell.set(this.#value)
                }
                this.E.getCell(cellName).eventTarget.addEventListener('change', event => {
                    if (event.detail !== undefined && (event.detail !== this.#value)) this.write(event.detail)
                }, { signal })
            }
            this.#sync = value
        }

        get value() { return this.#value }

    }

</script>