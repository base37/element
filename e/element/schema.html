<style></style>
<template></template>
<script>
    export default class extends `./pointer` {

        #abortController
        #canonicalUrl
        #schema
        #validate = input => true

        constructor() {
            super()
            this.#abortController = new AbortController()
            Object.defineProperties(this, {
                _apply: {
                    configurable: false, enumerable: false, value: async (result, target) => {
                        this.#canonicalUrl = result
                        let applyMap = this.applyMap ?? {}
                        if (!this.E.env.libraries.ajv) {
                            let ajvOptions = { ...this.E.env.options.ajv, ...applyMap }
                            this.E.env.libraries.ajv = new (await import('https://cdn.jsdelivr.net/npm/ajv@8.12.0/+esm')).default(ajvOptions)
                            const addFormats = (await import('https://cdn.jsdelivr.net/npm/ajv-formats/+esm')).default
                            addFormats(this.E.env.libraries.ajv)
                        }
                        this.#validate = this.E.env.libraries.ajv.getSchema(this.#canonicalUrl)
                        if (!this.#validate) {
                            let schemaFetch = await fetch(this.#canonicalUrl), schemaText = await schemaFetch.text()
                            if (schemaFetch.status >= 400) {
                                this.dispatchEvent(new CustomEvent('error', { detail: { type: 'load', status: schemaFetch.status, message: schemaText } }))
                                if (this.errors === 'throw') { throw new Error(schemaText); return } else if (this.errors === 'hide') { schemaText = '{}' }
                            }
                            let schemaJson
                            try { schemaJson = JSON.parse(schemaText) } catch (e) { }
                            if (schemaJson instanceof Object) {
                                this.#schema = JSON.parse(schemaText)
                                delete schemaJson['$schema']
                                this.E.env.libraries.ajv.addSchema(schemaJson, this.#canonicalUrl)
                                this.#validate = this.E.env.libraries.ajv.getSchema(this.#canonicalUrl)
                            } else { this.dispatchEvent(new CustomEvent('error', { detail: { type: 'parse', status: schemaFetch.status, message: schemaText } })) }
                        }
                        this.#abortController.abort()
                        this.#abortController = new AbortController()
                        for (const t of target) {
                            t.addEventListener('change', async event => {
                                const valid = await this.#validate(this.E.getValue(t)), errors = valid ? [] : [...this.#validate.errors]
                                if (!valid && errors.length) {
                                    t.dispatchEvent(new CustomEvent('error', { detail: errors }))
                                } else if (valid) { t.dispatchEvent(new CustomEvent('success', { detail: errors })) }
                            }, { signal: this.#abortController.signal })
                        }
                    }
                },
                _contentType: { configurable: false, enumerable: false, writable: false, value: 'application/schema+json' },
                _isReference: { configurable: false, enumerable: false, writable: false, value: true },
                _mode: { configurable: false, enumerable: false, writable: false, value: 'schema' }
            })
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('parser') }

        validate(data) {
            if (data instanceof HTMLElement) data = this.E.getValue(data)
            const valid = this.#validate(data), errors = valid ? [] : [...this.#validate.errors]
            return [valid, errors]
        }

        get schema() { return this.schema }

        get canonicalUrl() { return this.#canonicalUrl }

    }
</script>