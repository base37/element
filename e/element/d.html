<style></style>
<template></template>
<script>
    export default class extends `./map` {

        static portType = 'DOM'

        constructor() {
            super()
            Object.defineProperty(this, '_getPort', {
                value: portExpression => this.#getPort(portExpression, signal)
            })
        }

        #getPort(portExpression, signal) {
            if (!portExpression || (typeof portExpression !== 'string') || !(signal instanceof AbortSignal)) return
            const direction = this.direction, cells = this.cells
            if (!cells) return
            const [scopeExpression, selectorEvents] = portExpression.split(/\|(?!\=)/g),
                scope = this.E.resolveScope(scopeExpression.trim(), this)
            if (!scope) return
            selectorEvents = selectorEvents.trim()
            let selector, eventNames = [], useDefaultEvents = true, selectorEventsLastIndexOf = selectorEvents.lastIndexOf('!')
            if (selectorEventsLastIndexOf === -1) {
                selector = selectorEvents
            } else {
                selector = selectorEvents.slice(0, selectorEventsLastIndexOf)
                eventNames = selectorEvents.slice(selectorEventsLastIndexOf + 1).split(',').map(s => s.trim()).filter(s => !!s)
                useDefaultEvents = !eventNames.length
            }
            if (this.direction === 'toCell') {
                if (useDefaultEvents) eventNames = Array.from(new Set(Object.values(this.E.env.options.defaultEventTypes).concat(['click'])))
                for (const eventName of eventNames) {
                    scope.addEventListener(eventName, async event => {
                        if (selector && !event.target.matches(selector)) return
                        if (useDefaultEvents && (event.type !== (this.E.env.options.defaultEventTypes[event.target.tagName.toLowerCase()] ?? 'click'))) return
                        if (this.prevent) event.preventDefault()
                        const sourceValue = this.E.flatten(event.currentTarget), transform = this.transform, force = this.force,
                            setToCell = async (cell, countLabel, counter) => {
                                const value = cell.get(), result = await this.E.runTransform(transform, sourceValue, this, { cell: { value, name: cell.name, [countLabel]: counter }, event: this.E.flatten(event) })
                                if (!force) if ((result === undefined) || (value === result) || (JSON.stringify(value) === JSON.stringify(result))) return
                                cell.set(result, force)
                            }
                        if (Array.isArray(cells)) {
                            for (const [index, cell] of cells.entries()) setToCell(cell, 'index', index)
                        } else if (cells) {
                            for (const [key, cell] of Object.entries(cells)) setToCell(cell, 'key', key)
                        }
                    }, { signal })
                }
            } else if (direction === 'fromCell') {
                const applyCellValue = (value, cell, countLabel, counter, event) => {
                    let targets = this.E.utils.resolveSelector(selector, scope)
                    if (!Array.isArray(targets)) targets = [targets]
                    for (const target of targets) this.E.runTransform(this.transform, value, this, { cell: { value, name: cell.name, [countLabel]: counter }, event: this.E.flatten(event), target: this.E.flatten(target) })
                        .then(data => this.E.applyData(target, data))
                }
                if (Array.isArray(cells)) {
                    for (const [index, cell] of cells.entries()) {
                        const cellValue = cell.get()
                        if (this.force || (cellValue !== undefined)) applyCellValue(cellValue, cell, 'index', index)
                        cell.eventTarget.addEventListener('change', event => {
                            if (this.force || (event.detail !== undefined)) applyCellValue(event.detail, cell, 'index', index, event)
                        }, { signal })
                    }
                } else if (cells) {
                    for (const [key, cell] of Object.entries(cells)) {
                        const cellValue = cell.get()
                        if (this.force || (cellValue !== undefined)) applyCellValue(cellValue, cell, 'key', key)
                        cell.eventTarget.addEventListener('change', event => {
                            if (this.force || (event.detail !== undefined)) applyCellValue(event.detail, cell, 'key', key, event)
                        }, { signal })
                    }
                }
            } else { return }
            return scope
        }

    }
</script>