<style></style>
<template></template>
<script>
    export default class extends `./map` {

        static portType = 'DOM'

        constructor() {
            super()
            Object.defineProperty(this, '_getPort', {
                value: (portExpression, signal) => this.#getPort(portExpression, signal)
            })
            Object.defineProperty(this, '_applyFromCell', {
                value: (value, cell, countLabel, counter, event, selector, scope) => this.#applyFromCell(value, cell, countLabel, counter, event, selector, scope)
            })
        }

        #getPort(portExpression, signal) {
            if (!portExpression || (typeof portExpression !== 'string') || !(signal instanceof AbortSignal)) return
            const direction = this.direction, cells = this.cells
            if (!cells) return
            let [scopeExpression, selectorEvents] = portExpression.split(/\|(?!\=)/g).map(s => s.trim()),
                scope = this.E.utils.resolveScope(scopeExpression, this)
            if (!scope) return
            let selector, eventNames = [], useDefaultEvents = true, selectorEventsLastIndexOf = selectorEvents.lastIndexOf('!')
            if (selectorEventsLastIndexOf === -1) {
                selector = selectorEvents
            } else {
                selector = selectorEvents.slice(0, selectorEventsLastIndexOf)
                eventNames = selectorEvents.slice(selectorEventsLastIndexOf + 1).split(',').map(s => s.trim()).filter(s => !!s)
                useDefaultEvents = !eventNames.length
            }
            if (this.direction === 'toCell') {
                if (useDefaultEvents) eventNames = Array.from(new Set(Object.values(this.E.env.options.defaultEventTypes).concat(['click'])))
                for (const eventName of eventNames) {
                    scope.addEventListener(eventName, async event => {
                        if (selector && !event.target.matches(selector)) return
                        if (useDefaultEvents && (event.type !== (this.E.env.options.defaultEventTypes[event.target.tagName.toLowerCase()] ?? 'click'))) return
                        if (this.prevent) event.preventDefault()
                        const value = this.E.flatten(event.target)
                        if (Array.isArray(cells)) {
                            for (const [index, cell] of cells.entries()) this.saveToCell(value, cell, { index }, { event })
                        } else if (cells) {
                            for (const [key, cell] of Object.entries(cells)) this.saveToCell(value, cell, { key }, { event })
                        }
                    }, { signal })
                }
            } else if (direction === 'fromCell') {
                this.connectFromCells(signal, [selector, scope])
            } else { return }
            return scope
        }

        #applyFromCell(value, cell, countLabel, counter, event, selector, scope) {
            let targets = this.E.utils.resolveSelector(selector, scope)
            if (!Array.isArray(targets)) targets = [targets]
            for (const target of targets) this.E.runTransform(this.transform, value, this, { cell: { value, name: cell.name, [countLabel]: counter }, event: this.E.flatten(event), target: this.E.flatten(target) })
                .then(data => this.E.applyData(target, data))
        }

    }
</script>