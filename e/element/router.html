<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #base
        #name
        #options
        #optionsMap
        #value

        static {
            Object.defineProperty(this, 'modes', { value: this.E.env.modes })
        }

        modes = {}

        constructor() {
            super()
            for (const mode in this.constructor.modes) {
                this.modes[mode] ||= { ...this.constructor.modes[mode] }
                let modeSignature = this.getAttribute(mode)
                if (modeSignature) {
                    let [path, pointer, ...suffix] = modeSignature.split('/').map(s => s.split('.')).flat()
                    suffix = suffix.join('.')
                    this.modes[mode].path = path
                    this.modes[mode].pointer = pointer
                    this.modes[mode].suffix = suffix
                }
                this.modes[mode].path ||= this.constructor.modes[mode].path
                this.modes[mode].pointer ||= this.constructor.modes[mode].pointer
                this.modes[mode].suffix ||= this.constructor.modes[mode].suffix
                const f = this.processor.bind(this.e, this, mode, this.modes[mode].path, this.modes[mode].suffix)
                f.toString = this.processor.bind(this.e, this, mode, this.modes[mode].path, this.modes[mode].suffix, false, this.modes[mode].pointer)
                Object.defineProperty(this, mode, { configurable: true, enumerable: true, get: () => f })
            }
        }

        toString() { return this.#name }

        static get observedAttributes() { return (super.observedAttributes || []).concat('base', 'name', 'options') }

        connectedCallback() {
            window.addEventListener('hashchange', event => {
                this.#value = this.baseURI
                this.dispatchEvent(new CustomEvent('change', { detail: { newURL: event.newURL, oldURL: event.oldURL } }))
            })
            this.#value = this.baseURI
        }

        processor(router, mode, path = undefined, suffix = undefined, pointer = undefined, get = false) {
            path ||= router.modes[mode]?.path ?? mode
            pointer ||= router.modes[mode]?.pointer ?? mode
            suffix ||= router.modes[mode]?.suffix ?? ''
            const url = new URL(`${router.base && router.base.endsWith('*') ? ('./') : (router.name + '/')}${path}/${pointer}${suffix ? '.' + suffix : ''}`, router.base ? (new URL(router.base, router.baseURI).href) : router.baseURI).href
            return get ? fetch(router.E.resolveUrl(url), this.optionsMap) : url
        }

        to(path, proceed, mode) {
            if (proceed === false) return
            let url
            if (mode && (typeof this.modes[mode] === 'function')) {
                url = this.modes[mode](path)
            } else {
                url = new URL(`${this.base && this.base.endsWith('*') ? ('./') : (this.name + '/')}${path}`, this.base ? (new URL(this.base, this.baseURI).href) : this.baseURI).href
            }
            window.location = url
        }

        get base() { return this.#base }
        set base(value) { this.#base = value }

        get name() { return this.#name }
        set name(value) { if (value !== this.#name) this.#name = value }

        get options() { return this.#options }
        set options(value) {
            this.#optionsMap = this.E.utils.parseObjectAttribute(value, this)
            this.#options = value
        }

        get optionsMap() {
            const attrOptions = this.getAttribute('options')
            if (attrOptions && attrOptions !== this.#options) this.options = attrOptions
            return this.#optionsMap
        }

    }
</script>