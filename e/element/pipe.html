<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #abortController = new AbortController()
        #contentType
        #sourceObject
        #sourceObjectAvailable = false
        #options
        #optionsMap = {}
        #project
        #sendQueue = []
        #reader
        #send
        #writer
        #source
        #transform
        #value

        constructor() {
            super()
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('content-type', 'options', 'project', 'source', 'transform') }

        async connectedCallback() { }

        read(detail) {
            const parseTarget = (detail instanceof CustomEvent && (detail.detail !== undefined)) ? detail.detail : ((detail instanceof MessageEvent) ? detail.data : detail)
            this.#parse(parseTarget).then(v => {
                this.dispatchEvent(new CustomEvent('read', { detail }))
                this.#handleChange(v)
            })
        }

        write(payload) {
            if (this.#sourceObjectAvailable) {
                const writer = (this.E.env.map.get(this) ?? {}).writer ?? this.#writer, transform = this.transform
                if (transform) {


                }
                if (typeof writer === 'function') {
                    writer(payload, this)
                } else if (this.#sourceObject instanceof WebSocket) {
                    this.#sourceObject.send(payload)
                } else if (this.#sourceObject instanceof EventSource) {
                    const requestOptions = payload instanceof Object ? payload : { body: JSON.stringify(payload) }
                    fetch(this.#sourceObject.url, { ...(this.optionsMap ?? {}), ...requestOptions })
                } else if (this.#sourceObject instanceof WebTransport) {

                } else if (this.#sourceObject instanceof EventTarget) {
                    this.dispatchEvent(new CustomEvent(this.#source, { detail: payload }))
                } else if ((this.#sourceObject instanceof Object) && (payload instanceof Object)) {
                    Object.assign(this.#sourceObject, payload)
                } else if (this.#sourceObject instanceof Function) {
                    this.#sourceObject(payload)
                } else if (typeof this.#sourceObject === 'string') {
                    const requestOptions = payload instanceof Object ? payload : { body: JSON.stringify(payload) }
                    fetch(this.#sourceObject, { ...(this.optionsMap ?? {}), ...requestOptions }).then(response => this.read(response))
                } else { return }
                this.dispatchEvent(new CustomEvent('write', { detail: payload }))
            } else { this.#sendQueue.push(payload) }
        }

        #connectSource(source) {
            this.#sourceObjectAvailable = false
            this.#sendQueue = []
            this.#reader = undefined
            this.#writer = undefined
            this.#abortController.abort()
            this.#abortController = new AbortController()
            source = this.E.getVariable(source, this)
            if (source[0] === '`' && source.endsWith('`')) {
                const [sourceWriteStatement, readerStatement] = source.slice(1, -1).split('!', 2).map(s => s.trim()).filter(s => !!s)
                let [writerStatement, ...sourceStatement] = sourceWriteStatement.split('.').map(s => s.trim()).filter(s => !!s).reverse()
                if (writerStatement && !sourceStatement.length) {
                    sourceStatement = writerStatement
                    writerStatement = undefined
                } else { sourceStatement = sourceStatement.join('.') }
                this.#sourceObject = this.E.utils.resolveGlobal(sourceStatement, this)
                if (!this.#sourceObject) return
                let [writerName, writerArgs] = writerStatement.split('(').map(s => s.trim()).filter(s => !!s)
                writerArgs = (writerArgs ?? '').slice(0, -1).split(',').map(s => s.trim()).filter(s => !!s)
                this.#writer = payload => {
                    if (typeof this.#sourceObject[writerName] === 'function') {
                        this.#sourceObject[writerName](...writerArgs.map(a => this.E.getVariable(a, this)), payload)
                    } else if ((this.#sourceObject[writerName] instanceof Object) && (payload instanceof Object)) {
                        Object.assign(...this.#sourceObject[writerName], payload)
                    }
                }
                let [readerName, readerArgs] = readerStatement.split(/{|\(|\[/).map(s => s.trim()).filter(s => !!s)
                readerArgs = (readerArgs ?? '').slice(0, -1).split(',').map(s => s.trim()).filter(s => !!s)
                if (readerStatement.includes('(')) {
                    this.#reader = () => {
                        if (typeof this.#sourceObject[readerName] === 'function') return this.#sourceObject[readerName](...readerArgs.map(a => this.E.getVariable(a, this)))
                    }
                } else if (readerName) { this.#sourceObject.addEventListener(readerName, event => this.read(event)) }
                this.#sourceObjectAvailable = true
                for (const j of this.#sendQueue) this.send(j)
            } else if (source.startsWith('wss://')) {
                const makeSocket = () => {
                    const optionsMap = this.optionsMap ?? {}
                    this.#sourceObject = new WebSocket(source, optionsMap.protocols ?? [])
                    if (optionsMap.binaryType) this.#sourceObject.binaryType = optionsMap.binaryType
                    this.#sourceObject.addEventListener('open', event => {
                        this.#sourceObjectAvailable = true
                        for (const j of this.#sendQueue) this.write(j)
                    }, { once: true, signal: this.#abortController.signal })
                    this.#sourceObject.addEventListener('error', event => this.#sourceObjectAvailable = false, { signal: this.#abortController.signal })
                    this.#sourceObject.addEventListener('close', event => {
                        this.#sourceObjectAvailable = false
                        makeSocket()
                    }, { once: true, signal: this.#abortController.signal })
                    this.#sourceObject.addEventListener('message', event => this.read(event), { signal: this.#abortController.signal })
                }
                makeSocket()
            } else if (source.startsWith('https://') || source.startsWith('http://')) {
                this.#sourceObject = source
                this.#sourceObjectAvailable = true
                for (const j of this.#sendQueue) this.write(j)
            } else if (source.startsWith('sse://')) {
                const [url, events = ['message']] = source.split('!', 2)
                this.#sourceObject = new EventSource(url.replace('sse://', 'https://'), this.optionsMap)
                this.#sourceObject.addEventListener('open', event => {
                    this.#sourceObjectAvailable = true
                    for (const j of this.#sendQueue) this.write(j)
                }, { signal: this.#abortController.signal })
                for (const eventName of events) this.#sourceObject.addEventListener(eventName, event => this.read(event), { signal: this.#abortController.signal })
            } else if (source.startsWith('wt://')) {
                const makeTransport = () => {
                    this.#sourceObject = new WebTransport(via.replace('wt://', 'https://'), this.optionsMap)
                    this.#sourceObject.ready.then(() => {
                        this.#sourceObjectAvailable = true
                        for (const j of this.#sendQueue) this.write(j)
                    })
                    this.#sourceObject.closed.then(() => {
                        this.#sourceObjectAvailable = false
                        makeTransport()
                    })
                }
                makeTransport()
            } else if (source) {
                this.#sourceObject = new EventTarget()
                this.addEventListener(source, event => this.read(event), { signal: this.#abortController.signal })
                this.#sourceObjectAvailable = true
                for (const j of this.#sendQueue) this.write(j)
            }
        }

        #handleChange(newValue) {
            if (JSON.stringify(newValue ?? null) !== JSON.stringify(this.#value ?? null)) {
                this.#value = newValue
                this.dispatchEvent(new CustomEvent('change', { detail: newValue }))
            }
        }

        async #parse(value, contentType) {
            const parser = (this.E.env.map.get(this) ?? {}).parser
            contentType ||= this.contentType
            return (typeof parser === 'function') ? (await parser(value, this, contentType)) : (await this.E.parse(value, this, contentType))
        }

        async #serialize(value, contentType) {
            const serializer = (this.E.env.map.get(this) ?? {}).serializer
            contentType ||= this.contentType
            return (typeof serializer === 'function') ? (await serializer(value, this, contentType)) : (await this.E.serialize(value, this, contentType))
        }

        get contentType() { return this.E.utils.safeGet(this, this.#contentType, 'contentType') }
        set contentType(value) { this.#contentType = value }

        get ['content-type']() { return this.contentType }
        set ['content-type'](value) { this.contentType = value }

        get options() { return this.E.utils.safeGet(this, this.#options, 'options') }
        set options(value) {
            if (this.#options === value) return
            this.#optionsMap = this.E.utils.parseObjectAttribute(value, this)
            this.#options = value
        }

        get optionsMap() {
            const optionsAttr = this.getAttribute('options')
            if (this.#options !== optionsAttr) this.#optionsMap = this.E.utils.parseObjectAttribute(optionsAttr, this)
            return this.#optionsMap
        }

        get project() { return this.E.utils.safeGet(this, this.#project, 'project') }
        set project(value) {
            if (this.#project === value) return
            this.#project = value
        }

        get source() { return this.E.utils.safeGet(this, this.#source, 'source') }
        set source(value) {
            if (this.#source === value) return
            this.#connectSource(value)
            this.#source = value
        }

        get sourceObject() { return this.#sourceObject }

        get sourceObjectAvailable() { return this.#sourceObjectAvailable }

        get transform() { return this.E.utils.safeGet(this, this.#transform, 'transform') }
        set transform(value) {
            if (this.#transform === value) return
            this.#transform = value
        }

        get value() {
            let currentValue = this.#value
            if (typeof this.#reader === 'function') {
                currentValue = this.#reader()
                this.dispatchEvent(new CustomEvent('read'))
            }
            this.#handleChange(currentValue)
            return this.#value
        }

    }

</script>