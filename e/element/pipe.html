<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #abortController = new AbortController()
        #contentType
        #listen
        #options
        #optionsMap
        #resource
        #resourceReady
        #sendQueue = []
        #transform
        #value
        #via

        _contentType = 'application/json'
        _defaultListen = 'message'
        _defaultUse = 'detail'
        __ = '.value'
        _optionsTransform
        _resourceClass = 'EventTarget'
        _resourceNewArgs = ''
        _resourceReadyTest
        _sendMethodName

        constructor() {
            super()
            this.addEventListener('_ready', event => {
                for (const q of this.#sendQueue) this.send(q)
            })
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('via', 'transform', 'content-type', 'options') }

        async connectedCallback() { }

        async send(payload) {
            if (this.#resourceReady) {
                const sender = (this.E.env.map.get(this) ?? {}).sender, sendMethodName = this.getAttribute('send')
                if (typeof sender === 'function') {
                    await sender(payload, this)
                } else if (sendMethodName && (typeof this.#resource[sendMethodName] === 'function')) {
                    await this.#resource[sendMethodName](payload, this)
                } else if (this._sendMethodName && (typeof this.#resource[this._sendMethodName] === 'function')) {
                    await this.#resource[this._sendMethodName](payload, this)
                } else if (typeof this._sender === 'function') {
                    await this._sender(payload, this)
                }
            } else { this.#sendQueue.push(payload) }
        }

        async _setResource(signature) {
            let use = this._defaultUse, listen = this.listen || this._defaultListen, contentType = this.contentType,
                transform = await this.E.expandTransform(this.transform, this), options = this.optionsMap
            if (!signature || (signature.endsWith(')') && signature.includes('('))) {
                const [resourceClass, newArgs] = signature ? (signature.slice(0, -1).split('(')) : [(this._resourceClass ?? 'EventTarget'), (this._resourceNewArgs ?? '')], args = newArgs.split(',').map(a => this.E.utils.resolveMergeToken(a, this))
                const optionsArgs = (this._optionsTransform) ? await this.E.env.libraries.jsonata(this._optionsTransform).evaluate(options ?? {}) : (options ? [options] : [])
                if (typeof window[resourceClass] !== 'function') return
                this.#resource = new window[resourceClass](...args, ...optionsArgs)
                if (typeof this._resourceReadyTest === 'function') {
                    this.E.utils.waitUntil(async () => { this._resourceReadyTest(this.#resource, this) })
                } else { this.#resourceReady = true }
            } else {
                const url = this.E.resolveUrl(signature)
                if (url.startsWith('wss://')) {
                    let binaryType = (options ?? {}).binaryType
                    if (binaryType) delete options.binaryType
                    this.#resource = new WebSocket(url, (options ?? {}))
                    if (binaryType) this.#resource.binaryType = binaryType
                    this.#resource.addEventListener('open', event => {
                        this.#resourceReady = true
                        this.dispatchEvent(new CustomEvent('_ready'))
                    })
                    this.#resource.addEventListener('close', event => {
                        this.#resourceReady = false
                        this.#abortController.abort()
                        this.#abortController = new AbortController()
                        this._setResource(signature)
                    })
                    this.#resource.addEventListener('error', event => { })
                    use = 'data'
                } else {
                    if (!listen || listen.includes('$')) {
                        this._sender = async (payload) => {
                            const requestOptions = this.optionsMap ?? {}
                            if (payload) requestOptions.body = payload
                            if (payload && (typeof payload !== 'string')) payload = await this.#serialize(payload, contentType ?? this._contentType)
                            const result = await this.#parse((await fetch(url, requestOptions)), contentType)
                            if (transform) result = await this.E.env.libraries.jsonata(transform).evaluate(result)
                            this.#value = result
                            this.dispatchEvent(new CustomEvent('change', { detail: result }))
                        }
                        if (listen.includes('$')) {
                            await this._sender()
                            if (listen === '$') this.#resourceReady = true
                        }
                    }
                    if (listen && (listen !== '$')) {
                        this.#resource = new EventSource(url, options)
                        this.#resource.addEventListener('open', event => {
                            this.#resourceReady = true
                        })
                        this.#resource.addEventListener('error', event => { })
                        use = 'data'
                    }
                }
            }
            if (!(this.#resource instanceof EventTarget)) return
            let eventMaps = (listen || '').split(',').map(s => s.trim())
            for (const eventMap of eventMaps) {
                if (eventMap === '$') continue
                let [listenToUse = this._defaultListen, dispatchAs] = eventMap.split('|').map(s => s.trim()), listenTo, thisUse = use
                if (listenToUse.includes('.')) {
                    let listenToUseSplit = listenToUse.split('.').map(s => s.trim())
                    thisUse = listenToUseSplit.pop() || use
                    listenTo = listenToUseSplit.join('.')
                } else { listenTo = listenToUse }
                dispatchAs ||= listenTo
                this.#resource.addEventListener(listenTo, async event => {
                    let payload = event[thisUse || 'detail']
                    if (contentType && ((typeof payload === 'string') || (payload instanceof Response))) payload = await this.#parse(payload, contentType)
                    if (transform) payload = await this.E.env.libraries.jsonata(transform).evaluate(payload)
                    this.#value = payload
                    if (dispatchAs !== 'change') this.dispatchEvent(new CustomEvent('change', { detail: payload }))
                    this.dispatchEvent(new CustomEvent(dispatchAs, { detail: payload }))
                }, { signal: this.#abortController.signal })
            }
        }

        get ['content-type']() { return this.contentType }
        set ['content-type'](value) { this.contentType = value }

        get contentType() {
            if (this.#contentType !== this.getAttribute('content-type')) this.contentType = this.getAttribute('content-type')
            return this.#contentType
        }
        set contentType(value) { this.#contentType = value }

        get listen() {
            if (this.#listen !== this.getAttribute('listen')) this.listen = this.getAttribute('listen')
            return this.#listen
        }
        set listen(value) { this.#listen = value }

        get options() { return this.#options }
        set options(value) {
            this.#optionsMap = this.E.utils.parseObjectAttribute(value, this)
            this.#options = value
        }

        get optionsMap() {
            const optionsAttr = this.getAttribute('options')
            if (this.#options !== optionsAttr) this.#optionsMap = this.E.utils.parseObjectAttribute(optionsAttr, this)
            return this.#optionsMap
        }

        get resource() { return this.#resource }

        get transform() {
            if (this.#transform !== this.getAttribute('transform')) this.transform = this.getAttribute('transform')
            return this.#transform
        }
        set transform(value) { this.#transform = value }

        get value() { return this.#value }

        get via() { return this.#via }
        set via(value) {
            this._setResource(value)
            this.#via = value
        }

        async #parse(value, contentType) {
            const parser = (this.E.env.map.get(this) ?? {}).parser
            return (typeof parser === 'function') ? (await parser(value, this, contentType)) : (await this.E.parse(value, this, contentType))
        }

        async #serialize(value, contentType) {
            const serializer = (this.E.env.map.get(this) ?? {}).serializer
            return (typeof serializer === 'function') ? (await serializer(value, this, contentType)) : (await this.E.serialize(value, this, contentType))
        }

    }
</script>