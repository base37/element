<style></style>
<template></template>
<script>
    class extends `meta` {

        #via
        #resource
        #transform
        #listen
        #contentType
        #options
        #optionsMap
        #value
        #sendQueue = []

        #resourceReady

        #abortController = new AbortController()

        _resourceClass = 'EventTarget'
        _resourceNewArgs = ''
        _resourceReadyTest
        _defaultListen = 'message'
        _defaultUse = 'data'
        _eValueProxy = '.value'
        _contentType = 'application/json'
        _sendMethodName

        constructor() {
            super()
            Object.defineProperties(this, {
                _class: {configurable: true, enumerable: false, value: 'EventTarget'}, 
                _classArgs: {configurable: true, enumerable: false, value: ''}, 
                _optionsTransform: {configurable: true, enumerable: false, value: undefined}, 
                _resourceReadyTest: {configurable: true, enumerable: false, value: undefined}, 
                _defaultListen: {configurable: true, enumerable: false, value: 'message'}, 
                _defaultUse: {configurable: true, enumerable: false, value: 'data'}, 

                _sendMethodName: {configurable: true, enumerable: false, value: 'send'}
            })
            this.addEventListener('_ready', event => {
               for (const q of this.#sendQueue) this.send(q)
            })
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('via', 'transform', 'content-type', 'options') }

        async connectedCallback() {}

        async #parse(value, contentType) {
            const parser = (this.e.env.map.get(this) ?? {}).parser
            return (typeof parser === 'function') ? (await parser(value, this, contentType)) : (await this.e.parse(value, this, contentType))
        }

        async #serialize(value, contentType) {
            const serializer = (this.e.env.map.get(this) ?? {}).serializer
            return (typeof serializer === 'function') ? (await serializer(value, this, contentType)) : (await this.e.serialize(value, this, contentType))
        }

        async _setResource(signature) {
            let use = this._defaultUse, listen = this._defaultListen, contentType = this.contentType, 
                transform = await this.e.expandTransform(this.transform, this), options = this.optionsMap
            if (!signature || (signature.endsWith(')') && signature.includes('('))) {
                const [resourceClass, newArgs] = signature ? (signature.slice(0, -1).split('(')) : [(this._resourceClass ?? 'EventTarget'), (this._resourceNewArgs ?? '')], args = newArgs.split(',').map(a => this.e.utils.resolveMergeToken(a, this))
                const optionsArgs = (this._optionsTransform) ? await this.e.env.libraries.jsonata(this._optionsTransform).evaluate(options ?? {}) : (options ? [options] : [] )
                if (typeof window[resourceClass] !== 'function') return
                this.#resource = new window[resourceClass](...args, ...optionsArgs)

                if (typeof this._resourceReadyTest === 'function') {
                    this.e.utils.waitUntil(async () => { this._resourceReadyTest(this.#resource, this) })
                } else { this.#resourceReady = true }
            } else {
                const url = this.e.resolveUrl(signature)
                if (url.startsWith('wss://')) {
                    let binaryType = (options ?? {}).binaryType
                    if (binaryType) delete options.binaryType
                    this.#resource = new WebSocket(url, (options ?? {}))
                    if (binaryType) this.#resource.binaryType = binaryType
                    this.#resource.addEventListener('open', event => {
                        this.#resourceReady = true
                        this.dispatchEvent(new CustomEvent('_ready'))
                    })
                    this.#resource.addEventListener('close', event => {
                        this.#resourceReady = false
                        this.#abortController.abort()
                        this.#abortController = new AbortController()
                        this._setResource(signature)
                    })
                    this.#resource.addEventListener('error', event => {})
                } else {
                    if (!listen || listen.includes('$')) {
                        this._sender = async (payload) => {
                            const requestOptions = this.optionsMap ?? {}
                            if (payload) requestOptions.body = payload
                            if (payload && (typeof payload !== 'string')) payload = await this.#serialize(payload, contentType ?? this._contentType)
                            const result = await this.#parse((await fetch(url, requestOptions)), contentType)
                            if (transform) result = await this.e.env.libraries.jsonata(transform).evaluate(result)
                            this.#value = result
                            this.dispatchEvent(new CustomEvent('change', {detail: result}))
                        }
                        if (listen.includes('$')) {
                            await this._sender()
                            if (listen === '$') this.#resourceReady = true  
                        } 
                    }
                    if (listen && (listen !== '$')) {
                        this.#resource = new EventSource(url, options)
                        this.#resource.addEventListener('open', event => {
                            this.#resourceReady = true
                        })
                        this.#resource.addEventListener('error', event => {})
                    }
                }
            }
            if (!(this.#resource instanceof EventTarget)) return
            let eventMaps = (listen || '').split(',').map(s => s.trim())
            for (const eventMap of eventMaps) {
                if (eventMap === '$') continue
                let [listenToUse=this._defaultListen, dispatchAs] = eventMap.split('|').map(s => s.trim()), listenTo
                if (listenToUse.includes('.')) {
                    let listenToUseSplit = listenToUse.split('.').map(s => s.trim())
                    use = listenToUseSplit.pop() || use
                    listenTo = listenToUseSplit.join('.')
                } else { listenTo = listenToUse }
                dispatchAs ||= listenTo
                this.#resource.addEventListener(listenTo, async event => {
                    let payload = event[use || 'detail']
                    if (contentType && ((typeof payload === 'string') || (payload instanceof Response))) payload = await this.#parse(payload, contentType)
                    if (transform) payload = await this.e.env.libraries.jsonata(transform).evaluate(payload)
                    this.#value = payload
                    if (dispatchAs !== 'change') this.dispatchEvent(new CustomEvent('change', {detail: payload}))
                    this.dispatchEvent(new CustomEvent(dispatchAs, {detail: payload}))
                }, {signal: this.#abortController.signal})
            }
        }

        set via(value) {
            this._setResource(value)
            this.#via = value
        }
        get via() { return this.#via }

        set ['content-type'](value) { this.contentType = value }
        get ['content-type']() { return this.contentType }
        set contentType(value) { this.#contentType = value }
        get contentType() { 
            if (this.#contentType !== this.getAttribute('content-type')) this.contentType = this.getAttribute('content-type')
            return this.#contentType 
        }        

        set listen(value) { this.#listen = value }
        get listen() { 
            if (this.#listen !== this.getAttribute('listen')) this.listen = this.getAttribute('listen')
            return this.#listen 
        }

        set transform(value) { this.#transform = value }
        get transform() {
            if (this.#transform !== this.getAttribute('transform')) this.transform = this.getAttribute('transform')
            return this.#transform
        }

        set options(value) {
            this.#optionsMap = this.e.utils.parseObjectAttribute(value, this)
            this.#options = value
        }
        get options() { return this.#options }
        get optionsMap() { 
            const optionsAttr = this.getAttribute('options')
            if (this.#options !== optionsAttr) this.#optionsMap = this.e.utils.parseObjectAttribute(optionsAttr, this)
            return this.#optionsMap 
        }

        get resource() { return this.#resource }

        get value() { return this.#value }

        async send(payload) {
            if (this.#resourceReady) {
                const sender = (this.e.env.map.get(this) ?? {}).sender, sendMethodName = this.getAttribute('send')
                if (typeof sender === 'function') {
                    await sender(payload, this)
                } else if (sendMethodName && (typeof this.#resource[sendMethodName] === 'function')) {
                    await this.#resource[sendMethodName](payload, this)
                } else if (this._sendMethodName && (typeof this.#resource[this._sendMethodName] === 'function')) {
                    await this.#resource[this._sendMethodName](payload, this)
                } else if (typeof this._sender === 'function') {
                    await this._sender(payload, this)
                }
            } else { this.#sendQueue.push(payload) }
        }

    }
</script>

