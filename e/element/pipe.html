<style></style>
<template></template>
<script>
    export default class extends `meta` {

        #abortController = new AbortController()
        #contentType
        #hub
        #hubAvailable = false
        #options
        #optionsMap = {}
        #queue = []
        #receiver
        #send
        #sender
        #transform
        #value
        #via

        constructor() {
            super()
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('via', 'transform', 'content-type', 'options') }

        async connectedCallback() { }

        send(payload) {
            if (this.#hubAvailable) {
                const sender = (this.E.env.map.get(this) ?? {}).sender ?? this.#sender
                if (typeof sender === 'function') {
                    sender(payload, this)
                } else if (this.#hub instanceof WebSocket) {
                    this.#hub.send(payload)
                } else if (this.#hub instanceof EventSource) {
                    const requestOptions = payload instanceof Object ? payload : { body: JSON.stringify(payload) }
                    fetch(this.#hub.url, { ...(this.optionsMap ?? {}), ...requestOptions })
                } else if (this.#hub instanceof WebTransport) {

                } else if (this.#hub instanceof EventTarget) {
                    const eventDetail = payload instanceof Object ? payload : { detail: payload }
                    this.dispatchEvent(new CustomEvent(this.#via, eventDetail))
                } else if (this.#hub instanceof Object) {
                    const methodName = 'send'
                    if (typeof this.#hub[methodName] === 'function') {
                        this.#hub[methodName](payload)
                    } else {
                        this.#hub[methodName] = payload
                    }
                } else if (this.#hub instanceof Function) {
                    this.#hub(payload)
                } else if (typeof this.#hub === 'string') {
                    const requestOptions = payload instanceof Object ? payload : { body: JSON.stringify(payload) }
                    fetch(this.#hub, { ...(this.optionsMap ?? {}), ...requestOptions }).then(response => this.#receive(response))
                }
            } else { this.#queue.push(payload) }
        }

        async refresh() {

        }

        #createHub(via) {
            this.#hubAvailable = false
            this.#queue = []
            this.#abortController.abort()
            this.#abortController = new AbortController()
            via = this.E.getVariable(via, this)
            if (via[0] === '`' && via.endsWith('`')) {
                let [hubSendStatement, receiverStatement] = via.slice(1, -1).split('!', 2).map(s => s.trim()).filter(s => !!s)
                let [senderStatement, ...hubStatement] = hubSendStatement.split('.').map(s => s.trim()).filter(s => !!s).reverse()
                if (senderStatement && !hubStatement.length) {
                    hubStatement = senderStatement
                    senderStatement = undefined
                } else { hubStatement = hubStatement.join('.') }
                this.#hub = this.E.utils.resolveGlobal(hubStatement, this)
                if (!this.#hub) return
                let [senderName, senderArgs] = senderStatement.split('(').map(s => s.trim()).filter(s => !!s)
                senderArgs = (senderArgs ?? '').slice(0, -1).split(',').map(s => s.trim()).filter(s => !!s)
                this.#sender = payload => {
                    if (typeof this.#hub[senderName] === 'function') {
                        this.#hub[senderName](...senderArgs.map(a => this.E.getVariable(a, this)), payload)
                    } else if ((this.#hub[senderName] instanceof Object) && (payload instanceof Object)) {
                        Object.assign(...this.#hub[senderName], payload)
                    }
                }
                let [receiverName, receiverArgs] = receiverStatement.split(/{|\(|\[/).map(s => s.trim()).filter(s => !!s)
                receiverArgs = (receiverArgs ?? '').slice(0, -1).split(',').map(s => s.trim()).filter(s => !!s)
                if (receiverStatement.includes('(')) {
                    this.#receiver = payload => {
                        if (typeof this.#hub[receiverName] === 'function') this.#hub[receiverName](...receiverArgs.map(a => this.E.getVariable(a, this)), payload)
                    }
                } else {
                    this.#receiver = undefined
                    if (receiverName) this.#hub.addEventListener(receiverName, event => this.#receive(event))
                }
                this.#hubAvailable = true
                for (const j of this.#queue) this.send(j)
            } else if (via.startsWith('wss://')) {
                const makeSocket = () => {
                    const optionsMap = this.optionsMap ?? {}
                    this.#hub = new WebSocket(via, optionsMap.protocols ?? [])
                    if (optionsMap.binaryType) this.#hub.binaryType = optionsMap.binaryType
                    this.#hub.addEventListener('open', event => {
                        this.#hubAvailable = true
                        for (const j of this.#queue) this.send(j)
                    }, { once: true, signal: this.#abortController.signal })
                    this.#hub.addEventListener('error', event => this.#hubAvailable = false, { signal: this.#abortController.signal })
                    this.#hub.addEventListener('close', event => {
                        this.#hubAvailable = false
                        makeSocket()
                    }, { once: true, signal: this.#abortController.signal })
                    this.#hub.addEventListener('message', event => this.#receive(event), { signal: this.#abortController.signal })
                }
                makeSocket()
            } else if (via.startsWith('https://') || via.startsWith('http://')) {
                this.#hub = via
                this.#hubAvailable = true
                for (const j of this.#queue) this.send(j)
            } else if (via.startsWith('sse://')) {
                const [url, events = ['message']] = via.split('!', 2)
                this.#hub = new EventSource(url.replace('sse://', 'https://'), this.optionsMap)
                this.#hub.addEventListener('open', event => {
                    this.#hubAvailable = true
                    for (const j of this.#queue) this.send(j)
                }, { signal: this.#abortController.signal })
                for (const eventName of events) this.#hub.addEventListener(eventName, event => this.#receive(event), { signal: this.#abortController.signal })
            } else if (via.startsWith('wt://')) {
                const makeTransport = () => {
                    this.#hub = new WebTransport(via.replace('wt://', 'https://'), this.optionsMap)
                    this.#hub.ready.then(() => {
                        this.#hubAvailable = true
                        for (const j of this.#queue) this.send(j)
                    })
                    this.#hub.closed.then(() => {
                        this.#hubAvailable = false
                        makeTransport()
                    })
                }
                makeTransport()
            } else if (via) {
                this.#hub = new EventTarget()
                this.addEventListener(via, event => this.#receive(event), { signal: this.#abortController.signal })
                this.#hubAvailable = true
                for (const j of this.#queue) this.send(j)
            }
        }

        #receive(event) {
            this.dispatchEvent(new CustomEvent('receive', { detail: event }))
            const finish = detail => {
                this.#value = detail
                this.dispatchEvent(new CustomEvent('change', { detail }))
            }, process = detail => {
                let transform = this.E.getVariable(this.transform, this)
                if (transform) {
                    try {
                        this.E.expandTransform(transform, this).then(transform => {
                            this.E.env.libraries.jsonata(transform).evaluate(event).then(result => finish(result))
                        })
                    } catch (e) {
                        this.E.utils.processError('transform', e, this, e)
                    }
                } else { finish(result) }
            }
            if (event instanceof MessageEvent) {
                this.#parse(event.data).then(detail => process(detail))
            } else if (event instanceof CustomEvent && (event.detail !== undefined)) {
                this.#parse(event.detail).then(detail => process(detail))
            } else if (event instanceof Response) {
                this.#parse(event).then(detail => process(detail))
            }
        }

        get contentType() { return this.E.utils.safeGet(this, this.#contentType, 'contentType') }
        set contentType(value) { this.#contentType = value }

        get ['content-type']() { return this.contentType }
        set ['content-type'](value) { this.contentType = value }

        get hub() { return this.#hub }

        get options() { return this.E.utils.safeGet(this, this.#options, 'options') }
        set options(value) {
            if (this.#options === value) return
            this.#optionsMap = this.E.utils.parseObjectAttribute(value, this)
            this.#options = value
        }

        get optionsMap() {
            const optionsAttr = this.getAttribute('options')
            if (this.#options !== optionsAttr) this.#optionsMap = this.E.utils.parseObjectAttribute(optionsAttr, this)
            return this.#optionsMap
        }

        get transform() { return this.E.utils.safeGet(this, this.#transform, 'transform') }
        set transform(value) { this.#transform = value }

        get value() { return this.#value }

        get via() { return this.E.utils.safeGet(this, this.#via, 'via') }
        set via(value) {
            if (this.#via === value) return
            this.#createHub(value)
            this.#via = value
        }

        async #parse(value, contentType) {
            const parser = (this.E.env.map.get(this) ?? {}).parser
            contentType ||= this.contentType
            return (typeof parser === 'function') ? (await parser(value, this, contentType)) : (await this.E.parse(value, this, contentType))
        }

        async #serialize(value, contentType) {
            const serializer = (this.E.env.map.get(this) ?? {}).serializer
            return (typeof serializer === 'function') ? (await serializer(value, this, contentType)) : (await this.E.serialize(value, this, contentType))
        }

    }

</script>