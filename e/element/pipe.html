<style></style>
<template></template>
<script>
    class extends `meta` {

        #name
        #scope
        #observe
        #do
        #source
        #sink

    	constructor() {
    		super()
    	}

        toString() { return this.#name }

		static get observedAttributes() { return (super.observedAttributes || []).concat('name', 'scope', 'observe', 'do', 'source', 'sink') }

        async connectedCallback() {
            const observed = this.e.getObserved(this, this.#scope, this.#observe), 
                [sourceNameField, sourceHashVector] = this.#source.trim().split('#', 2).map(s => s.trim()), 
                [sourceName, sourceFieldVector] = sourceNameField.trim().split(/\.(.+)/).map(s => s.trim()), 
                [sinkName, sinkFlag] = this.#sink.trim().split(/\.(.+)/).map(s => s.trim())
            if (!sourceName || !sourceHashVector) return
            const sourceSockets = (sourceName.startsWith('`') && sourceName.endsWith('`')) 
                ? Array.from(observed.querySelectorAll(sourceName.slice(1, -1))) : Array.of(observed.getElementsByTagName('meta')[sourceName]), 
                sinkSockets = (sinkName.startsWith('`') && sinkName.endsWith('`')) 
                ? Array.from(observed.querySelectorAll(sinkName.slice(1, -1))) : Array.of(observed.getElementsByTagName('meta')[sinkName])
            if (!sourceSockets.length) return
            const doSplit = (this.#do||'').trim().split('|').map(s => s.trim())
            for (const eventName of sourceHashVector.trim().split(',')) {
                for (const sourceSocket of sourceSockets) {
                    sourceSocket.addEventListener(eventName, async event => {
                        let data = this.e.applyField(sourceFieldVector, event?.detail instanceof Object ? event.detail : event)
                        for (const doFrag of (this.#do||'').split('|').map(s => s.trim())) {
                            const [processorName, processorFieldVector=''] = doFrag.trim().split(/\.(.+)/).map(s => s.trim())
                            if (!processorName) continue
                            const processorElement = observed.getElementsByTagName('meta')[processorName]
                            if (!processorElement || (typeof processorElement.exec !== 'function')) continue
                            data = this.e.applyField(processorFieldVector, processorElement.exec(data, event))
                        }
                        for (const sinkSocket of sinkSockets) for (const sinkTarget of sinkSocket.targets) this.e.sinkData(sinkTarget, data, sinkSocket, sinkFlag)
                    })
                }
            }
        }

        set name(value) { if (value !== this.#name) this.#name = value }
        get name() { return this.#name }

        set scope(value) { this.#scope = value }
        get scope() { return this.#scope }

        set observe(value) { this.#observe = value }
        get observe() { return this.#observe }        

        set do(value) { this.#do = value }
        get do() { return this.#do }

        set source(value) { this.#source = value }
        get source() { return this.#source }

        set sink(value) { this.#sink = value }
        get sink() { return this.#sink }

    }	
</script>