<style></style>
<template></template>
<script>
    class extends `./abstract/pointer` {

        #module
        #map
        #mapMap
        #abortController

        constructor() {
            super()
            this.#abortController = new AbortController()            
            Object.defineProperties(this, {
                _mode: {configurable: false, enumerable: false, writable: false, value: 'plugin'}, 
                _isReference: {configurable: false, enumerable: false, writable: false, value: true}, 
                _apply: {configurable: false, enumerable: false, value: async (result, target) => {
                        this.#module = result
                        //for (const [s, m] of Object.entries(this.mapMap || {})) this[s] = this.#module[m]
                        let applyMap = this.applyMap
                        if (applyMap) {
                            let applyEntries = Object.entries(this.applyMap ?? {})
                            for (const [role, mm] of applyEntries) {
                                if ((typeof this.#module[mm] === 'function') && role.startsWith('gateway:')) {
                                    const [, protocol] = role.split(':') 
                                    if (protocol) this.e.env.gateways[protocol] = this.#module[mm]
                                } else if (role.startsWith('$')) {
                                    const variableName = role.slice(1)
                                    if (variableName) this.e.env.variables[variableName] = this.#module[mm]
                                } else { continue }
                                delete applyEntries[role]
                            }
                            this.#abortController.abort()
                            this.#abortController = new AbortController()
                            const resolveMarkMergerToken = (token, element) => {
                                if (!token) return '$0'
                                if (typeof token === 'number') return `$${token}`
                                if (token[0] === '.') return element[token.slice(1)]
                                if (token[0] === '@') return element.getAttribute(token.slice(1))
                                if (token === '_') return this.e.getValue(element)
                                if ((token[0] === '`') && token.endsWith('`')) return token.slice(1,-1)
                            }, getResult = (mod, args, element) => {
                                let result
                                if (typeof this.#module[modulePartName] === 'string') {
                                    result = this.#module[modulePartName]
                                    for (let [i,v] of args.entries()) {
                                        let [marker, merger] = (v.includes('=') ? v.split('=').map(s => s.trim()) : [i, v])
                                            .map(tk => resolveMarkMergerToken(tk, t))
                                        result = result.replace(new RegExp(marker, 'g'), merger)
                                    }
                                } else if (typeof this.#module[modulePartName] === 'function') {
                                    result = await this.#module[modulePartName](...args.map(a => resolveMarkMergerToken(a, t)))
                                }
                            }, setResult = (result, role, element) => {
                                if (role === '_') {
                                    this.e.setValue(t, result)
                                } else if (role.startsWith('*')) {
                                    let [fl, tr] = this.e.utils.splitOnce(role.slice(1), ',').map(s => s.trim())
                                    this.e.sinkData(t, result, fl, tr, this)
                                } else if (role.startsWith('.')) {
                                    t[role.slice(1)] = result
                                } else if (role.startsWith('@')) {
                                    t.setAttribute(role.slice(1), result)
                                } else {
                                    const elementMap = this.e.env.map.get(t) ?? {}
                                    elementMap[role] = result
                                    this.e.env.map.set(t, elementMap)
                                }
                            }
                            for (const t of target) {                                
                                for (const [role, mm] of applyEntries) {
                                    let result, modPart
                                    if (mm.includes('(') && mm.endsWith(')')) {
                                        let [modulePartName, ...args] = mm.split('(')
                                        args = args.join('(').slice(0,-1).split(',').map(s => s.trim())
                                        if (this.#module[modulePartName] === undefined) continue
                                        modPart = this.#module[modulePartName]
                                    } else { 
                                        if (this.#module[mm] === undefined) continue
                                        result = this.#module[mm]
                                    }
                                    if ((result === undefined) && !role.startsWith('!')) result = getResult(modPart, args, t)
                                    if (role.startsWith('!')) {
                                        let [eventName, pipeTo] = role.split('|').map(s => s.trim())
                                        eventName = eventName.slice(1)
                                        t.addEventListener(eventName, event => {
                                            setResult(getResult(modPart, arg, t), pipeTo, t)
                                        })
                                    } else {
                                        if (result === undefined) result = getResult(modPart, args, t)
                                        setResult(result, role, t)
                                    }
                                }
                            }
                        }
                    }
                }
            })
        }

        static get observedAttributes() { return (super.observedAttributes || []).concat('parser') }

        set map(value) {
            this.#mapMap = this.e.utils.parseObjectAttribute(value)
            this.#map = value 
        }
        get map() { return this.#map }
        get mapMap() {
            const attrMap = this.getAttribute('map')
            if (attrMap && attrMap!== this.#map) this.map = attrMap
            return this.#mapMap 
        }        

        get module() { return this.#module }

    }
</script>