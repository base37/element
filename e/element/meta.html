<style></style>
<template><slot></slot></template>
<script>
    class extends `./abstract/routable` {

        #parser

    	constructor() {
    		super()
            Object.defineProperties(this, {
                _mode: {configurable: false, enumerable: false, writable: false, value: 'meta'},
                _parse: {configurable: false, enumerable: false, writable: false, value: async (response) => {
                    const text = await this._routable._parse(response), template = document.createElement('template')
                    template.innerHTML = text
                    return template.content.cloneNode(true).children
                }},
                _applyHash: {configurable: false, enumerable: false, writable: false, value: async (parsedResponse) => {
                    const hashResponse = this.e.applyHash(this._hash, await this._routable._applyHash(parsedResponse))
                    const runParser = async text => {
                        let parsed
                        if (this.#parser) {
                            parsed = (typeof this.e.processors[this.#parser] === 'function') ? await this.e.processors[this.#parser](text) : {}
                        } else {
                            parsed = JSON.parse(text)
                        }
                        return parsed
                    }
                    const result = {}
                    if (hashResponse[0].tagName.toLowerCase() === 'script' && hashResponse[0].getAttribute('type') === 'application/json') {
                        try { Object.assign(result, await runParser(hashResponse[0].textContent.trim())) } catch(e) {}
                    }
                    return result
                }}, 
                _applyField: {configurable: false, enumerable: false, writable: false, value: async (parsedResponse) => {
                    return this.e.applyField(this._field, await this._routable._applyField(parsedResponse))
                }}, 
                _as: {configurable: false, enumerable: false, writable: false, value: async (useResponse, addOrRemove, node, previousSibling, nextSibling, oldAttributeValues) => {
                    if (addOrRemove === 'add') this.e.sinkData(node, useResponse, this, this.as)
                }}
            })
    	}

		static get observedAttributes() {
    	    return (super.observedAttributes || []).concat('allow', 'deny', 'alias', 'defaults')
    	}

        set allow(value) { this.#allow = (value||'').split(',').map(a => a.trim()) }
        get allow() { return this.#allow.join(',') }

        set deny(value) { this.#deny = (value||'').split(',').map(a => a.trim()) }
        get deny() { return this.#deny.join(',') }

        set alias(value) { this.#alias = Object.fromEntries((value||'').split(',').map(a => a.trim().split(/:(.+)/).map(a => a.trim()))) }
        get alias() { return Object.entries(this.#alias).map(entry => entry.join(':')).join(',') }

        set defaults(value) { this.#defaults = Object.fromEntries((value||'').split(',').map(a => a.trim().split(/:(.+)/).map(a => a.trim()))) }
        get defaults() { return Object.entries(this.#defaults).map(entry => entry.join(':')).join(',') }

        set parser(value) { this.#parser = value }
        get parser() { return this.#parser }

    }
</script>